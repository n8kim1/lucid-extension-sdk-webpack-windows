"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IframeUI = exports.IncomingUIMessageType = void 0;
const defer_1 = require("../core/defer");
/** @ignore */
var IncomingUIMessageType;
(function (IncomingUIMessageType) {
    IncomingUIMessageType[IncomingUIMessageType["Closed"] = 1] = "Closed";
    IncomingUIMessageType[IncomingUIMessageType["PostMessageFromFrame"] = 2] = "PostMessageFromFrame";
    IncomingUIMessageType[IncomingUIMessageType["FrameLoaded"] = 3] = "FrameLoaded";
    IncomingUIMessageType[IncomingUIMessageType["FramePosition"] = 4] = "FramePosition";
})(IncomingUIMessageType || (exports.IncomingUIMessageType = IncomingUIMessageType = {}));
/**
 * Base class for defining and interacting with custom UI elements whose contents are displayed
 * in an iframe.
 */
class IframeUI {
    constructor(client) {
        this.client = client;
        this.id = ++IframeUI.nextId;
        this.messageActionName = IframeUI.uiMessageActionNamePrefix + this.id;
        /** True after the iframe has fired an onload event (not all scripts are necessarily finished executing) */
        this.loaded = false;
        this.frameLoadedPromise = (0, defer_1.defer)();
        /**
         * The location of this frame within the top-level browser window. This is always updated immediately before
         * `messageFromFrame` is called.
         */
        this.framePosition = { x: 0, y: 0, w: 1, h: 1 };
    }
    /** @ignore */
    static isUIMessageActionName(name) {
        return name.startsWith(IframeUI.uiMessageActionNamePrefix);
    }
    /**
     * Subclasses must call hookMessages some time before the UI is displayed. A Modal
     * will call this when the open() method is called, where a Panel will need to do
     * this in the constructor to watch for the user opening the panel.
     */
    hookMessages() {
        this.client.registerAction(this.messageActionName, (message) => {
            switch (message['t']) {
                case IncomingUIMessageType.Closed:
                    this.loaded = false;
                    this.frameClosed();
                    break;
                case IncomingUIMessageType.PostMessageFromFrame:
                    this.messageFromFrame(message['data']);
                    break;
                case IncomingUIMessageType.FramePosition:
                    this.framePosition = message['data'];
                    break;
                case IncomingUIMessageType.FrameLoaded:
                    this.loaded = true;
                    this.frameLoadedPromise.resolve();
                    this.frameLoaded();
                    break;
            }
        });
    }
    /**
     * Subclasses must call unhookMessages to allow them to be garbage collected.
     */
    unhookMessages() {
        this.client.deleteAction(this.messageActionName);
    }
    /**
     * Send a message to this UI component's iframe via window.postMessage.
     * @param data Data to send to the iframe
     */
    async sendMessage(data) {
        await this.frameLoadedPromise;
        this.client.sendCommand("suim" /* CommandName.SendUIMessage */, {
            'n': this.messageActionName,
            'd': data,
        });
    }
    /**
     * Receives messages sent from the iframe via parent.postMessage(<data>, '*')
     * @param message data sent from the iframe
     */
    messageFromFrame(message) { }
    /**
     * Called when the iframe has been constructed, its srcdoc set, and the window loaded event has fired
     */
    frameLoaded() { }
    /**
     * Called when the iframe has been removed from the DOM
     */
    frameClosed() { }
}
exports.IframeUI = IframeUI;
IframeUI.nextId = 0;
IframeUI.uiMessageActionNamePrefix = '__ui_message__';
