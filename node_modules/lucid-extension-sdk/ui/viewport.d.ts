import { BlockDefinition } from '../document/blockdefinition';
import { ImageDefinition } from '../document/imagedefinition';
import { ItemProxy } from '../document/itemproxy';
import { PageProxy } from '../document/pageproxy';
import { EditorClient } from '../editorclient';
/**
 * A text editing hook provided to [Viewport.hookTextEdit](/extension-sdk/#classes_ui_viewport-Viewport_hooktextedit)
 * may return a TextEditCompletionCallback to specify what behavior should happen when the user finishes editing text.
 *
 * If this callback returns false, the edit is reverted.
 *
 * If this callback returns a string, the typed value is replaced with that string.
 */
export type TextEditCompletionCallback = (newValue: string) => boolean | string | Promise<boolean | string>;
export declare class Viewport {
    private readonly client;
    private static nextHookId;
    constructor(client: EditorClient);
    private static nextHookName;
    /**
     * @param deep If true, and groups are selected, include the contents of those groups in the array
     * @returns An array of currently-selected items on the currently-visible page
     */
    getSelectedItems(deep?: boolean): ItemProxy[];
    /**
     * Unselect all currently-selected items, and select the subset of the given items that exist on
     * the currently-visible page.
     * @param items
     */
    setSelectedItems(items: ItemProxy[]): void;
    /**
     * Find available space on the current page for adding new content.
     * @param width
     * @param height
     * @returns a reference to the page and origin (upper-left point) of the space you can add new
     * content of the given size to.
     */
    findAvailableSpace(width: number, height: number): {
        page: PageProxy;
        x: number;
        y: number;
    };
    /**
     * @returns the page currently being viewed
     */
    getCurrentPage(): PageProxy | undefined;
    /**
     * View the given page in the viewport
     * @param page The page to view
     */
    setCurrentPage(page: PageProxy): void;
    /**
     * @returns the box for the current viewport location
     */
    getVisibleRect(): import("../math").Box;
    /**
     * Switch to the page containing these items, if necessary, and then animate the viewport
     * to zoom in and focus on these items.
     * @param items The items the camera should zoom to
     */
    focusCameraOnItems(items: ItemProxy[]): void;
    /**
     * If {@link callback} returns false, text editing is prevented.
     * If {@link callback} returns true, text editing continues as normal.
     *
     * If {@link callback} returns a {@link TextEditCompletionCallback}(/extension-sdk/#modules_ui_viewport_texteditcompletioncallback),
     * then text editing is allowed, but that completion callback is called.
     *
     * when the user finishes editing that text. That completion callback may return true or false to allow or deny the edit, or
     * also may return a replacement string to use instead of the text the user actually typed. If replacement text is provided,
     * it will be styled as close to the original as possible, but styles that apply to only parts of the original text will be
     * discarded.
     *
     * @param callback Called just before the user starts editing text.
     * @param eager Whether to trigger the callback eagerly during text edit
     *
     * @returns A handle representing this hook, which can be passed to unhookTextEdit to remove this hook.
     */
    hookTextEdit(callback: (item: ItemProxy, textAreaKey: string, text?: string) => boolean | TextEditCompletionCallback | Promise<boolean | TextEditCompletionCallback>, eager?: boolean): string;
    /**
     * Remove a hook set by hookTextEdit.
     *
     * @param handle The return value of hookTextEdit.
     */
    unhookTextEdit(handle: string): void;
    /**
     * @param callback Called when the user changes their selection of items
     *
     * @returns A handle representing this hook, which can be passed to unhookSelection to remove this hook.
     */
    hookSelection(callback: (items: ItemProxy[]) => void): string;
    /**
     * Remove a hook set by hookSelection.
     *
     * @param handle The return value of hookSelection.
     */
    unhookSelection(handle: string): void;
    /**
     * Start an interaction of the current user dragging a new block onto the current page, exactly
     * as if they started dragging that block out of the normal toolbox. At the time this function is
     * called, the user's primary mouse button should be down (e.g. in a mousedown event handler).
     *
     * @param definition Definition of the block to create if and where the user drops it on-canvas
     * @returns A promise resolving to a reference to the created block, if successfully dropped,
     *  or undefined if the user cancels the drag interaction.
     */
    startDraggingNewBlock(definition: BlockDefinition): Promise<import("..").BlockProxy | undefined>;
    /**
     * Start an interaction of the current user dragging a new image onto the current page, exactly
     * as if they started dragging that image out of the normal toolbox. At the time this function is
     * called, the user's primary mouse button should be down (e.g. in a mousedown event handler).
     *
     * @param definition Definition of the image to create if and where the user drops it on-canvas
     * @returns A promise resolving to a reference to the created image, if successfully dropped,
     *  or undefined if the user cancels the drag interaction.
     */
    startDraggingNewImage(definition: ImageDefinition): Promise<import("..").BlockProxy | undefined>;
    /**
     * If startDraggingNewBlock has been called, and the drag-new-block interaction is still active,
     * cancel that interaction.
     */
    cancelDraggingNewBlock(): void;
    /**
     * If startDraggingNewImage has been called, and the drag-new-image interaction is still active,
     * cancel that interaction.
     */
    cancelDraggingNewImage(): void;
    /**
     * After calling startDraggingNewBlock, call this to simulate the user moving the mouse at the
     * given location within the top-level browser window.
     *
     * This has no effect if the drag-new-block interaction is not active.
     *
     * To convert a position in a Panel's iframe to a position in the top-level browser window,
     * add the IframeUI.framePosition.
     */
    dragPointerMove(x: number, y: number): void;
    /**
     * After calling startDraggingNewBlock, call this to simulate the user releasing the mouse
     * button at the given location within the top-level browser window.
     *
     * This has no effect if the drag-new-block interaction is not active.
     *
     * To convert a position in a Panel's iframe to a position in the top-level browser window,
     * add the IframeUI.framePosition.
     */
    dragPointerUp(x: number, y: number): void;
}
