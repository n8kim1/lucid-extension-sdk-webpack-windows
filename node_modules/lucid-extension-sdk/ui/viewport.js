"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Viewport = void 0;
const checks_1 = require("../core/checks");
const fillcolor_1 = require("../core/properties/fillcolor");
const imagedefinition_1 = require("../document/imagedefinition");
const itemproxy_1 = require("../document/itemproxy");
const pageproxy_1 = require("../document/pageproxy");
const math_1 = require("../math");
class Viewport {
    constructor(client) {
        this.client = client;
    }
    static nextHookName() {
        return '__viewport__hook' + Viewport.nextHookId++;
    }
    /**
     * @param deep If true, and groups are selected, include the contents of those groups in the array
     * @returns An array of currently-selected items on the currently-visible page
     */
    getSelectedItems(deep) {
        const ids = this.client.sendCommand("gs" /* CommandName.GetSelection */, { 'd': deep });
        return ids
            .map((id) => this.client.getElementProxy(id))
            .filter((proxy) => proxy instanceof itemproxy_1.ItemProxy);
    }
    /**
     * Unselect all currently-selected items, and select the subset of the given items that exist on
     * the currently-visible page.
     * @param items
     */
    setSelectedItems(items) {
        this.client.sendCommand("ss" /* CommandName.SetSelection */, { 'i': items.map((i) => i.id) });
    }
    /**
     * Find available space on the current page for adding new content.
     * @param width
     * @param height
     * @returns a reference to the page and origin (upper-left point) of the space you can add new
     * content of the given size to.
     */
    findAvailableSpace(width, height) {
        const result = this.client.sendCommand("fas" /* CommandName.FindAvailableSpace */, { 'w': width, 'h': height });
        return {
            page: new pageproxy_1.PageProxy(result['p'], this.client),
            x: result['x'],
            y: result['y'],
        };
    }
    /**
     * @returns the page currently being viewed
     */
    getCurrentPage() {
        const id = this.client.sendCommand("gcp" /* CommandName.GetCurrentPage */, undefined);
        return id == null ? id : new pageproxy_1.PageProxy(id, this.client);
    }
    /**
     * View the given page in the viewport
     * @param page The page to view
     */
    setCurrentPage(page) {
        this.client.sendCommand("scp" /* CommandName.SetCurrentPage */, page.id);
    }
    /**
     * @returns the box for the current viewport location
     */
    getVisibleRect() {
        return this.client.sendCommand("gvr" /* CommandName.GetVisibleRect */, undefined);
    }
    /**
     * Switch to the page containing these items, if necessary, and then animate the viewport
     * to zoom in and focus on these items.
     * @param items The items the camera should zoom to
     */
    focusCameraOnItems(items) {
        const bb = (0, math_1.combinedBoundingBox)(items.map((e) => e.getBoundingBox()));
        if (bb && items[0]) {
            //TODO: A reasonable max zoom level (e.g. 200%)
            this.client.sendCommand("av" /* CommandName.AnimateViewport */, {
                'bb': (0, math_1.padBox)(bb, 80),
                'p': items[0].getPage().id,
            });
        }
    }
    /**
     * If {@link callback} returns false, text editing is prevented.
     * If {@link callback} returns true, text editing continues as normal.
     *
     * If {@link callback} returns a {@link TextEditCompletionCallback}(/extension-sdk/#modules_ui_viewport_texteditcompletioncallback),
     * then text editing is allowed, but that completion callback is called.
     *
     * when the user finishes editing that text. That completion callback may return true or false to allow or deny the edit, or
     * also may return a replacement string to use instead of the text the user actually typed. If replacement text is provided,
     * it will be styled as close to the original as possible, but styles that apply to only parts of the original text will be
     * discarded.
     *
     * @param callback Called just before the user starts editing text.
     * @param eager Whether to trigger the callback eagerly during text edit
     *
     * @returns A handle representing this hook, which can be passed to unhookTextEdit to remove this hook.
     */
    hookTextEdit(callback, eager) {
        const actionName = Viewport.nextHookName();
        this.client.registerAction(actionName, async (textHookParam) => {
            const element = this.client.getElementProxy(textHookParam['i']);
            if (element instanceof itemproxy_1.ItemProxy) {
                const result = await callback(element, textHookParam['t'], textHookParam['v']);
                if ((0, checks_1.isBoolean)(result)) {
                    return result;
                }
                else {
                    const completeName = Viewport.nextHookName();
                    this.client.registerAction(completeName, (textCompleteParam) => {
                        this.client.deleteAction(completeName);
                        return result(textCompleteParam['v']);
                    });
                    return completeName;
                }
            }
            else {
                //Shouldn't be possible, but just in case allow text editing as normal
                return true;
            }
        });
        this.client.sendCommand("hte" /* CommandName.HookTextEdit */, { 'n': actionName, 'e': !!eager });
        return actionName;
    }
    /**
     * Remove a hook set by hookTextEdit.
     *
     * @param handle The return value of hookTextEdit.
     */
    unhookTextEdit(handle) {
        this.client.deleteAction(handle);
        this.client.sendCommand("ute" /* CommandName.UnhookTextEdit */, { 'n': handle });
    }
    /**
     * @param callback Called when the user changes their selection of items
     *
     * @returns A handle representing this hook, which can be passed to unhookSelection to remove this hook.
     */
    hookSelection(callback) {
        const actionName = Viewport.nextHookName();
        this.client.registerAction(actionName, async (param) => {
            const elements = param['ids']
                .map((id) => this.client.getElementProxy(id))
                .filter((element) => element instanceof itemproxy_1.ItemProxy);
            callback(elements);
        });
        this.client.sendCommand("hs" /* CommandName.HookSelection */, { 'n': actionName });
        return actionName;
    }
    /**
     * Remove a hook set by hookSelection.
     *
     * @param handle The return value of hookSelection.
     */
    unhookSelection(handle) {
        this.client.deleteAction(handle);
        this.client.sendCommand("us" /* CommandName.UnhookSelection */, { 'n': handle });
    }
    /**
     * Start an interaction of the current user dragging a new block onto the current page, exactly
     * as if they started dragging that block out of the normal toolbox. At the time this function is
     * called, the user's primary mouse button should be down (e.g. in a mousedown event handler).
     *
     * @param definition Definition of the block to create if and where the user drops it on-canvas
     * @returns A promise resolving to a reference to the created block, if successfully dropped,
     *  or undefined if the user cancels the drag interaction.
     */
    async startDraggingNewBlock(definition) {
        var _a;
        const properties = (_a = definition.properties) !== null && _a !== void 0 ? _a : {};
        if (definition.fillStyle !== undefined) {
            properties['FillColor'] = (0, fillcolor_1.serializeSimpleFill)(definition.fillStyle);
        }
        if (definition.lineWidth !== undefined) {
            properties['LineWidth'] = definition.lineWidth;
        }
        const maybeBlockId = await this.client.sendCommand("sdc" /* CommandName.StartDragBlockToCanvas */, {
            'c': definition.className,
            'sz': {
                'w': definition.boundingBox.w,
                'h': definition.boundingBox.h,
            },
            'p': properties,
            's': definition.stencil,
        });
        return maybeBlockId ? this.client.getBlockProxy(maybeBlockId) : undefined;
    }
    /**
     * Start an interaction of the current user dragging a new image onto the current page, exactly
     * as if they started dragging that image out of the normal toolbox. At the time this function is
     * called, the user's primary mouse button should be down (e.g. in a mousedown event handler).
     *
     * @param definition Definition of the image to create if and where the user drops it on-canvas
     * @returns A promise resolving to a reference to the created image, if successfully dropped,
     *  or undefined if the user cancels the drag interaction.
     */
    async startDraggingNewImage(definition) {
        await this.client.loadBlockClasses(['UserImage2Block']);
        return await this.startDraggingNewBlock((0, imagedefinition_1.imageToBlockDefinition)(definition));
    }
    /**
     * If startDraggingNewBlock has been called, and the drag-new-block interaction is still active,
     * cancel that interaction.
     */
    cancelDraggingNewBlock() {
        this.client.sendCommand("cdc" /* CommandName.CancelDragBlockToCanvas */, undefined);
    }
    /**
     * If startDraggingNewImage has been called, and the drag-new-image interaction is still active,
     * cancel that interaction.
     */
    cancelDraggingNewImage() {
        this.cancelDraggingNewBlock();
    }
    /**
     * After calling startDraggingNewBlock, call this to simulate the user moving the mouse at the
     * given location within the top-level browser window.
     *
     * This has no effect if the drag-new-block interaction is not active.
     *
     * To convert a position in a Panel's iframe to a position in the top-level browser window,
     * add the IframeUI.framePosition.
     */
    dragPointerMove(x, y) {
        this.client.sendCommand("dpm" /* CommandName.DragPointerMove */, { x, y });
    }
    /**
     * After calling startDraggingNewBlock, call this to simulate the user releasing the mouse
     * button at the given location within the top-level browser window.
     *
     * This has no effect if the drag-new-block interaction is not active.
     *
     * To convert a position in a Panel's iframe to a position in the top-level browser window,
     * add the IframeUI.framePosition.
     */
    dragPointerUp(x, y) {
        this.client.sendCommand("dpu" /* CommandName.DragPointerUp */, { x, y });
    }
}
exports.Viewport = Viewport;
Viewport.nextHookId = 0;
