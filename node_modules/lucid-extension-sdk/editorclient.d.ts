import { CommandArgs, CommandName, HashAlgorithmEnum, TriggerAuthFlowResult, UnionToIntersection } from './commandtypes';
import { CardIntegrationConfig } from './core/cardintegration/cardintegrationconfig';
import { JsonObject, JsonSerializable } from './core/jsonserializable';
import { UnfurlCallbacks } from './core/unfurl/unfurlcallbacks';
import { BinaryXHRResponse, OAuthXHRRequest, TextXHRResponse, XHRRequest, XHRResponse } from './core/xhr';
import { CollectionProxy } from './data/collectionproxy';
import { BlockDefinition } from './document/blockdefinition';
import { BlockProxy } from './document/blockproxy';
import { ElementProxy } from './document/elementproxy';
import { GroupProxy } from './document/groupproxy';
import { LineProxy } from './document/lineproxy';
import { PageProxy } from './document/pageproxy';
import { FileUploadData } from './ui/menu';
export type DataActionResponse = {
    /** The HTTP Status Code from the Extension Data Sync endpoint */
    'status': number;
} & ({
    /** The body of the HTTP Response (if Content-Type: application/json) */
    'json': unknown;
} | {
    /** The body of the HTTP Response (otherwise) */
    'text': string;
});
export declare function getResponseBody(response: DataActionResponse): string | JsonObject;
export type DataActionOptions = {
    dataConnectorName: string;
    actionName: string;
    actionData?: unknown;
    syncDataSourceIdNonce?: string;
    asynchronous?: boolean;
};
export declare class EditorClient {
    private nextId;
    protected readonly callbacks: Map<string, (value: any) => JsonSerializable | void | Promise<any>>;
    private getUniqueActionName;
    /**
     * Get which Lucid product this editor extension has been loaded in.
     */
    getProduct(): import(".").LucidProduct;
    /**
     * Unload this extension immediately, removing any custom menu items etc., until the user refreshes the browser tab.
     */
    killExtension(): void;
    /**
     * Unload this extension, and then re-execute it.
     */
    reloadExtension(): void;
    /**
     * Initiate a browser file download of custom content
     * @param filename Filename of the downloaded file
     * @param data The content to put into the file, either in plain text or as base64-encoded binary data
     * @param mime The MIME type to tell the browser it is downloading
     * @param base64 If true, base64 decode the data before downloading it
     */
    download(filename: string, data: string, mime: string, base64: boolean): void;
    /**
     * Upload an image and return a URL that can be used for displaying that image on the canvas. Note: the URL is
     * public - anyone with the URL can access the image.
     * @param data The binary image contents, or a base64-encoded string
     * @param mediaType The media type, e.g. 'image/png'
     * @returns A promise that resolves with the URL of the created image.
     *
     */
    createUserImage(mediaType: string, data: Uint8Array | string): Promise<string>;
    /**
     * @ignore
     * @deprecated Use createUserImage instead.
     */
    experimentalCreateUserImage(mediaType: string, data: Uint8Array | string): Promise<string>;
    performDataAction(options: DataActionOptions): Promise<DataActionResponse>;
    /**
     * If the extension package containing this editor extension has configurable settings,
     * show a standard modal allowing the user to view or change those settings.
     *
     * If the user does not have permission to change settings on this installation of this
     * extension, or if no settings exist, an error is thrown.
     *
     * @returns A promise that resolves when the user closes the settings modal.
     */
    showPackageSettingsModal(): Promise<void>;
    /**
     * If the extension package containing this editor extension has configurable settings, set the
     * value of those settings for this installation of this extension. A subset of setting values
     * can be provided to update those values while leaving others unchanged.
     *
     * If the user does not have permission to change settings on this installation of this
     * extension, or if no settings exist, an error is thrown.
     */
    setPackageSettings(settings: Record<string, string> | Map<string, string>): Promise<undefined>;
    /**
     * If the extension package containing this editor extension has configurable settings,
     * fetch the current values of those settings for this installation of this extension.
     *
     * Only settings that have been set by the installing user will have a value in the map,
     * other settings will be missing.
     *
     * @returns A promise that resolves to a map of setting names to current setting values
     */
    getPackageSettings(): Promise<Map<string, JsonSerializable>>;
    /**
     * @returns True if the current user is allowed to edit package settings on this installation
     * of this extension (if any settings exist), or false otherwise.
     */
    canEditPackageSettings(): Promise<boolean>;
    awaitDataImport(dataConnectorName: string, syncDataSourceId: undefined | string, syncCollectionId: string, primaryKeys: string[], timeout?: number): Promise<CollectionProxy>;
    /** @ignore until spreadsheet integration is ready for launch (CHART-51946) */
    awaitDataSourceImport(dataConnectorName: string, syncDataSourceIdNonce: string): Promise<string>;
    /**
     * Make a network request
     * @param request Settings for the network request
     * @returns A promise that will either resolve or reject with an XHRResponse. If the HTTP status
     *   code is not 2xx, the promise will reject.
     */
    xhr(request: XHRRequest & {
        responseFormat: 'utf8';
    }): Promise<TextXHRResponse>;
    xhr(request: XHRRequest & {
        responseFormat: 'binary';
    }): Promise<BinaryXHRResponse>;
    xhr(request: XHRRequest): Promise<XHRResponse>;
    /**
     * Make an asyncronous OAuth network request. The request is enqueued to eventually execute. The request may be attempted multiple times with
     * an overall timeout of 120 seconds.
     * @param providerName Name of the OAuth provider
     * @param request Settings for the request
     * @returns A promise that will either resolve or reject with an XHRResponse. If the HTTP status
     *   code is not 2xx, the promise will reject.
     */
    asyncOAuthXhr(providerName: string, request: OAuthXHRRequest & {
        responseFormat: 'utf8';
    }): Promise<TextXHRResponse>;
    asyncOAuthXhr(providerName: string, request: OAuthXHRRequest & {
        responseFormat: 'binary';
    }): Promise<BinaryXHRResponse>;
    asyncOAuthXhr(providerName: string, request: OAuthXHRRequest): Promise<XHRResponse>;
    /**
     * Make an OAuth network request. Make the request immediately and only once with a 10 second timeout.
     * @param providerName Name of the OAuth provider
     * @param request Settings for the request
     * @returns A promise that will either resolve or reject with an XHRResponse. If the HTTP status
     *   code is not 2xx, the promise will reject.
     */
    oauthXhr(providerName: string, request: OAuthXHRRequest & {
        responseFormat: 'utf8';
    }): Promise<TextXHRResponse>;
    oauthXhr(providerName: string, request: OAuthXHRRequest & {
        responseFormat: 'binary';
    }): Promise<BinaryXHRResponse>;
    oauthXhr(providerName: string, request: OAuthXHRRequest): Promise<XHRResponse>;
    triggerAuthFlow(providerName: string): TriggerAuthFlowResult;
    /**
     * Returns an OAuth token for the given provider, prompting the user to grant access if necessary
     *
     * @param providerName Name of the OAuth provider
     * @returns An oauth token, or undefined if a valid token cannot be obtained
     */
    getOAuthToken(providerName: string): Promise<string | undefined>;
    /**
     * Fetch the OAuth Client Id if there is one
     *
     * @param providerName Name of the OAuth provider
     * @returns A oauth client id or undefined if it doesn't exist
     */
    getOAuthClientId(providerName: string): Promise<string | undefined>;
    /**
     * Make a request with a permanent token like a merge account token or API key.
     * @param providerName The name of the authorization provider from the manifest
     * @param request Settings for the network request
     * @returns A promise that will either resolve or reject with an XHRResponse. If the HTTP status
     *   code is not 2xx, the promise will reject.
     * @ignore */
    permanentTokenXhr(providerName: string, request: XHRRequest & {
        responseFormat: 'utf8';
    }): Promise<TextXHRResponse>;
    permanentTokenXhr(providerName: string, request: XHRRequest & {
        responseFormat: 'binary';
    }): Promise<BinaryXHRResponse>;
    permanentTokenXhr(providerName: string, request: XHRRequest): Promise<XHRResponse>;
    /**
     * Register a named action. These actions can be triggered from custom UI, for example as the action of a
     * custom menu item.
     *
     * Some actions may return a value that is used by the core application, e.g. a `visibleAction` for a menu
     * item. However, if you return a `Promise` from your callback, that value will be discarded and your
     * action will return `undefined` instead. The ability to provide a callback that returns a Promise is only
     * a convenience so that you can register actions with `async` callbacks for easy async/await.
     *
     * Throws an error if the same action name is registered multiple times.
     *
     * @param name name of the action
     * @param callback function to execute when this action is invoked
     */
    registerAction(name: string, callback: (value: any) => JsonSerializable | void | Promise<any>): void;
    /**
     * Register a named action that receives file upload data. These callbacks can be used in
     * Menu.addMenuItem as the file action.
     * @param name The name of the action
     * @param callback Function to execute when this action is invoked
     */
    registerFileUploadAction(name: string, callback: (files: FileUploadData[]) => void): void;
    /**
     * Registers a handler for link unfurling.
     * @param domain The domain
     * @param callbacks The callbacks to call when a link matching the domain is pasted.
     */
    registerUnfurlHandler(domain: string, callbacks: UnfurlCallbacks): void;
    /**
     * @ignore
     * @deprecated Use registerUnfurlHandler instead.
     */
    experimentalRegisterUnfurlHandler(domain: string, callbacks: UnfurlCallbacks): void;
    /**
     * Remove the callback for a given action. If the action is later invoked, nothing will happen.
     * @param name name of the action to unregister
     */
    deleteAction(name: string): void;
    /**
     * @param name name of the action to check
     * @returns true if a callback has been registered for this action; false otherwise
     */
    actionExists(name: string): boolean;
    /**
     * Execute an API command. This is the low-level API that most of this SDK wraps. It is not expected that you should
     * ever need to use this directly.
     *
     * @param name name of the API command to execute
     * @param params data to pass to the API command
     * @returns the output of the given API command
     */
    sendCommand<C extends CommandName>(name: C, params: UnionToIntersection<CommandArgs[C]['query']>): CommandArgs[C]['result'];
    /**
     * Create and return a proxy for accessing a block with the given ID. If the block is of a type that has a specific
     * proxy implementation (e.g. an ERD block) then a specialized subclass of BlockProxy may be returned.
     *
     * @param id ID of the block to create a proxy for
     * @returns the given block
     */
    getBlockProxy(id: string): BlockProxy;
    /**
     * Because code for block classes are loaded incrementally, you MUST call
     * loadBlockClasses with the given block class name (and wait for it to
     * resolve) before attempting to create a block. If you don't, an error
     * will be thrown.
     *
     * @param classNames the block classes to load
     * @returns a promise that resolves when the block classes can be used to create new blocks on the document
     */
    loadBlockClasses(classNames: string[]): Promise<undefined>;
    /**
     * Import one or pages of the specified document or template into the current document
     * as new pages.
     * NOTE: The indices of the pages to import will change if the pages are rearranged
     * on the source document or template.
     *
     * @param documentId The ID of the document or template to import
     * @param pageNums An array of zero-indexed page indices to import from the document or template
     * @returns a promise that resolves to void when the pages have been imported or the
     * the import failed
     */
    importPage(documentId: string, pageNums: number[]): Promise<void>;
    /**
     * Duplicates one or more pages of the current document as new pages.
     *
     * @param pageNums An array of zero-indexed page indices to duplicate from the current document
     * @returns a promise that resolves to void when the pages have been duplicated or the
     * the duplication failed
     */
    duplicatePages(pageNums: number[]): Promise<void>;
    /**
     * Load the requested shape library's content, and if it was found, return a block definition ready to be
     * created.
     *
     * Example usage:
     * ```inline:typescript
     * const client = new EditorClient();
     * const viewport = new Viewport(client);
     *
     * const page = viewport.getCurrentPage();
     * if (page) {
     *     const def = await page.getCustomShapeDefinition('libraryName', 'shapeName');
     *     if (def) {
     *         //Customize the shape about to be created
     *         def.boundingBox.x = 500;
     *         def.boundingBox.y = 500;
     *
     *         //Create the shape itself
     *         const block = page.addBlock(def);
     *
     *         //Set any data fields on the shape as needed
     *         block.shapeData.set('Value', 50);
     *     }
     * }
     * ```
     * @param library Name of the shape library in this extension to search for
     * @param shape Name of the shape within that library to search for
     * @returns
     */
    getCustomShapeDefinition(library: string, shape: string): Promise<BlockDefinition | undefined>;
    /**
     * @param callback A callback that processes the bootstrap data, if any, stored on the document and
     * associated with this editor extension. If this callback is async (returns a promise), then the
     * bootstrap data is not cleared off of the document until that promise resolves.
     *
     * @param markExtensionAsRequired If bootstrap data is available for this editor extension, this will mark the
     * document as requiring the extension. Once marked, if the extension is not installed the user will be
     * notified about the extension being required on document load. The minimum extension version required by the
     * document is the version provided in the request body when creating the document.
     *
     * @return a promise that resolves immediately if there is no available bootstrap data, or else after
     * the callback successfully completes. This promise will reject/throw if the callback throws or
     * returns a promise that rejects, or if there is another editor session processing the same bootstrap
     * data at the same time.
     */
    processAndClearBootstrapData(callback: (data: JsonSerializable) => void | Promise<void>, markExtensionAsRequired?: boolean): Promise<void>;
    /**
     * @param id ID of the line to create a proxy for
     * @returns the given line
     */
    getLineProxy(id: string): LineProxy;
    /**
     * @param id ID of the page to create a proxy for
     * @returns the given page
     */
    getPageProxy(id: string): PageProxy;
    /**
     * @param id ID of the item to create a proxy for
     * @returns the given item
     */
    getItemProxy(id: string): BlockProxy | LineProxy | GroupProxy;
    /**
     * @param id ID of the item to create a proxy for
     * @returns the given item, or undefined if the item does not exist or an error occurs
     */
    tryGetItemProxy(id: string): BlockProxy | LineProxy | GroupProxy | undefined;
    /**
     * @param id ID of the element to create a proxy for
     * @returns the given element
     */
    getElementProxy(id: string): ElementProxy;
    /**
     * @hidden
     */
    protected listenToEditor(): void;
    /**
     * Display an alert modal to the user
     * @param text Body text to display in the alert modal
     * @param title Title of the alert modal; defaults to the extension title specified in manifest.json
     * @param buttonText Text for the OK button; defaults to "OK" (or a translation)
     * @returns a Promise that resolves true if the user clicks OK, false if they otherwise dismiss the modal
     */
    alert(text: string, title?: string, buttonText?: string): import("./commandtypes").AlertResult;
    /**
     * Display a confirm modal to the user
     * @param text Body text to display in the alert modal
     * @param title Title of the alert modal; defaults to the extension title specified in manifest.json
     * @param okText Text for the OK button; defaults to "OK" (or a translation)
     * @param cancelText Text for the Cancel button; defaults to "Cancel" (or a translation)
     * @returns a Promise that resolves true if the user clicks OK, false if they click Cancel or otherwise dismiss the modal
     */
    confirm(text: string, title?: string, okText?: string, cancelText?: string): import("./commandtypes").ConfirmResult;
    /**
     * Display a prompt modal to the user
     * @param text Body text to display in the alert modal
     * @param title Title of the alert modal; defaults to the extension title specified in manifest.json
     * @returns a Promise that resolves to a string if a user enters one, or undefined if they cancel
     */
    prompt(text: string, title?: string): import("./commandtypes").PromptResult;
    /**
     * Executes the given callback within a mutex scoped to the current document, extension, and the given name.
     * If another editor session currently has the given mutex name locked within the same extension package ID
     * on this same document, this function's returned promise will resolve to false. Otherwise, the mutex will
     * be locked for the duration of the callback and the returned promise will resolve to true.
     * @param name Name of the intra-document mutex to attempt to lock
     * @param callback Code to execute while the mutex is locked, if it is successfully locked
     * @returns A promise resolving to a boolean indicating whether the mutex was successfully locked
     */
    withIntraDocumentMutex(name: string, callback: () => void | Promise<void>): Promise<boolean>;
    /**
     * @param callback Callback that will be executed with the user's local undo/redo history suppressed. This is
     * useful when you want to make changes to a document that will not be erased if the user uses undo or redo,
     * for example adding shape data onto shapes as a result of a background process that collects data from a
     * remote API.
     */
    withSilentActions(callback: () => void): void;
    /**
     * This method fetches the `CardIntegrationConfig` associated with the given data source ID. If you need to change
     * the `CardIntegrationConfig`, you can call this method and mutate the returned object, then return it to the
     * extension API via the `updateCardIntegrationConfig` method. Note that this method has a few best-practices you
     * should be aware of before using it, as detailed in its comment.
     */
    getCardIntegrationConfig(dataSourceId: string): Promise<import("./commandtypes").GetCardIntegrationConfigResult>;
    /**
     * Update the current `CardIntegrationConfig` associated with the given data source ID with the data from the new
     * one provided. This will not remove fields form the fieldDisplaySetings, only add new ones or update existing
     * ones.
     *
     * You should only call this method in response to a user action from the current session, and should be careful
     * when there are multiple collaborators that you are not repeatedly calling this method for all users. Doing so
     * could lead to undefined or unexpected behavior.
     */
    updateCardIntegrationConfig(dataSourceId: string, newConfig: CardIntegrationConfig): Promise<void>;
    /**
     * Hash a particular string using the given algorithm.
     *
     * Hashing can be very slow in extensions, so we provide this utility function to instead run hashing algorithms
     * in the client.
     *
     * @param algorithm Which hashing algorithm to apply to the string. We currently only support SHA256.
     * @param string The raw string we are calculating the hash of.
     * @returns The hashed string.
     */
    /** @ignore because our documentation gets generated incorrectly for an as-yet unknown reason. It seems to refer to the HashAlgorithmEnum with an incorrect link. */
    hash(algorithm: HashAlgorithmEnum, string: string): string;
    constructor();
}
