"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EditorClient = exports.getResponseBody = void 0;
const commandtypes_1 = require("./commandtypes");
const base64_1 = require("./core/base64");
const cardintegrationconfig_1 = require("./core/cardintegration/cardintegrationconfig");
const checks_1 = require("./core/checks");
const unfurldetails_1 = require("./core/unfurl/unfurldetails");
const unfurlrefresherrortype_1 = require("./core/unfurl/unfurlrefresherrortype");
const collectionproxy_1 = require("./data/collectionproxy");
const blockproxyregistry_1 = require("./document/blockclasses/blockproxyregistry");
const customblockproxy_1 = require("./document/blockclasses/customblockproxy");
const linkunfurlblockproxy_1 = require("./document/blockclasses/linkunfurlblockproxy");
const blockproxy_1 = require("./document/blockproxy");
const documentproxy_1 = require("./document/documentproxy");
const elementproxy_1 = require("./document/elementproxy");
const groupproxy_1 = require("./document/groupproxy");
const lineproxy_1 = require("./document/lineproxy");
const pageproxy_1 = require("./document/pageproxy");
const unfurleventmessage_1 = require("./message/unfurleventmessage");
function parseRawXHRResponse(responseFormat, raw) {
    var _a, _b, _c, _d;
    return Object.assign({ url: (_a = raw === null || raw === void 0 ? void 0 : raw['url']) !== null && _a !== void 0 ? _a : '', status: (_b = raw === null || raw === void 0 ? void 0 : raw['s']) !== null && _b !== void 0 ? _b : 0, headers: (_c = raw === null || raw === void 0 ? void 0 : raw['h']) !== null && _c !== void 0 ? _c : {}, timeout: raw === null || raw === void 0 ? void 0 : raw['to'] }, (responseFormat === 'utf8'
        ? {
            responseFormat,
            responseText: (_d = raw === null || raw === void 0 ? void 0 : raw['t']) !== null && _d !== void 0 ? _d : 'An unknown error occurred',
        }
        : {
            responseFormat,
            responseData: (raw === null || raw === void 0 ? void 0 : raw['t']) ? (0, base64_1.decodeBase64)(raw['t']) : new Uint8Array(0),
        }));
}
function getResponseBody(response) {
    if ('json' in response) {
        return response['json'];
    }
    else if ('text' in response) {
        return response['text'];
    }
    else {
        return '';
    }
}
exports.getResponseBody = getResponseBody;
class EditorClient {
    getUniqueActionName() {
        while (this.actionExists('a' + this.nextId)) {
            this.nextId++;
        }
        return 'a' + this.nextId;
    }
    /**
     * Get which Lucid product this editor extension has been loaded in.
     */
    getProduct() {
        return this.sendCommand("gpr" /* CommandName.GetProduct */, undefined);
    }
    /**
     * Unload this extension immediately, removing any custom menu items etc., until the user refreshes the browser tab.
     */
    killExtension() {
        this.sendCommand("k" /* CommandName.KillExtension */, undefined);
    }
    /**
     * Unload this extension, and then re-execute it.
     */
    reloadExtension() {
        this.sendCommand("r" /* CommandName.ReloadExtension */, undefined);
    }
    /**
     * Initiate a browser file download of custom content
     * @param filename Filename of the downloaded file
     * @param data The content to put into the file, either in plain text or as base64-encoded binary data
     * @param mime The MIME type to tell the browser it is downloading
     * @param base64 If true, base64 decode the data before downloading it
     */
    download(filename, data, mime, base64) {
        this.sendCommand("d" /* CommandName.Download */, {
            'f': filename,
            'd': data,
            'm': mime,
            'b64': base64,
        });
    }
    /**
     * Upload an image and return a URL that can be used for displaying that image on the canvas. Note: the URL is
     * public - anyone with the URL can access the image.
     * @param data The binary image contents, or a base64-encoded string
     * @param mediaType The media type, e.g. 'image/png'
     * @returns A promise that resolves with the URL of the created image.
     *
     */
    async createUserImage(mediaType, data) {
        const result = await this.sendCommand("cui" /* CommandName.CreateUserImage */, {
            't': mediaType,
            'd': (0, checks_1.isString)(data) ? data : (0, base64_1.encodeBase64)(data),
        });
        return result['u'];
    }
    /**
     * @ignore
     * @deprecated Use createUserImage instead.
     */
    experimentalCreateUserImage(mediaType, data) {
        return this.createUserImage(mediaType, data);
    }
    async performDataAction(options) {
        if (options.asynchronous === undefined) {
            options.asynchronous = true;
        }
        const result = await this.sendCommand("da" /* CommandName.DataAction */, {
            'fn': options.actionName,
            'a': options.asynchronous,
            's': options.syncDataSourceIdNonce,
            'fd': options.actionData,
            'n': options.dataConnectorName,
        });
        if ('t' in result) {
            return {
                'status': result['c'],
                'text': result['t'],
            };
        }
        return {
            'status': result['c'],
            'json': result['j'],
        };
    }
    /**
     * If the extension package containing this editor extension has configurable settings,
     * show a standard modal allowing the user to view or change those settings.
     *
     * If the user does not have permission to change settings on this installation of this
     * extension, or if no settings exist, an error is thrown.
     *
     * @returns A promise that resolves when the user closes the settings modal.
     */
    async showPackageSettingsModal() {
        return this.sendCommand("spsm" /* CommandName.ShowPackageSettingsModal */, undefined);
    }
    /**
     * If the extension package containing this editor extension has configurable settings, set the
     * value of those settings for this installation of this extension. A subset of setting values
     * can be provided to update those values while leaving others unchanged.
     *
     * If the user does not have permission to change settings on this installation of this
     * extension, or if no settings exist, an error is thrown.
     */
    async setPackageSettings(settings) {
        let settingsAsRecord = {};
        if (settings instanceof Map) {
            for (const [key, value] of settings.entries()) {
                settingsAsRecord[key] = value;
            }
        }
        else {
            settingsAsRecord = settings;
        }
        return this.sendCommand("sps" /* CommandName.SetPackageSettings */, settingsAsRecord);
    }
    /**
     * If the extension package containing this editor extension has configurable settings,
     * fetch the current values of those settings for this installation of this extension.
     *
     * Only settings that have been set by the installing user will have a value in the map,
     * other settings will be missing.
     *
     * @returns A promise that resolves to a map of setting names to current setting values
     */
    async getPackageSettings() {
        return new Map(Object.entries(await this.sendCommand("gps" /* CommandName.GetPackageSettings */, undefined)));
    }
    /**
     * @returns True if the current user is allowed to edit package settings on this installation
     * of this extension (if any settings exist), or false otherwise.
     */
    async canEditPackageSettings() {
        return this.sendCommand("ceps" /* CommandName.CanEditPackageSettings */, undefined);
    }
    async awaitDataImport(dataConnectorName, syncDataSourceId, syncCollectionId, primaryKeys, timeout = 30000) {
        return new collectionproxy_1.CollectionProxy(await this.sendCommand("ai" /* CommandName.AwaitImport */, {
            'n': dataConnectorName,
            's': syncDataSourceId,
            'c': syncCollectionId,
            'pk': primaryKeys,
            't': timeout,
        }), this);
    }
    /** @ignore until spreadsheet integration is ready for launch (CHART-51946) */
    async awaitDataSourceImport(dataConnectorName, syncDataSourceIdNonce) {
        return await this.sendCommand("adi" /* CommandName.AwaitDataSourceImport */, {
            'n': dataConnectorName,
            's': syncDataSourceIdNonce,
        });
    }
    xhr(request) {
        let streamCallback;
        if (request.streamCallback) {
            streamCallback = this.getUniqueActionName();
            this.registerAction(streamCallback, (msg) => { var _a; return (_a = request.streamCallback) === null || _a === void 0 ? void 0 : _a.call(request, msg['d']); });
        }
        const responseFormat = request.responseFormat || 'utf8';
        return this.sendCommand("xhr" /* CommandName.SendXHR */, {
            'url': request.url,
            'm': request.method,
            'd': request.data,
            'h': request.headers,
            'ms': request.timeoutMs,
            'f': responseFormat,
            's': streamCallback,
        })
            .then((raw) => {
            return parseRawXHRResponse(responseFormat, raw);
        })
            .catch((error) => {
            const raw = (0, commandtypes_1.isRawSendXHRResponse)(error) ? error : undefined;
            throw parseRawXHRResponse(responseFormat, raw);
        })
            .finally(() => {
            if (streamCallback) {
                this.deleteAction(streamCallback);
            }
        });
    }
    asyncOAuthXhr(providerName, request) {
        const responseFormat = request.responseFormat || 'utf8';
        return this.sendCommand("aoauth" /* CommandName.SendAsyncOAuthRequest */, Object.assign({ 'url': request.url, 'm': request.method, 'd': request.data, 'h': request.headers, 'ms': request.timeoutMs, 'p': providerName, 'f': responseFormat }, (request.postResultTo ? { 'prt': request.postResultTo } : {})))
            .then((raw) => {
            return parseRawXHRResponse(responseFormat, raw);
        })
            .catch((error) => {
            const raw = (0, commandtypes_1.isRawSendXHRResponse)(error) ? error : undefined;
            throw parseRawXHRResponse(responseFormat, raw);
        });
    }
    oauthXhr(providerName, request) {
        const responseFormat = request.responseFormat || 'utf8';
        return this.sendCommand("oauth" /* CommandName.SendOAuthRequest */, Object.assign({ 'url': request.url, 'm': request.method, 'd': request.data, 'h': request.headers, 'ms': request.timeoutMs, 'p': providerName, 'f': responseFormat }, (request.postResultTo ? { 'prt': request.postResultTo } : {})))
            .then((raw) => {
            return parseRawXHRResponse(responseFormat, raw);
        })
            .catch((error) => {
            const raw = (0, commandtypes_1.isRawSendXHRResponse)(error) ? error : undefined;
            throw parseRawXHRResponse(responseFormat, raw);
        });
    }
    triggerAuthFlow(providerName) {
        return this.sendCommand("tauth" /* CommandName.TriggerAuthFlow */, {
            'p': providerName,
        });
    }
    /**
     * Returns an OAuth token for the given provider, prompting the user to grant access if necessary
     *
     * @param providerName Name of the OAuth provider
     * @returns An oauth token, or undefined if a valid token cannot be obtained
     */
    async getOAuthToken(providerName) {
        return await this.sendCommand("got" /* CommandName.GetOAuthToken */, { 'p': providerName });
    }
    /**
     * Fetch the OAuth Client Id if there is one
     *
     * @param providerName Name of the OAuth provider
     * @returns A oauth client id or undefined if it doesn't exist
     */
    async getOAuthClientId(providerName) {
        return await this.sendCommand("goci" /* CommandName.GetOAuthClientId */, { 'p': providerName });
    }
    permanentTokenXhr(providerName, request) {
        const responseFormat = request.responseFormat || 'utf8';
        return this.sendCommand("perm" /* CommandName.SendPermanentTokenRequest */, {
            'url': request.url,
            'm': request.method,
            'd': request.data,
            'h': request.headers,
            'ms': request.timeoutMs,
            'p': providerName,
            'f': responseFormat,
        })
            .then((raw) => {
            return parseRawXHRResponse(responseFormat, raw);
        })
            .catch((error) => {
            const raw = (0, commandtypes_1.isRawSendXHRResponse)(error) ? error : undefined;
            throw parseRawXHRResponse(responseFormat, raw);
        });
    }
    /**
     * Register a named action. These actions can be triggered from custom UI, for example as the action of a
     * custom menu item.
     *
     * Some actions may return a value that is used by the core application, e.g. a `visibleAction` for a menu
     * item. However, if you return a `Promise` from your callback, that value will be discarded and your
     * action will return `undefined` instead. The ability to provide a callback that returns a Promise is only
     * a convenience so that you can register actions with `async` callbacks for easy async/await.
     *
     * Throws an error if the same action name is registered multiple times.
     *
     * @param name name of the action
     * @param callback function to execute when this action is invoked
     */
    registerAction(name, callback) {
        if (this.actionExists(name)) {
            throw new Error('Action already exists: ' + name);
        }
        this.callbacks.set(name, callback);
    }
    /**
     * Register a named action that receives file upload data. These callbacks can be used in
     * Menu.addMenuItem as the file action.
     * @param name The name of the action
     * @param callback Function to execute when this action is invoked
     */
    registerFileUploadAction(name, callback) {
        this.registerAction(name, (msg) => {
            callback(msg['f'].map((rawFile) => {
                if (rawFile['b']) {
                    return { fileName: rawFile['n'], text: rawFile['t'], binary: (0, base64_1.decodeBase64)(rawFile['b']) };
                }
                else {
                    return { fileName: rawFile['n'], text: rawFile['t'] };
                }
            }));
        });
    }
    /**
     * Registers a handler for link unfurling.
     * @param domain The domain
     * @param callbacks The callbacks to call when a link matching the domain is pasted.
     */
    registerUnfurlHandler(domain, callbacks) {
        const unfurlAction = this.getUniqueActionName();
        let afterUnfurlAction = undefined;
        let expandAction = undefined;
        this.registerAction(unfurlAction, async (rawMsg) => {
            const msg = (0, unfurleventmessage_1.deserializeUnfurlEventMessage)(rawMsg);
            try {
                const result = await callbacks.unfurlCallback(msg.url);
                if (result && !(0, unfurlrefresherrortype_1.unfurlRefreshErrorTypeValidator)(result)) {
                    return (0, unfurldetails_1.serializeUnfurlDetails)(result);
                }
            }
            catch (err) {
                return unfurlrefresherrortype_1.UnfurlRefreshErrorType.GenericFailure;
            }
            return undefined;
        });
        if (callbacks.afterUnfurlCallback) {
            afterUnfurlAction = this.getUniqueActionName();
            this.registerAction(afterUnfurlAction, async (rawMsg) => {
                var _a;
                const msg = (0, unfurleventmessage_1.deserializeUnfurlEventMessage)(rawMsg);
                if (msg.blockId) {
                    const proxy = this.getBlockProxy(msg.blockId);
                    if (proxy instanceof linkunfurlblockproxy_1.LinkUnfurlBlockProxy) {
                        await ((_a = callbacks.afterUnfurlCallback) === null || _a === void 0 ? void 0 : _a.call(callbacks, proxy, msg.url));
                    }
                }
                return undefined;
            });
        }
        if (callbacks.expandCallback) {
            expandAction = this.getUniqueActionName();
            this.registerAction(expandAction, async (rawMsg) => {
                var _a;
                const msg = (0, unfurleventmessage_1.deserializeUnfurlEventMessage)(rawMsg);
                if (msg.blockId) {
                    const proxy = this.getBlockProxy(msg.blockId);
                    if (proxy instanceof linkunfurlblockproxy_1.LinkUnfurlBlockProxy) {
                        await ((_a = callbacks.expandCallback) === null || _a === void 0 ? void 0 : _a.call(callbacks, proxy, msg.url));
                    }
                }
            });
        }
        this.sendCommand("ru" /* CommandName.RegisterUnfurl */, {
            'd': domain,
            'ua': unfurlAction,
            'aua': afterUnfurlAction,
            'e': expandAction,
        });
    }
    /**
     * @ignore
     * @deprecated Use registerUnfurlHandler instead.
     */
    experimentalRegisterUnfurlHandler(domain, callbacks) {
        return this.registerUnfurlHandler(domain, callbacks);
    }
    /**
     * Remove the callback for a given action. If the action is later invoked, nothing will happen.
     * @param name name of the action to unregister
     */
    deleteAction(name) {
        this.callbacks.delete(name);
    }
    /**
     * @param name name of the action to check
     * @returns true if a callback has been registered for this action; false otherwise
     */
    actionExists(name) {
        return this.callbacks.has(name);
    }
    //Note: UnionToIntersection here fixes the type of params required if you're passing in something that's not a single
    //specific command name, to require the type of all possible command names you could pass in, intersected. So if you
    //call this with a CommandName.ListBlocks|CommandName.ListLines it will work as expected but if you just pass in a
    //CommandName, there won't be any possible params you could pass that would meet all the requirements (string & undefined & ...)
    /**
     * Execute an API command. This is the low-level API that most of this SDK wraps. It is not expected that you should
     * ever need to use this directly.
     *
     * @param name name of the API command to execute
     * @param params data to pass to the API command
     * @returns the output of the given API command
     */
    sendCommand(name, params) {
        return lucid.executeCommand(name, params);
    }
    /**
     * Create and return a proxy for accessing a block with the given ID. If the block is of a type that has a specific
     * proxy implementation (e.g. an ERD block) then a specialized subclass of BlockProxy may be returned.
     *
     * @param id ID of the block to create a proxy for
     * @returns the given block
     */
    getBlockProxy(id) {
        const className = this.sendCommand("gp" /* CommandName.GetProperty */, { 'id': id, 'p': 'ClassName' });
        let proxy = (0, blockproxyregistry_1.findProxyClass)(className);
        if (proxy === customblockproxy_1.CustomBlockProxy) {
            proxy = customblockproxy_1.CustomBlockProxy.getCustomBlockClass(this, id);
        }
        if (proxy) {
            return new proxy(id, this);
        }
        else {
            return new blockproxy_1.BlockProxy(id, this);
        }
    }
    /**
     * Because code for block classes are loaded incrementally, you MUST call
     * loadBlockClasses with the given block class name (and wait for it to
     * resolve) before attempting to create a block. If you don't, an error
     * will be thrown.
     *
     * @param classNames the block classes to load
     * @returns a promise that resolves when the block classes can be used to create new blocks on the document
     */
    loadBlockClasses(classNames) {
        return this.sendCommand("lbc" /* CommandName.LoadBlockClasses */, classNames);
    }
    /**
     * Import one or pages of the specified document or template into the current document
     * as new pages.
     * NOTE: The indices of the pages to import will change if the pages are rearranged
     * on the source document or template.
     *
     * @param documentId The ID of the document or template to import
     * @param pageNums An array of zero-indexed page indices to import from the document or template
     * @returns a promise that resolves to void when the pages have been imported or the
     * the import failed
     */
    async importPage(documentId, pageNums) {
        return await this.sendCommand("imp" /* CommandName.ImportPage */, { 'id': documentId, 'n': pageNums });
    }
    /**
     * Duplicates one or more pages of the current document as new pages.
     *
     * @param pageNums An array of zero-indexed page indices to duplicate from the current document
     * @returns a promise that resolves to void when the pages have been duplicated or the
     * the duplication failed
     */
    async duplicatePages(pageNums) {
        return await this.sendCommand("imp" /* CommandName.ImportPage */, {
            'id': this.sendCommand("gdid" /* CommandName.GetDocumentId */, undefined),
            'n': pageNums,
        });
    }
    /**
     * Load the requested shape library's content, and if it was found, return a block definition ready to be
     * created.
     *
     * Example usage:
     * ```inline:typescript
     * const client = new EditorClient();
     * const viewport = new Viewport(client);
     *
     * const page = viewport.getCurrentPage();
     * if (page) {
     *     const def = await page.getCustomShapeDefinition('libraryName', 'shapeName');
     *     if (def) {
     *         //Customize the shape about to be created
     *         def.boundingBox.x = 500;
     *         def.boundingBox.y = 500;
     *
     *         //Create the shape itself
     *         const block = page.addBlock(def);
     *
     *         //Set any data fields on the shape as needed
     *         block.shapeData.set('Value', 50);
     *     }
     * }
     * ```
     * @param library Name of the shape library in this extension to search for
     * @param shape Name of the shape within that library to search for
     * @returns
     */
    async getCustomShapeDefinition(library, shape) {
        await this.loadBlockClasses(['CustomBlock']);
        const shapeData = await this.sendCommand("gcs" /* CommandName.GetCustomShape */, { 'l': library, 's': shape });
        if (shapeData) {
            return {
                className: 'CustomBlock',
                boundingBox: shapeData['bb'],
                stencil: shapeData['s'],
                properties: shapeData['p'],
            };
        }
        return undefined;
    }
    /**
     * @param callback A callback that processes the bootstrap data, if any, stored on the document and
     * associated with this editor extension. If this callback is async (returns a promise), then the
     * bootstrap data is not cleared off of the document until that promise resolves.
     *
     * @param markExtensionAsRequired If bootstrap data is available for this editor extension, this will mark the
     * document as requiring the extension. Once marked, if the extension is not installed the user will be
     * notified about the extension being required on document load. The minimum extension version required by the
     * document is the version provided in the request body when creating the document.
     *
     * @return a promise that resolves immediately if there is no available bootstrap data, or else after
     * the callback successfully completes. This promise will reject/throw if the callback throws or
     * returns a promise that rejects, or if there is another editor session processing the same bootstrap
     * data at the same time.
     */
    async processAndClearBootstrapData(callback, markExtensionAsRequired) {
        const name = this.getUniqueActionName();
        this.registerAction(name, (msg) => {
            return callback(msg['d']);
        });
        await this.sendCommand("b" /* CommandName.Bootstrap */, { 'c': name, 'm': markExtensionAsRequired });
        this.deleteAction(name);
    }
    /**
     * @param id ID of the line to create a proxy for
     * @returns the given line
     */
    getLineProxy(id) {
        return new lineproxy_1.LineProxy(id, this);
    }
    /**
     * @param id ID of the page to create a proxy for
     * @returns the given page
     */
    getPageProxy(id) {
        return new pageproxy_1.PageProxy(id, this);
    }
    /**
     * @param id ID of the item to create a proxy for
     * @returns the given item
     */
    getItemProxy(id) {
        const type = this.sendCommand("get" /* CommandName.GetElementType */, { 'id': id });
        switch (type) {
            case 'block':
                return this.getBlockProxy(id);
            case 'line':
                return this.getLineProxy(id);
            case 'group':
                return new groupproxy_1.GroupProxy(id, this);
            default:
                throw new Error('Element ' + id + ' is not an Item; type found is ' + type);
        }
    }
    /**
     * @param id ID of the item to create a proxy for
     * @returns the given item, or undefined if the item does not exist or an error occurs
     */
    tryGetItemProxy(id) {
        try {
            const item = this.getItemProxy(id);
            if (item.exists()) {
                return item;
            }
        }
        catch (_a) { }
        return undefined;
    }
    /**
     * @param id ID of the element to create a proxy for
     * @returns the given element
     */
    getElementProxy(id) {
        const type = this.sendCommand("get" /* CommandName.GetElementType */, { 'id': id });
        switch (type) {
            case 'block':
                return this.getBlockProxy(id);
            case 'line':
                return this.getLineProxy(id);
            case 'page':
                return this.getPageProxy(id);
            case 'document':
                return new documentproxy_1.DocumentProxy(this);
            case 'group':
                return new groupproxy_1.GroupProxy(id, this);
            default:
                return new elementproxy_1.ElementProxy(id, this);
        }
    }
    /**
     * @hidden
     */
    listenToEditor() {
        lucid.listen((msg) => {
            var _a;
            return (_a = this.callbacks.get(msg['id'])) === null || _a === void 0 ? void 0 : _a(msg);
        });
    }
    /**
     * Display an alert modal to the user
     * @param text Body text to display in the alert modal
     * @param title Title of the alert modal; defaults to the extension title specified in manifest.json
     * @param buttonText Text for the OK button; defaults to "OK" (or a translation)
     * @returns a Promise that resolves true if the user clicks OK, false if they otherwise dismiss the modal
     */
    alert(text, title, buttonText) {
        return this.sendCommand("a" /* CommandName.Alert */, { 't': title, 'b': text, 'bt': buttonText });
    }
    /**
     * Display a confirm modal to the user
     * @param text Body text to display in the alert modal
     * @param title Title of the alert modal; defaults to the extension title specified in manifest.json
     * @param okText Text for the OK button; defaults to "OK" (or a translation)
     * @param cancelText Text for the Cancel button; defaults to "Cancel" (or a translation)
     * @returns a Promise that resolves true if the user clicks OK, false if they click Cancel or otherwise dismiss the modal
     */
    confirm(text, title, okText, cancelText) {
        return this.sendCommand("c" /* CommandName.Confirm */, { 't': title, 'b': text, 'o': okText, 'c': cancelText });
    }
    /**
     * Display a prompt modal to the user
     * @param text Body text to display in the alert modal
     * @param title Title of the alert modal; defaults to the extension title specified in manifest.json
     * @returns a Promise that resolves to a string if a user enters one, or undefined if they cancel
     */
    prompt(text, title) {
        return this.sendCommand("p" /* CommandName.Prompt */, { 't': title, 'b': text });
    }
    /**
     * Executes the given callback within a mutex scoped to the current document, extension, and the given name.
     * If another editor session currently has the given mutex name locked within the same extension package ID
     * on this same document, this function's returned promise will resolve to false. Otherwise, the mutex will
     * be locked for the duration of the callback and the returned promise will resolve to true.
     * @param name Name of the intra-document mutex to attempt to lock
     * @param callback Code to execute while the mutex is locked, if it is successfully locked
     * @returns A promise resolving to a boolean indicating whether the mutex was successfully locked
     */
    async withIntraDocumentMutex(name, callback) {
        const action = this.getUniqueActionName();
        this.registerAction(action, callback);
        try {
            return await this.sendCommand("wm" /* CommandName.WithMutex */, { 'n': name, 'a': action });
        }
        finally {
            this.deleteAction(action);
        }
    }
    /**
     * @param callback Callback that will be executed with the user's local undo/redo history suppressed. This is
     * useful when you want to make changes to a document that will not be erased if the user uses undo or redo,
     * for example adding shape data onto shapes as a result of a background process that collects data from a
     * remote API.
     */
    withSilentActions(callback) {
        const action = this.getUniqueActionName();
        this.registerAction(action, () => {
            const result = callback();
            if ((0, checks_1.isPromise)(result)) {
                throw new Error('withSilentActions cannot be used with an async callback');
            }
        });
        try {
            this.sendCommand("wsa" /* CommandName.WithSilentActions */, { 'a': action });
        }
        finally {
            this.deleteAction(action);
        }
    }
    /**
     * This method fetches the `CardIntegrationConfig` associated with the given data source ID. If you need to change
     * the `CardIntegrationConfig`, you can call this method and mutate the returned object, then return it to the
     * extension API via the `updateCardIntegrationConfig` method. Note that this method has a few best-practices you
     * should be aware of before using it, as detailed in its comment.
     */
    async getCardIntegrationConfig(dataSourceId) {
        return await this.sendCommand("gcic" /* CommandName.GetCardIntegrationConfig */, dataSourceId);
    }
    /**
     * Update the current `CardIntegrationConfig` associated with the given data source ID with the data from the new
     * one provided. This will not remove fields form the fieldDisplaySetings, only add new ones or update existing
     * ones.
     *
     * You should only call this method in response to a user action from the current session, and should be careful
     * when there are multiple collaborators that you are not repeatedly calling this method for all users. Doing so
     * could lead to undefined or unexpected behavior.
     */
    async updateCardIntegrationConfig(dataSourceId, newConfig) {
        return await this.sendCommand("ucic" /* CommandName.UpdateCardIntegrationConfig */, {
            'd': dataSourceId,
            'c': (0, cardintegrationconfig_1.serializeCardIntegrationConfig)(newConfig),
        });
    }
    /**
     * Hash a particular string using the given algorithm.
     *
     * Hashing can be very slow in extensions, so we provide this utility function to instead run hashing algorithms
     * in the client.
     *
     * @param algorithm Which hashing algorithm to apply to the string. We currently only support SHA256.
     * @param string The raw string we are calculating the hash of.
     * @returns The hashed string.
     */
    /** @ignore because our documentation gets generated incorrectly for an as-yet unknown reason. It seems to refer to the HashAlgorithmEnum with an incorrect link. */
    hash(algorithm, string) {
        return this.sendCommand("hsh" /* CommandName.CalculateHash */, { 'a': algorithm, 's': string });
    }
    constructor() {
        this.nextId = 0;
        this.callbacks = new Map();
        this.listenToEditor();
    }
}
exports.EditorClient = EditorClient;
