"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseSchemaDefinition = exports.parseFieldDefinition = exports.serializeSchemaDefinition = exports.serializeFieldDefinition = exports.serializeFieldConstraintDefinition = exports.isFieldConstraintDefinition = exports.minMaxFieldConstraintValidator = void 0;
const checks_1 = require("../core/checks");
const fieldtypedefinition_1 = require("../core/data/fieldtypedefinition/fieldtypedefinition");
const serializedfielddefinition_1 = require("../core/data/serializedfield/serializedfielddefinition");
const validators_1 = require("../core/validators/validators");
function minMaxFieldConstraintValidator(val) {
    return (val === serializedfielddefinition_1.FieldConstraintType.MIN_VALUE ||
        val === serializedfielddefinition_1.FieldConstraintType.MAX_VALUE ||
        val === serializedfielddefinition_1.FieldConstraintType.MAX_LENGTH);
}
exports.minMaxFieldConstraintValidator = minMaxFieldConstraintValidator;
exports.isFieldConstraintDefinition = (0, validators_1.both)((0, validators_1.objectValidator)({
    'type': serializedfielddefinition_1.isFieldConstraintType,
}), (0, validators_1.either)((0, validators_1.objectValidator)({ 'type': minMaxFieldConstraintValidator, 'value': checks_1.isNumber }), (0, validators_1.objectValidator)({ 'type': (0, validators_1.exclude)(serializedfielddefinition_1.isFieldConstraintType, minMaxFieldConstraintValidator), 'value': checks_1.isUndefined })));
/** @ignore */
function serializeFieldConstraintDefinition(constraint) {
    return {
        'Type': constraint.type,
        'Details': constraint.value,
    };
}
exports.serializeFieldConstraintDefinition = serializeFieldConstraintDefinition;
/** @ignore */
function serializeFieldDefinition(field) {
    const serialized = {
        'Name': field.name,
        'Type': (0, fieldtypedefinition_1.serializeFieldTypeDefinition)(field.type),
    };
    if (field.constraints) {
        serialized['Constraints'] = field.constraints.map(serializeFieldConstraintDefinition);
    }
    if (field.mapping) {
        serialized['Mapping'] = field.mapping;
    }
    return serialized;
}
exports.serializeFieldDefinition = serializeFieldDefinition;
/** @ignore */
function serializeSchemaDefinition(def) {
    return {
        'Fields': def.fields.map(serializeFieldDefinition),
        'PrimaryKey': def.primaryKey,
        'FieldLabelOverrides': def.fieldLabels,
    };
}
exports.serializeSchemaDefinition = serializeSchemaDefinition;
/** @ignore */
function parseFieldDefinition(field) {
    var _a;
    return {
        name: field['Name'],
        type: (0, fieldtypedefinition_1.deserializeFieldTypeDefinition)(field['Type']),
        constraints: (_a = field['Constraints']) === null || _a === void 0 ? void 0 : _a.map((constraint) => {
            switch (constraint['Type']) {
                case serializedfielddefinition_1.FieldConstraintType.MIN_VALUE:
                case serializedfielddefinition_1.FieldConstraintType.MAX_VALUE:
                case serializedfielddefinition_1.FieldConstraintType.MAX_LENGTH:
                    if (!(0, checks_1.isNumber)(constraint['Details'])) {
                        throw new Error('Invalid constraint format');
                    }
                    return { type: constraint['Type'], value: constraint['Details'] };
                case serializedfielddefinition_1.FieldConstraintType.REQUIRED:
                case serializedfielddefinition_1.FieldConstraintType.LOCKED:
                case serializedfielddefinition_1.FieldConstraintType.SINGLE_LINE_ONLY:
                case serializedfielddefinition_1.FieldConstraintType.NO_WHITESPACE:
                case serializedfielddefinition_1.FieldConstraintType.UNIQUE_EDIT:
                    return { type: constraint['Type'] };
                default:
                    throw new Error('Invalid constraint format');
            }
        }),
        mapping: field['Mapping'],
    };
}
exports.parseFieldDefinition = parseFieldDefinition;
/** @ignore */
function parseSchemaDefinition(def) {
    return {
        fields: def['Fields'].map(parseFieldDefinition),
        primaryKey: def['PrimaryKey'],
        fieldLabels: def['FieldLabelOverrides'],
    };
}
exports.parseSchemaDefinition = parseSchemaDefinition;
