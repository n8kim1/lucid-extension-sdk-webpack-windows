"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PatchCollectionProxy = exports.PatchedDataItemProxy = void 0;
const dataitemproxy_1 = require("./dataitemproxy");
class PatchedDataItemProxy extends dataitemproxy_1.DataItemProxy {
    constructor(primaryKey, collection, 
    /**
     * The names of all fields that have been changed locally on this data item and
     * not yet synced back to the external data source.
     */
    changedFields, 
    /**
     * The original data item, before local changes. You can query the original values
     * for the changedFields from this data item.
     */
    original, client) {
        super(primaryKey, collection, client);
        this.changedFields = changedFields;
        this.original = original;
    }
}
exports.PatchedDataItemProxy = PatchedDataItemProxy;
class PatchCollectionProxy {
    /**
     * Use CollectionProxy.getLocalChanges() to get a PatchCollectionProxy rather
     * than constructing one directly.
     */
    constructor(client, branchedCollection, patchCollection, originalCollection) {
        this.client = client;
        this.branchedCollection = branchedCollection;
        this.patchCollection = patchCollection;
        this.originalCollection = originalCollection;
    }
    /**
     * @returns all data items that have been added to this collection locally, but that
     * have not yet been synced back to the external data source.
     */
    getAddedItems() {
        //Note: We could get this list directly from the metadata collection associated with the
        //patch collection, but at this time we're not sure we want to expose metadata collections
        //to the extension API, so this somewhat less-performance-optimal solution seems like the
        //best overall answer.
        return this.patchCollection.items.filter((item, primaryKey) => !this.originalCollection.items.get(primaryKey).exists());
    }
    /**
     * @returns all data items that were deleted from this collection locally, but that
     * have not yet been deleted in the external data source.
     */
    getDeletedItems() {
        //See comment in getAddedItems
        return this.originalCollection.items.filter((item, primaryKey) => !this.branchedCollection.items.get(primaryKey).exists());
    }
    /**
     * @returns all data items that have been changed locally, but that have not
     * yet been synced back to the external data source.
     */
    getChangedItems() {
        const changed = [];
        for (const [primaryKey, patchItem] of this.patchCollection.items) {
            const original = this.originalCollection.items.get(primaryKey);
            if (original.exists()) {
                //Not just using .keys() because we want to filter out undefined values,
                //which the `for...of` iterator on patchItem.fields (MapProxy) does for us.
                const changedFields = [];
                for (const [key] of patchItem.fields) {
                    changedFields.push(key);
                }
                changed.push(new PatchedDataItemProxy(primaryKey, this.branchedCollection, changedFields, original, this.client));
            }
        }
        return changed;
    }
}
exports.PatchCollectionProxy = PatchCollectionProxy;
