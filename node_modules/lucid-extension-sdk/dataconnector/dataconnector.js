"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataConnector = exports.DataConnectorResponseError = exports.DataConnectorRequestState = exports.DataConnectorRequestError = exports.DataConnectorRunError = void 0;
const checks_1 = require("../core/checks");
const validators_1 = require("../core/validators/validators");
const action_1 = require("./actions/action");
const dataconnectoractionkeys_1 = require("./actions/dataconnectoractionkeys");
const managewebhookresponsebody_1 = require("./actions/managewebhookresponsebody");
const patch_1 = require("./actions/patch");
const patchresponsebody_1 = require("./actions/patchresponsebody");
const debugserver_1 = require("./debugserver");
const itemrekeyerandrelabeler_1 = require("./itemrekeyerandrelabeler");
/** Throw this from an action request handler to produce a non-200 response code and not have to return the expected
 * result type */
class DataConnectorRunError extends Error {
    constructor(status, body, message) {
        super(message !== null && message !== void 0 ? message : JSON.stringify(body));
        this.status = status;
        this.body = body;
    }
    static withMessage(status, message) {
        return new DataConnectorRunError(status, { error: message }, message);
    }
}
exports.DataConnectorRunError = DataConnectorRunError;
/** Thrown by any failable http APIs */
class DataConnectorRequestError extends Error {
    constructor(status, message, response, statusText) {
        super(message);
        this.status = status;
        this.response = response;
        this.statusText = statusText;
    }
    toString() {
        return `${this.message} ${this.statusText ? this.statusText + ' ' : ''}(${this.status}) ${this.response}`;
    }
}
exports.DataConnectorRequestError = DataConnectorRequestError;
class DataConnectorRequestState {
    constructor(itemRekeyer) {
        this.itemRekeyer = itemRekeyer;
    }
}
exports.DataConnectorRequestState = DataConnectorRequestState;
/** Thrown by any APIs the client didn't recognize when parsing */
class DataConnectorResponseError extends Error {
    constructor(message, response) {
        super(message);
        this.response = response;
    }
}
exports.DataConnectorResponseError = DataConnectorResponseError;
/** Factory class to define a bunch of action handlers. */
class DataConnector {
    constructor(client, optPatchParser) {
        this.client = client;
        this.actions = {};
        this.routes = {};
        this.patchParser = optPatchParser !== null && optPatchParser !== void 0 ? optPatchParser : patch_1.itemPatchParser;
    }
    /** Factory to define an action request handler */
    defineAction(name, request, asynchronous = false) {
        this.actions[name] = {
            actionResponder: request,
            asynchronous,
        };
        return this;
    }
    /** Factory to define an asynchronous action request handler */
    defineAsynchronousAction(name, request) {
        return this.defineAction(name, request, true);
    }
    /** Factory to define a route handler */
    defineRoute(name, request) {
        this.routes[name] = request;
        return this;
    }
    /** Call a defined action handler and gather its serialized response */
    async runAction(url, headers, body) {
        const state = new DataConnectorRequestState(new itemrekeyerandrelabeler_1.ItemRekeyerAndRelabeler());
        const actions = await this.client.parseActions(url, headers, body, this.patchParser);
        if (!actions) {
            console.warn('Received bad request', url, headers, body);
            return { status: 404, body: { error: 'Bad request' } };
        }
        const actionName = actions[0].name;
        try {
            const responses = [];
            for (const action of actions) {
                if (!(action.name in this.actions)) {
                    throw DataConnectorRunError.withMessage(404, `Action ${action.name} is not implemented`);
                }
                const { actionResponder, asynchronous } = this.actions[action.name];
                const response = (() => {
                    if (asynchronous) {
                        if (!(action instanceof action_1.DataConnectorAsynchronousAction)) {
                            throw DataConnectorRunError.withMessage(400, `Passing uncredentialed action to ${action.name} which is defined to be asynchronous`);
                        }
                        return actionResponder(action, state);
                    }
                    else {
                        return actionResponder(action, state);
                    }
                })();
                responses.push(await response);
            }
            if (actionName === dataconnectoractionkeys_1.DataConnectorActionKeys.ManageWebhook) {
                const response = responses[0];
                // leave the type on this variable because our return type isn't strict. This means that
                // changes to serializeManageWebhookResponse's return type will need to consider this point
                const body = (0, managewebhookresponsebody_1.serializeManageWebhookResponse)(response);
                return { status: 200, body };
            }
            if (actionName === dataconnectoractionkeys_1.DataConnectorActionKeys.Patch || actionName === dataconnectoractionkeys_1.DataConnectorActionKeys.UnbatchedPatch) {
                const responsesCasted = responses;
                // leave the type on this variable because our return type isn't strict. This means that
                // changes to serializePatchChanges's return type will need to consider this point
                const body = (0, patchresponsebody_1.serializePatchChanges)(responsesCasted);
                return { status: 200, body };
            }
            else if (responses.length === 1) {
                return { status: 200, body: responses[0] };
            }
            else {
                return { status: 200, body: responses };
            }
        }
        catch (e) {
            const errorLogger = console.error ? console.error : console.log;
            errorLogger(`Error running ${actionName} action`, e);
            if (isDataConnectorRunError(e)) {
                return { status: e.status, body: e.body };
            }
            else {
                return { status: 500, body: { error: `error running ${actionName} action` } };
            }
        }
    }
    /** Add a route to the given express app (or generate a new app) to serve this data connector */
    routeDebugServer(options) {
        return (0, debugserver_1.routeDebugServer)(this, options);
    }
    /**
     * Serve this data connector as a simple express app for debugging purposes
     */
    runDebugServer(options) {
        (0, debugserver_1.runDebugServer)(this, options);
    }
}
exports.DataConnector = DataConnector;
// instanceof DataConnectorRunError will not work in some environments
const isDataConnectorRunError = (0, validators_1.objectValidator)({
    status: checks_1.isNumber,
    body: checks_1.isUnknown,
});
