import { SemanticCollection } from '../core/data/datasource/semanticcollection';
import { SourceForeignKey } from '../core/data/datasource/sourceforeignkeys';
import { UpdateCreationPermission } from '../core/data/datasource/updatecreationpermission';
import { UpstreamPatchType } from '../core/data/datasource/upstreampatchtype';
import { SerializedFieldTypeDefinition } from '../core/data/fieldtypedefinition/fieldtypedefinition';
import { LucidFields } from '../core/data/fieldtypedefinition/lucidfields';
import { SemanticFields } from '../core/data/fieldtypedefinition/semanticfields';
import { SemanticKind } from '../core/data/fieldtypedefinition/semantickind';
import { FieldConstraintType } from '../core/data/serializedfield/serializedfielddefinition';
import { SerializedFields, SerializedLucidDictionary } from '../core/data/serializedfield/serializedfields';
import { SerializedLabelOverrides } from '../core/data/serializedfield/serializedschema';
import { JsonSerializable } from '../core/jsonserializable';
import { DataUpdateFilterType } from '../data/dataupdatefiltertype';
import { FieldDefinition, SchemaDefinition } from '../data/schemadefinition';
/**
 * Container for an update to a data source
 */
export type DataSourceRequest = {
    /** The current update filter type associated with this request */
    updateFilterType?: DataUpdateFilterType;
    /** The name of the data source to be added or modified */
    dataSourceName: string;
    /** Collections to add or update to the data source */
    collections: Record<string, CollectionPatch>;
    /** Configuration for the data source to be added or modified */
    dataSourceConfiguration?: {
        /** Configures how changes made to the data are pushed to the external source */
        patchType: UpstreamPatchType;
    };
    /** Configuration for relationships between collections in the data source */
    sourceForeignKeys?: SourceForeignKey[];
    /** The level of permission the request has to create data */
    creationPermission?: UpdateCreationPermission;
};
type SerializedFieldConstraintForApi = {
    'type': FieldConstraintType;
    'details'?: JsonSerializable;
};
type SerializedFieldDefinitionForApi = {
    'name': string;
    'type': SerializedFieldTypeDefinition;
    'constraints': SerializedFieldConstraintForApi[];
    'syncSchema'?: string;
    'mapping'?: readonly SemanticKind[] | readonly LucidFields[] | readonly SemanticFields[];
};
export type SerializedSchemaForApi = {
    'fields': SerializedFieldDefinitionForApi[];
    'primaryKey': string[];
    'fieldLabelOverrides'?: SerializedLabelOverrides | undefined;
};
type serializedPropertiesForApi = {
    'Represents'?: SemanticCollection[];
    'Name'?: string;
};
export interface SerializedCollectionPatch {
    'schema'?: SerializedSchemaForApi;
    'itemsPatch': SerializedItemsPatch;
    'properties'?: serializedPropertiesForApi;
}
export declare class ItemsPatchInexhaustive {
    /**
     * Items to be added or changed in the collection. Mapping from item serialized primary key to
     * the sparse patch of the item. See FormattedPrimaryKey.forItem.
     **/
    items: Map<string, SerializedFields>;
    /** Items to remove from the collection, based on the same primary key algorithm. */
    itemsDeleted?: string[] | undefined;
    errors?: Map<string, SerializedLucidDictionary> | undefined;
    private readonly _brand;
    constructor(
    /**
     * Items to be added or changed in the collection. Mapping from item serialized primary key to
     * the sparse patch of the item. See FormattedPrimaryKey.forItem.
     **/
    items: Map<string, SerializedFields>, 
    /** Items to remove from the collection, based on the same primary key algorithm. */
    itemsDeleted?: string[] | undefined, errors?: Map<string, SerializedLucidDictionary> | undefined);
}
export declare class ItemsPatchExhaustive {
    items: Map<string, SerializedFields>;
    rekeyingMap?: Map<string, string | null> | undefined;
    fieldNamesChanged?: Map<string, string | null> | undefined;
    errors?: Map<string, SerializedLucidDictionary> | undefined;
    private readonly _brand;
    constructor(items: Map<string, SerializedFields>, rekeyingMap?: Map<string, string | null> | undefined, fieldNamesChanged?: Map<string, string | null> | undefined, errors?: Map<string, SerializedLucidDictionary> | undefined);
}
export type ItemsPatch = {
    /**
     * Items to be added or changed in the collection. Mapping from item serialized primary key to
     * the sparse patch of the item. See FormattedPrimaryKey.forItem.
     **/
    items: Map<string, SerializedFields>;
    /** Items to remove from the collection, based on the same primary key algorithm. */
    itemsDeleted?: string[];
    /** Errors found while patching the items */
    errors?: Map<string, SerializedLucidDictionary>;
} | ItemsPatchInexhaustive | ItemsPatchExhaustive;
export type SerializedItemsPatch = {
    'items': Record<string, SerializedFields>;
    'itemsDeleted': string[];
    'errors'?: Record<string, SerializedLucidDictionary>;
} | {
    'exhaustiveItems': Record<string, SerializedFields>;
    'rekeyingMap'?: Record<string, string | null>;
    'fieldNamesChanged'?: Record<string, string | null>;
    'errors'?: Record<string, SerializedLucidDictionary>;
};
export declare function serializeItemsPatch(patch: ItemsPatch): SerializedItemsPatch;
/**
 * A patch to a collection or the definition of a new collection to be added. If adding a new collection, a schema must
 * be provided. If modifying an existing collection, a schema may be omitted.
 **/
export interface CollectionPatch {
    /**
     * If changing an existing schema only the following changes are allowed:
     *
     * 1. Adding a nullable field
     * 2. Promoting a type of a field to a union of types (`string` -> `string | number`)
     * 3. Adding a new variant to a union type (`string | number` -> `string | number | boolean`)
     *
     * * Removing a field is not allowed (just add `| null` and don't provide the field in patches anymore).
     * * Changing a type in a way that any existing legal value is no longer valid for that field is not allowed.
     */
    schema?: SchemaDefinition;
    /** The patch to apply to the collection */
    patch: ItemsPatch;
    /** What the collection implicitly represents **/
    represents?: SemanticCollection[];
    /** The collection's display name */
    name?: string | undefined;
    /** Whether the collection is hidden from the data panel */
    hideFromDataPanel?: boolean;
}
/** @ignore */
export declare function serializeFieldDefinitionForApi(field: FieldDefinition): SerializedFieldDefinitionForApi;
export declare function serializeSchemaForApi(schema: SchemaDefinition): SerializedSchemaForApi;
export declare function serializeCollectionPatch(patch: CollectionPatch): SerializedCollectionPatch;
/**
 * For the moment, when the upstream Google Sheet is changed in such a way that the schema has changed, we simply
 * stop updates from happening. We do need to alert the user that this has happened, though. This is a utility function
 * for creating the appropriate entry in the errors map so that the user can be alerted that updates have stopped
 * and what they need to do to fix it.
 *
 * The eventual, proposed fix is to allow schemas to have version numbers so that changes to the schema from Google
 * can simply be folded in to the on-document copies of the data and all following edits.
 *
 * @param oldPrimaryKey The primary key stored in the data sync service and which currently is used to interpret
 * patches.
 * @param newPrimaryKey The primary key as it has been changed in the real Google Sheets.
 * @returns The error map entry which alerts the document that this problem has happened.
 */
export declare function schemaOutOfSyncStatus(oldPrimaryKey: string[], newPrimaryKey: string[]): [string, SerializedLucidDictionary];
/**
 * For the moment, when the upstream Google Sheet is changed in such a way that the schema has changed, we simply
 * stop updates from happening. We do need to alert the user that this has happened, though. We also need to know when
 * the updates are happening properly so we can clear the error once the user has resolved the problem. Since the
 * only way to delete errors is to overwrite them, we simply overwrite the error to be OK on every successful
 * import.
 * @returns The error map entry which alerts the document that this problem has been resolved.
 */
export declare function schemaOKStatus(): [string, SerializedLucidDictionary];
export {};
