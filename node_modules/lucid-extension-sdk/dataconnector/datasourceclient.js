"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockDataSourceClient = exports.DataSourceClient = void 0;
const checks_1 = require("../core/checks");
const datasourcetype_1 = require("../core/data/datasource/datasourcetype");
const sourceforeignkeys_1 = require("../core/data/datasource/sourceforeignkeys");
const upstreamconfig_1 = require("../core/data/datasource/upstreamconfig");
const upstreamupdatetype_1 = require("../core/data/datasource/upstreamupdatetype");
const result_1 = require("../core/result");
const validators_1 = require("../core/validators/validators");
const dataconnector_1 = require("./dataconnector");
const datasourcemetadatatypes_1 = require("./datasourcemetadatatypes");
const datasourceupdatetypes_1 = require("./datasourceupdatetypes");
const defaultfetchfunction_1 = require("./defaultfetchfunction");
const throwunsuccessful_1 = require("./throwunsuccessful");
const QueryParamLengthLimit = 2000;
/**
 * Authenticated client for DataSource related requests to Lucid.
 */
class DataSourceClient {
    constructor(urls, updateToken, fetchMethod = defaultfetchfunction_1.globalFetch) {
        this.urls = urls;
        this.updateToken = updateToken;
        this.fetchMethod = fetchMethod;
        const dataSyncUrl = urls.dataSync;
        this.metadataUrl = (0, checks_1.isString)(dataSyncUrl) ? `${dataSyncUrl}dataSource/metadata` : undefined;
    }
    formatBody({ dataSourceName, collections, updateFilterType, dataSourceConfiguration, sourceForeignKeys, creationPermission, }) {
        const updateData = {};
        for (const collectionId in collections) {
            updateData[collectionId] = (0, datasourceupdatetypes_1.serializeCollectionPatch)(collections[collectionId]);
        }
        const updateFilterTypeObj = updateFilterType ? { 'UpdateFilterType': updateFilterType } : {};
        const upstreamConfig = {
            dataSourceType: datasourcetype_1.DataSourceType.DataService,
            updateType: upstreamupdatetype_1.UpstreamUpdateType.EVENTPULL,
            patchType: dataSourceConfiguration === null || dataSourceConfiguration === void 0 ? void 0 : dataSourceConfiguration.patchType,
            sourceConfig: Object.assign({}, updateFilterTypeObj),
        };
        const foreignKeys = sourceForeignKeys ? sourceForeignKeys.map(sourceforeignkeys_1.serializeSourceForeignKey) : [];
        return {
            'updateData': updateData,
            'name': dataSourceName,
            'upstreamConfig': (0, upstreamconfig_1.serializeUpstreamConfig)(upstreamConfig),
            'sourceForeignKeys': foreignKeys,
            'creationPermission': creationPermission,
        };
    }
    /** Create or update a datasource. If you create a new collection it must be fully specified in terms of schema and
     * and items. If it's just an update then the schema can be omitted (if unchanged) and items that already exist can
     * be partial.*/
    async update(request) {
        const response = await this.fetchMethod(`${this.urls.api}data/dataSource/update`, {
            'method': 'POST',
            'headers': {
                'Content-Type': 'application/json',
                'data-update-token': this.updateToken,
                'Lucid-Api-Version': '1',
            },
            'body': JSON.stringify(this.formatBody(request)),
        });
        await (0, throwunsuccessful_1.throwUnsuccessful)(response, 'updating data source');
        // webhooks return 200 with an empty body
        // document updates return valid json
        // we can't use .json because that will fail for webhooks
        // if we update the response type for webhook updates
        // we can handle that here too. We should probably unify the responses
        // to be meaningful
        // we could just:
        // return await response.text();
        // but lets avoid users trying to interpret the response
    }
    /**
     * When dealing with data, we can often have a very large number of collections in a single data source, and in
     * turn, we may well end up get the values for a very large number of metadata values per collection.
     * Because the endpoints for metadata use query params to encode the metadata names, and because metadata value
     * reads can be easily parallelized, and because URLs have length limits, this function constructs an array of
     * query params that are certain to be short enough that each individual query will be a safe length, while still
     * getting *all* of the requested data.
     * @param keys The metadata keys we are requesting from the data sync service for the corresponding data source.
     * @param prefixes The metadata prefixes we are requesting from the data sync service for the corresponding data source.
     * @returns An array of query params such that each query param is short enough to be safe, but all params combined
     *             cover all requested metadata.
     */
    getLengthLimitedQueryParams(keys, prefixes) {
        const keyQueryParams = keys.map(encodeURIComponent).map((keyVal) => `metadataKeys=${keyVal}`);
        const prefixQueryParams = prefixes.map(encodeURIComponent).map((prefixVal) => `metadataPrefixes=${prefixVal}`);
        const fullQueryParams = [];
        let currentQueryParam = '';
        let delimiter = '?';
        [...keyQueryParams, ...prefixQueryParams].forEach((param) => {
            currentQueryParam = currentQueryParam.concat(`${delimiter}${param}`);
            if (currentQueryParam.length > QueryParamLengthLimit) {
                fullQueryParams.push(currentQueryParam);
                currentQueryParam = '';
                delimiter = '?';
            }
            else {
                delimiter = '&';
            }
        });
        if (currentQueryParam.length > 0) {
            fullQueryParams.push(currentQueryParam);
        }
        return fullQueryParams;
    }
    async getResponseOrError(url) {
        const response = await this.fetchMethod(url, {
            'method': 'GET',
            'headers': {
                'Content-Type': 'application/json',
                'data-update-token': this.updateToken,
                'Lucid-Api-Version': '1',
            },
        });
        try {
            await (0, throwunsuccessful_1.throwUnsuccessful)(response, 'getting data source`s metadata');
        }
        catch (e) {
            if (e instanceof dataconnector_1.DataConnectorResponseError) {
                return { error: { url, body: e.response } };
            }
            throw e;
        }
        const responseBody = await response.json();
        if ((0, validators_1.arrayValidator)(datasourcemetadatatypes_1.isSerializedMetadataRecord)(responseBody)) {
            return {
                value: responseBody.map((rawResponse) => {
                    return {
                        key: rawResponse['key'],
                        value: rawResponse['value'],
                    };
                }),
            };
        }
        else {
            return {
                error: { url, body: responseBody },
            };
        }
    }
    /** @ignore until metadata endpoints are made part of the public API */
    async getMetadata(keys, prefixes = []) {
        if (this.metadataUrl == null) {
            throw new Error('Attempted to access data sync service metadata endpoints in environment where the URL does not exist!');
        }
        const queryParamsList = this.getLengthLimitedQueryParams(keys, prefixes);
        const urlsWithParams = queryParamsList.map((query) => `${this.metadataUrl}${query}`);
        const responsePromises = urlsWithParams.map((url) => this.getResponseOrError(url));
        const responses = await Promise.all(responsePromises);
        const records = [];
        const errors = [];
        responses.forEach((response) => {
            if ((0, result_1.isSuccess)(response)) {
                records.push(...response.value);
            }
            else {
                errors.push(response.error);
            }
        });
        if (errors.length > 0) {
            const message = `Error(s) received accessing URL(s): ${errors.map(({ url }) => url).join(',')}`;
            const allBodies = errors.map(({ body }) => body);
            throw new dataconnector_1.DataConnectorResponseError(message, JSON.stringify(allBodies));
        }
        return records;
    }
    /** @ignore until metadata endpoints are made part of the public API */
    async patchMetadata(patches) {
        if (this.metadataUrl == null) {
            throw new Error('Attempted to access data sync service metadata endpoints in environment where the URL does not exist!');
        }
        const serializedPatches = patches.map((patch) => {
            return {
                'key': patch.key,
                'oldValue': patch.oldValue,
                'newValue': patch.newValue,
            };
        });
        const response = await this.fetchMethod(this.metadataUrl, {
            'method': 'PATCH',
            'headers': {
                'Content-Type': 'application/json',
                'data-update-token': this.updateToken,
                'Lucid-Api-Version': '1',
            },
            body: JSON.stringify(serializedPatches),
        });
        if (response.status === 409) {
            const responseBody = await response.json();
            if ((0, validators_1.arrayValidator)(datasourcemetadatatypes_1.isSerializedMetadataRecord)(responseBody)) {
                return {
                    status: 'Conflict',
                    records: responseBody.map((record) => {
                        return {
                            key: record['key'],
                            value: record['value'],
                        };
                    }),
                };
            }
            throw new dataconnector_1.DataConnectorResponseError(`Invalid conflict response to query at '${this.metadataUrl}'! Expected an array of serialized metadata records`, JSON.stringify(responseBody));
        }
        await (0, throwunsuccessful_1.throwUnsuccessful)(response, 'patching data source`s metadata');
        return { status: 'NoContent' };
    }
}
exports.DataSourceClient = DataSourceClient;
/**
 * A version of the DataSourceClient that you can use for any automated tests of your data connector.
 * Modify the `gotUpdate` field to change the behaviour of the update method.
 **/
class MockDataSourceClient extends DataSourceClient {
    constructor() {
        super({ main: '', api: '' }, '');
        /** Assign this to your mocked update function */
        this.gotUpdate = (request) => {
            throw new Error(`Didn't mock request: ${JSON.stringify(request)}`);
        };
        /** Assign this to your mocked update function */
        this.gotMetadata = (request) => {
            throw new Error(`Didn't mock request: ${JSON.stringify(request)}`);
        };
        /** Assign this to your mocked update function */
        this.patchedMetadata = (request) => {
            throw new Error(`Didn't mock request: ${JSON.stringify(request)}`);
        };
    }
    /** @ignore */
    update(request) {
        return Promise.resolve(this.gotUpdate(request));
    }
    /** @ignore */
    getMetadata(keys, prefixes = []) {
        return Promise.resolve(this.gotMetadata(keys, prefixes));
    }
    /** @ignore */
    patchMetadata(patches) {
        return Promise.resolve(this.patchedMetadata(patches));
    }
}
exports.MockDataSourceClient = MockDataSourceClient;
