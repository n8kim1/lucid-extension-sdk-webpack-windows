"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeActions = exports.actionsHeaderValidator = void 0;
const checks_1 = require("../../core/checks");
const validators_1 = require("../../core/validators/validators");
const dataupdatefiltertype_1 = require("../../data/dataupdatefiltertype");
const action_1 = require("./action");
const dataconnectoractionkeys_1 = require("./dataconnectoractionkeys");
exports.actionsHeaderValidator = (0, validators_1.objectValidator)({
    'x-lucid-rsa-nonce': checks_1.isString,
    'x-lucid-signature': checks_1.isString,
});
const serializedActionsBaseValidator = (0, validators_1.objectValidator)({
    action: (0, validators_1.objectValidator)({ name: checks_1.isString, data: checks_1.isUnknown }),
    packageId: checks_1.isString,
    packageVersion: (0, validators_1.nullableOption)(checks_1.isString),
    dataConnectorName: checks_1.isString,
    installationId: (0, validators_1.nullableOption)(checks_1.isString),
    userCredential: (0, validators_1.nullableOption)(checks_1.isString),
    useOutboundProxy: (0, validators_1.option)(checks_1.isBoolean),
    documentUpdateToken: (0, validators_1.nullableOption)(checks_1.isString),
    documentCollections: (0, validators_1.objectOfValidator)((0, validators_1.arrayValidator)(checks_1.isString)),
    updateFilterType: (0, validators_1.enumValidator)(dataupdatefiltertype_1.DataUpdateFilterType),
});
const serializedPatchDataValidator = (0, validators_1.objectValidator)({
    packageVersion: checks_1.isString,
    patches: (0, validators_1.arrayValidator)((0, validators_1.objectValidator)({
        patch: checks_1.isUnknown,
        id: checks_1.isString,
    })),
    userCredential: checks_1.isString,
    useOutboundProxy: (0, validators_1.option)(checks_1.isBoolean),
    documentUpdateToken: checks_1.isString,
});
const parseSerializedPatches = (patches, patchParser) => {
    return patches
        .map((patch) => {
        const p = patch['patch'];
        return patchParser(patch['id'], p);
    })
        .filter(checks_1.isDefAndNotNull);
};
const serializedManageWebhookDataValidator = (0, validators_1.objectValidator)({
    webhooks: (0, validators_1.arrayValidator)((0, validators_1.objectValidator)({
        documentCollections: (0, validators_1.objectOfValidator)((0, validators_1.arrayValidator)(checks_1.isString)),
        webhookData: (0, validators_1.option)(checks_1.isUnknown),
    })),
    webhookToken: checks_1.isString,
});
/** Function to convert the lucid action wire format into a clean list of actions */
function deserializeActions(client, actions, patchParser) {
    const parsedActions = typeof actions === 'string' ? JSON.parse(actions) : actions;
    if (!serializedActionsBaseValidator(parsedActions)) {
        return;
    }
    const name = parsedActions['action']['name'];
    const data = parsedActions['action']['data'];
    if (name === dataconnectoractionkeys_1.DataConnectorActionKeys.Patch) {
        if (!(0, validators_1.arrayValidator)(serializedPatchDataValidator)(data)) {
            console.log(`Failing validation step due to serializedPatchDataValidator`);
            return;
        }
        const parsedData = data
            .map((item) => {
            const context = new action_1.DataConnectorActionContext(parsedActions['packageId'], item['packageVersion'], item['userCredential'], item['useOutboundProxy'], // Use from action data and ignores the useOutboundProxy boolean in parsedActions
            parsedActions['dataConnectorName'], parsedActions['dataConnectorName'], parsedActions['documentCollections'], parsedActions['updateFilterType']);
            const patches = parseSerializedPatches(item['patches'], patchParser);
            if (patches.length < item['patches'].length) {
                return undefined;
            }
            return new action_1.DataConnectorPatchAction(context, patches, client.getDataSourceClient(item['documentUpdateToken']));
        })
            .filter(checks_1.isDefAndNotNull);
        if (parsedData.length < data.length) {
            console.log(`Failing validation step due to mismatched patches length.\nExpected length: ${data.length}\nActual length: ${parsedData.length}`);
            return;
        }
        return parsedData;
    }
    if (!parsedActions['packageVersion'] || !parsedActions['userCredential']) {
        return;
    }
    if (name === dataconnectoractionkeys_1.DataConnectorActionKeys.UnbatchedPatch) {
        if (!serializedPatchDataValidator(data)) {
            return;
        }
        const context = new action_1.DataConnectorActionContext(parsedActions['packageId'], parsedActions['packageVersion'], parsedActions['userCredential'], parsedActions['useOutboundProxy'], parsedActions['dataConnectorName'], parsedActions['dataConnectorName'], parsedActions['documentCollections'], parsedActions['updateFilterType']);
        const parsedPatches = parseSerializedPatches(data['patches'], patchParser);
        if (parsedPatches.length < data['patches'].length) {
            console.log(`Failing validation step due to mismatched patches length.\nExpected length: ${data['patches'].length}\nActual length: ${parsedPatches.length}`);
            return;
        }
        return [
            new action_1.DataConnectorPatchAction(context, parsedPatches, client.getDataSourceClient(data['documentUpdateToken']), dataconnectoractionkeys_1.DataConnectorActionKeys.UnbatchedPatch),
        ];
    }
    const context = new action_1.DataConnectorActionContext(parsedActions['packageId'], parsedActions['packageVersion'], parsedActions['userCredential'], parsedActions['useOutboundProxy'], parsedActions['dataConnectorName'], parsedActions['dataConnectorName'], parsedActions['documentCollections'], parsedActions['updateFilterType']);
    if (name == 'ManageWebhook') {
        if (!serializedManageWebhookDataValidator(data)) {
            return;
        }
        const webhooks = data['webhooks'].map((webhook) => new action_1.Webhook(webhook['documentCollections'], webhook['webhookData']));
        return [new action_1.DataConnectorManageWebhookAction(context, data['webhookToken'], webhooks)];
    }
    if (parsedActions['documentUpdateToken']) {
        return [
            new action_1.DataConnectorAsynchronousAction(name, context, client.getDataSourceClient(parsedActions['documentUpdateToken']), data),
        ];
    }
    return [new action_1.DataConnectorSynchronousAction(name, context, data)];
}
exports.deserializeActions = deserializeActions;
