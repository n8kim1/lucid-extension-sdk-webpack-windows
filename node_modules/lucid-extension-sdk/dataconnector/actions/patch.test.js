"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.patchesEqual = exports.orderedStringify = exports.getRandomItemPatch = exports.getRandomEmptyPatch = exports.uuid = void 0;
const checks_1 = require("../../core/checks");
const datasourceutils_1 = require("../../core/data/datasource/datasourceutils");
const spreadsheetpossibledatatypes_1 = require("../../core/data/datasource/spreadsheetpossibledatatypes");
const serializedschema_1 = require("../../core/data/serializedfield/serializedschema");
const patch_1 = require("./patch");
function arraysEqualWith(areEqual) {
    return (a, b) => {
        if (a.length !== b.length) {
            return false;
        }
        return a.every((aItem, index) => areEqual(aItem, b[index]));
    };
}
function recordsEqualWith(areEqual) {
    return (a, b) => {
        for (const key in a) {
            if (!b.hasOwnProperty(key) || !areEqual(a[key], b[key])) {
                return false;
            }
        }
        for (const key in b) {
            if (!a.hasOwnProperty(key)) {
                return false;
            }
        }
        return true;
    };
}
function arraySetsEqual(deletedA, deletedB) {
    const setA = new Set(deletedA);
    const setB = new Set(deletedB);
    if (setA.size !== setB.size) {
        return false;
    }
    setB.forEach((b) => setA.delete(b));
    return setA.size === 0;
}
function uuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => (c == 'x' ? Math.floor(Math.random() * 16) : Math.floor(Math.random() * 4) + 8).toString(16));
}
exports.uuid = uuid;
function randomWordChar() {
    const upperCaseChar = (0, datasourceutils_1.alphabetize)(Math.floor(Math.random() * 26));
    if (Math.random() > 0.5) {
        return upperCaseChar;
    }
    return upperCaseChar.toLowerCase();
}
function randomWord() {
    return Array.from({ length: 10 }, randomWordChar).join('');
}
function randomWordOrPrevious(frequency, previous) {
    const previousArray = [...previous];
    if (previousArray.length === 0) {
        return randomWord;
    }
    return () => {
        if (Math.random() < frequency) {
            return previousArray[Math.floor(Math.random() * previousArray.length)];
        }
        return randomWord();
    };
}
function getRandomEmptyPatch(optSyncSourceId, optSyncCollectionId) {
    const id = uuid();
    const syncSourceId = optSyncSourceId !== null && optSyncSourceId !== void 0 ? optSyncSourceId : uuid();
    const syncCollectionId = optSyncCollectionId !== null && optSyncCollectionId !== void 0 ? optSyncCollectionId : uuid();
    return new patch_1.ItemPatch(id, {}, {}, [], undefined, syncSourceId, syncCollectionId);
}
exports.getRandomEmptyPatch = getRandomEmptyPatch;
function randInRange(range) {
    if ((0, checks_1.isNumber)(range)) {
        return Math.floor(Math.random() * range);
    }
    return range[0] + Math.floor(Math.random() * (range[1] - range[0]));
}
function schemaFromRange(range) {
    const width = randInRange(range);
    const fields = Array.from({ length: width }, (_, index) => (0, datasourceutils_1.alphabetize)(index));
    return {
        'Fields': fields.map((field) => ({
            'Name': field,
            'Type': spreadsheetpossibledatatypes_1.SpreadSheetPossibleDataTypes,
        })),
        'PrimaryKey': [],
    };
}
function getRandomPatchSettingsInstance(settings) {
    const schema = (0, serializedschema_1.isSerializedSchema)(settings.schema) ? settings.schema : schemaFromRange(settings.schema);
    return {
        previousDependency: settings.previousDependency,
        deleteFrequency: settings.deleteFrequency,
        addedIds: randInRange(settings.addedIds),
        changedIds: randInRange(settings.changedIds),
        deletedIds: randInRange(settings.deletedIds),
        orderedAnchors: settings.orderedAnchors !== undefined ? randInRange(settings.orderedAnchors) : undefined,
        changeDensity: settings.changeDensity,
        schema,
    };
}
function getRandomPatchItemFields(schema, density) {
    const result = {};
    const primaryKeys = new Set(schema['PrimaryKey']);
    let isEmptyResult = true;
    schema['Fields'].forEach((field) => {
        if (primaryKeys.has(field['Name']) || Math.random() < density) {
            isEmptyResult = false;
            result[field['Name']] = randomWord();
        }
    });
    return isEmptyResult ? undefined : result;
}
function getRandomPatchItem(count, schema, density, wordGetter) {
    const result = {};
    for (let i = 0; i < count; i++) {
        const name = wordGetter();
        const newFields = getRandomPatchItemFields(schema, density);
        if (newFields) {
            result[name] = newFields;
        }
    }
    return result;
}
function getPreviousPatchBuckets(previousPatches) {
    const normal = new Set();
    const deleted = new Set();
    previousPatches.forEach((patch) => {
        for (const addedKey in patch.itemsAdded) {
            normal.add(addedKey);
            deleted.delete(addedKey);
        }
        for (const changedKey in patch.itemsAdded) {
            normal.add(changedKey);
            deleted.delete(changedKey);
        }
        for (const deletedKey of patch.itemsDeleted) {
            normal.delete(deletedKey);
            deleted.add(deletedKey);
        }
    });
    return { normal, deleted };
}
function getRandomItemPatch(settings, previousPatches, optSyncSourceId, optSyncCollectionId) {
    var _a;
    const id = uuid();
    const syncSourceId = optSyncSourceId !== null && optSyncSourceId !== void 0 ? optSyncSourceId : uuid();
    const syncCollectionId = optSyncCollectionId !== null && optSyncCollectionId !== void 0 ? optSyncCollectionId : uuid();
    const previousPatchBuckets = getPreviousPatchBuckets(previousPatches);
    const settingsInstance = getRandomPatchSettingsInstance(settings);
    const deletedWordGetter = randomWordOrPrevious(settings.deleteFrequency, previousPatchBuckets.deleted);
    const addedItems = getRandomPatchItem(settingsInstance.addedIds, settingsInstance.schema, 1.0, deletedWordGetter);
    const existingWordGetter = randomWordOrPrevious(settings.previousDependency, previousPatchBuckets.normal);
    const changedItems = getRandomPatchItem(settingsInstance.changedIds, settingsInstance.schema, settings.changeDensity, existingWordGetter);
    const deletedItems = [...new Set(Array.from({ length: settingsInstance.deletedIds }, existingWordGetter))];
    deletedItems.forEach((deletedKey) => delete changedItems[deletedKey]);
    const itemOrderChains = new Map();
    const orderedAnchorsSet = (settingsInstance.orderedAnchors &&
        new Set(Array.from({ length: settingsInstance.orderedAnchors }, existingWordGetter))) ||
        undefined;
    const orderedAnchors = orderedAnchorsSet && [...orderedAnchorsSet];
    if (orderedAnchors && orderedAnchors.length > 0) {
        for (const key in addedItems) {
            const anchorIndex = Math.floor(Math.random() * orderedAnchors.length);
            const anchor = orderedAnchors[anchorIndex];
            if (!itemOrderChains.has(anchor)) {
                itemOrderChains.set(anchor, new Set());
            }
            (_a = itemOrderChains.get(anchor)) === null || _a === void 0 ? void 0 : _a.add(key);
        }
    }
    const itemOrderChanged = [];
    itemOrderChains.forEach((chain, anchor) => {
        let lastNext = anchor;
        chain.forEach((chainEntry) => {
            itemOrderChanged.push([chainEntry, lastNext]);
            lastNext = chainEntry;
        });
    });
    return new patch_1.ItemPatch(id, addedItems, changedItems, deletedItems, itemOrderChanged, syncSourceId, syncCollectionId);
}
exports.getRandomItemPatch = getRandomItemPatch;
/**
 * When we use raw JSON.stringify on objects, it can depend in subtle ways how the object was created. This
 * function is intended to make the resulting string depend only on the logical contents so as to minimize unneeded
 * refreshes.
 *
 * @param data The Sheet-type to stringify
 * @returns A custom stringified object
 */
function orderedStringify(data) {
    if ((0, checks_1.isArray)(data)) {
        return `[${data.map((arrayItem) => (arrayItem == null ? 'null' : orderedStringify(arrayItem))).join(',')}]`;
    }
    if ((0, checks_1.isObject)(data)) {
        const entries = Object.entries(data).filter(([_key, value]) => value !== undefined);
        entries.sort(([keyA], [keyB]) => (keyA > keyB ? 1 : keyA === keyB ? 0 : -1));
        return `{${entries.map(([key, value]) => `${JSON.stringify(key)}:${orderedStringify(value)}`).join(',')}}`;
    }
    return JSON.stringify(data);
}
exports.orderedStringify = orderedStringify;
function patchesEqual(patchA, patchB) {
    if (patchA instanceof patch_1.ItemPatch && patchB instanceof patch_1.ItemPatch) {
        if (patchA.id !== patchB.id ||
            patchA.syncSourceId !== patchB.syncSourceId ||
            patchA.syncCollectionId !== patchB.syncCollectionId ||
            orderedStringify(patchA.itemsAdded) !== orderedStringify(patchB.itemsAdded) ||
            orderedStringify(patchA.itemsChanged) !== orderedStringify(patchB.itemsChanged) ||
            !arraySetsEqual(patchA.itemsDeleted, patchB.itemsDeleted)) {
            return false;
        }
        const orderMapA = new Map(patchA.itemOrderChanged);
        const orderMapB = new Map(patchB.itemOrderChanged);
        if (orderMapA.size !== orderMapB.size) {
            return false;
        }
        return [...orderMapA].every(([from, to]) => orderMapB.get(from) === to);
    }
    if (patchA instanceof patch_1.SchemaPatch && patchB instanceof patch_1.SchemaPatch) {
        if (patchA.id !== patchB.id ||
            patchA.syncSourceId !== patchB.syncSourceId ||
            patchA.syncCollectionId !== patchB.syncCollectionId ||
            !arraysEqualWith(patch_1.areThirdPartyColumnsEqual)(patchA.columnsAdded, patchB.columnsAdded) ||
            !recordsEqualWith(patch_1.areThirdPartyColumnPatchesEqual)(patchA.columnsChanged, patchB.columnsChanged) ||
            !arraySetsEqual(patchA.columnsDeleted, patchB.columnsDeleted)) {
            return false;
        }
        const orderMapA = new Map(patchA.columnOrdering);
        const orderMapB = new Map(patchB.columnOrdering);
        if (orderMapA.size !== orderMapB.size) {
            return false;
        }
        return [...orderMapA].every(([from, to]) => orderMapB.get(from) === to);
    }
    return false;
}
exports.patchesEqual = patchesEqual;
