"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializePatchChanges = exports.serializePatchResponse = exports.PatchErrorTooltipField = exports.PatchChange = void 0;
const object_1 = require("../../core/object");
const datasourceupdatetypes_1 = require("../datasourceupdatetypes");
/**
 * Reports a completed change back to Lucid
 */
class PatchChange {
    constructor(patchId, syncId, collections, creationPermission) {
        this.patchId = patchId;
        this.syncId = syncId;
        this.collections = collections;
        this.creationPermission = creationPermission;
        this.errors = {};
    }
    setError(primaryKey, fieldName, error) {
        if (!(primaryKey in this.errors)) {
            this.errors[primaryKey] = {};
        }
        this.errors[primaryKey][fieldName] = error;
    }
    setTooltipError(primaryKey, error) {
        this.setError(primaryKey, exports.PatchErrorTooltipField, error);
    }
    getErrors() {
        return this.errors;
    }
}
exports.PatchChange = PatchChange;
/** Placeholder field name for tool tip errors */
exports.PatchErrorTooltipField = '__canvasTooltipDataSyncError__';
/** Convert a Patch change to our wire format */
function serializePatchResponse(patchChange) {
    return {
        'syncId': patchChange.syncId,
        'collections': patchChange.collections.map((c) => {
            return Object.assign({ 'collectionId': c.collectionId, 'itemsPatch': (0, datasourceupdatetypes_1.serializeItemsPatch)(c.itemsPatch) }, (c.schema != null ? { 'schema': (0, datasourceupdatetypes_1.serializeSchemaForApi)(c.schema) } : undefined));
        }),
        'creationPermission': patchChange.creationPermission,
    };
}
exports.serializePatchResponse = serializePatchResponse;
function serializePatchChanges(changes) {
    const joinedErrors = {};
    for (const changeGroup of changes) {
        for (const change of changeGroup) {
            for (const [primaryKey, fieldNames] of Object.entries(change.getErrors())) {
                for (const [fieldName, error] of Object.entries(fieldNames)) {
                    if (!(change.patchId in joinedErrors)) {
                        joinedErrors[change.patchId] = {};
                    }
                    const patchErrors = joinedErrors[change.patchId];
                    if (!(primaryKey in patchErrors)) {
                        patchErrors[primaryKey] = {};
                    }
                    const primaryKeyErrors = patchErrors[primaryKey];
                    primaryKeyErrors[fieldName] = error;
                }
            }
        }
    }
    return {
        'changes': (0, object_1.flatten)(changes.map((changeList) => changeList.map((change) => serializePatchResponse(change)))),
        'errors': joinedErrors,
    };
}
exports.serializePatchChanges = serializePatchChanges;
