"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ItemRekeyerAndRelabeler = exports.RekeyingRelabelingMap = void 0;
const fieldspecification_1 = require("../core/data/fieldspecification");
const object_1 = require("../core/object");
const patch_1 = require("./actions/patch");
const datasourceupdatetypes_1 = require("./datasourceupdatetypes");
function calculateRekeyingMap(itemsPatch, primaryKey) {
    var _a, _b;
    if (itemsPatch instanceof datasourceupdatetypes_1.ItemsPatchExhaustive) {
        return itemsPatch.rekeyingMap;
    }
    else {
        if (!primaryKey) {
            return undefined;
        }
        const constPrimaryKey = primaryKey;
        function primaryKeyIfChanged(oldPrimaryKey, item) {
            const changedParts = constPrimaryKey.elements.map((field) => item[field]);
            if (changedParts.find((x) => x !== undefined) === undefined) {
                // this patch didn't touch the primary key
                return undefined;
            }
            // we might need parts of the old primary key if only some of the primary key fields changed.
            // As an optimization we could only compute this if at least one of the changedParts is
            // undefined.
            const oldParts = JSON.parse(`[${oldPrimaryKey}]`);
            const newParts = changedParts.map((part, index) => (part !== undefined ? part : oldParts[index]));
            const newPrimaryKey = fieldspecification_1.FormattedPrimaryKey.serializeList(newParts);
            if (newPrimaryKey !== oldPrimaryKey) {
                return newPrimaryKey;
            }
            else {
                return undefined;
            }
        }
        const itemsMap = [...itemsPatch.items.entries()]
            .map(([key, value]) => [key, primaryKeyIfChanged(key, value)])
            .filter((x) => x[1] !== undefined);
        const deletedMap = (_b = (_a = itemsPatch.itemsDeleted) === null || _a === void 0 ? void 0 : _a.map((key) => [key, null])) !== null && _b !== void 0 ? _b : [];
        const theMap = new Map([...itemsMap, ...deletedMap]);
        return theMap.size > 0 ? theMap : undefined;
    }
}
function calculateRelabelingMap(itemsPatch) {
    if (itemsPatch instanceof datasourceupdatetypes_1.ItemsPatchExhaustive) {
        return itemsPatch.fieldNamesChanged;
    }
    else {
        return undefined;
    }
}
class RekeyingRelabelingMap {
    constructor(keyMap, labelMap) {
        this.keyMap = keyMap;
        this.labelMap = labelMap;
    }
    getNewKey(key) {
        var _a;
        return (_a = this.keyMap.get(key)) !== null && _a !== void 0 ? _a : key;
    }
    getNewLabel(label) {
        var _a;
        return (_a = this.labelMap.get(label)) !== null && _a !== void 0 ? _a : label;
    }
    getRelabeledItem(item) {
        const newItem = {};
        for (const key in item) {
            newItem[this.getNewLabel(key)] = item[key];
        }
        return newItem;
    }
    getRecordWithNewKeysAndLabels(items) {
        return (0, object_1.fromEntries)(Object.entries(items).map(([key, value]) => [this.getNewKey(key), this.getRelabeledItem(value)]));
    }
    getRelabeledThirdPartyColumn(thirdPartyColumn) {
        return new patch_1.ThirdPartyColumn(this.getNewLabel(thirdPartyColumn.name), thirdPartyColumn.fieldType);
    }
    getRelabeledThirdPartyColumnPatches(thirdPartyColumnPatch) {
        const newRecord = {};
        for (const label in thirdPartyColumnPatch) {
            newRecord[this.getNewLabel(label)] = thirdPartyColumnPatch[label];
        }
        return newRecord;
    }
    getRekeyedRelabeledPatch(patch) {
        var _a, _b;
        if (patch instanceof patch_1.ItemPatch) {
            return new patch_1.ItemPatch(patch.id, this.getRecordWithNewKeysAndLabels(patch.itemsAdded), this.getRecordWithNewKeysAndLabels(patch.itemsChanged), patch.itemsDeleted.map((key) => this.getNewKey(key)), (_a = patch.itemOrderChanged) === null || _a === void 0 ? void 0 : _a.map(([a, b]) => [this.getNewKey(a), b && this.getNewKey(b)]), patch.syncSourceId, patch.syncCollectionId);
        }
        if (patch instanceof patch_1.SchemaPatch) {
            return new patch_1.SchemaPatch(patch.id, patch.columnsAdded.map((column) => this.getRelabeledThirdPartyColumn(column)), this.getRelabeledThirdPartyColumnPatches(patch.columnsChanged), patch.columnsDeleted.map((columnName) => this.getNewLabel(columnName)), (_b = patch.columnOrdering) === null || _b === void 0 ? void 0 : _b.map(([movedColumn, anchorColumn]) => [
                this.getNewLabel(movedColumn),
                anchorColumn != null ? this.getNewLabel(anchorColumn) : anchorColumn,
            ]), patch.syncSourceId, patch.syncCollectionId);
        }
        return patch.clone();
    }
}
exports.RekeyingRelabelingMap = RekeyingRelabelingMap;
class ItemRekeyerAndRelabeler {
    constructor() {
        this.rekeyingRelabelingMaps = new Map();
    }
    addRekeyingsRelabelingsFor(collectionId, itemsPatch, primaryKey) {
        var _a, _b, _c, _d;
        const rekeyingMap = calculateRekeyingMap(itemsPatch, primaryKey);
        const relabelingMap = calculateRelabelingMap(itemsPatch);
        const existingKeyAndLabelMap = this.rekeyingRelabelingMaps.get(collectionId);
        const rekeyedExisting = rekeyingMap &&
            [...((_a = existingKeyAndLabelMap === null || existingKeyAndLabelMap === void 0 ? void 0 : existingKeyAndLabelMap.keyMap.entries()) !== null && _a !== void 0 ? _a : [])].map(([key, value]) => {
                var _a;
                return [
                    key,
                    value && ((_a = rekeyingMap.get(value)) !== null && _a !== void 0 ? _a : value),
                ];
            });
        const relabeledExisting = relabelingMap &&
            [...((_b = existingKeyAndLabelMap === null || existingKeyAndLabelMap === void 0 ? void 0 : existingKeyAndLabelMap.labelMap.entries()) !== null && _b !== void 0 ? _b : [])].map(([key, value]) => {
                var _a;
                return [
                    key,
                    value && ((_a = relabelingMap.get(value)) !== null && _a !== void 0 ? _a : value),
                ];
            });
        this.rekeyingRelabelingMaps.set(collectionId, new RekeyingRelabelingMap(new Map([...((_c = rekeyingMap === null || rekeyingMap === void 0 ? void 0 : rekeyingMap.entries()) !== null && _c !== void 0 ? _c : []), ...(rekeyedExisting !== null && rekeyedExisting !== void 0 ? rekeyedExisting : [])]), new Map([...((_d = relabelingMap === null || relabelingMap === void 0 ? void 0 : relabelingMap.entries()) !== null && _d !== void 0 ? _d : []), ...(relabeledExisting !== null && relabeledExisting !== void 0 ? relabeledExisting : [])])));
    }
    getRekeyingRelabelingMap(patch) {
        return this.rekeyingRelabelingMaps.get(patch.syncCollectionId);
    }
}
exports.ItemRekeyerAndRelabeler = ItemRekeyerAndRelabeler;
