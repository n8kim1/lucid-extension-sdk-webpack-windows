import { MetadataPatch, MetadataPatchResponse, MetadataRecord } from './datasourcemetadatatypes';
import { DataSourceRequest } from './datasourceupdatetypes';
/**
 * Authenticated client for DataSource related requests to Lucid.
 */
export declare class DataSourceClient {
    private urls;
    private updateToken;
    private fetchMethod;
    private readonly metadataUrl;
    constructor(urls: {
        main: string;
        api: string;
    }, updateToken: string, fetchMethod?: import("./defaultfetchfunction").GlobalFetchType);
    private formatBody;
    /** Create or update a datasource. If you create a new collection it must be fully specified in terms of schema and
     * and items. If it's just an update then the schema can be omitted (if unchanged) and items that already exist can
     * be partial.*/
    update(request: DataSourceRequest): Promise<void>;
    /**
     * When dealing with data, we can often have a very large number of collections in a single data source, and in
     * turn, we may well end up get the values for a very large number of metadata values per collection.
     * Because the endpoints for metadata use query params to encode the metadata names, and because metadata value
     * reads can be easily parallelized, and because URLs have length limits, this function constructs an array of
     * query params that are certain to be short enough that each individual query will be a safe length, while still
     * getting *all* of the requested data.
     * @param keys The metadata keys we are requesting from the data sync service for the corresponding data source.
     * @param prefixes The metadata prefixes we are requesting from the data sync service for the corresponding data source.
     * @returns An array of query params such that each query param is short enough to be safe, but all params combined
     *             cover all requested metadata.
     */
    private getLengthLimitedQueryParams;
    private getResponseOrError;
    /** @ignore until metadata endpoints are made part of the public API */
    getMetadata(keys: string[], prefixes?: string[]): Promise<MetadataRecord[]>;
    /** @ignore until metadata endpoints are made part of the public API */
    patchMetadata(patches: MetadataPatch[]): Promise<MetadataPatchResponse>;
}
/**
 * A version of the DataSourceClient that you can use for any automated tests of your data connector.
 * Modify the `gotUpdate` field to change the behaviour of the update method.
 **/
export declare class MockDataSourceClient extends DataSourceClient {
    /** Assign this to your mocked update function */
    gotUpdate: (request: DataSourceRequest) => void;
    /** Assign this to your mocked update function */
    gotMetadata: (keys: string[], prefixes: string[]) => MetadataRecord[];
    /** Assign this to your mocked update function */
    patchedMetadata: (patches: MetadataPatch[]) => MetadataPatchResponse;
    constructor();
    /** @ignore */
    update(request: DataSourceRequest): Promise<void>;
    /** @ignore */
    getMetadata(keys: string[], prefixes?: string[]): Promise<MetadataRecord[]>;
    /** @ignore */
    patchMetadata(patches: MetadataPatch[]): Promise<MetadataPatchResponse>;
}
