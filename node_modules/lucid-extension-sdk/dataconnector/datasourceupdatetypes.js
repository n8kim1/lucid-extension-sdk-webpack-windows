"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schemaOKStatus = exports.schemaOutOfSyncStatus = exports.serializeCollectionPatch = exports.serializeSchemaForApi = exports.serializeFieldDefinitionForApi = exports.serializeItemsPatch = exports.ItemsPatchExhaustive = exports.ItemsPatchInexhaustive = void 0;
const checks_1 = require("../core/checks");
const fieldtypedefinition_1 = require("../core/data/fieldtypedefinition/fieldtypedefinition");
const object_1 = require("../core/object");
const collectionerrortypes_1 = require("../data/collectionerrortypes");
class ItemsPatchInexhaustive {
    constructor(
    /**
     * Items to be added or changed in the collection. Mapping from item serialized primary key to
     * the sparse patch of the item. See FormattedPrimaryKey.forItem.
     **/
    items, 
    /** Items to remove from the collection, based on the same primary key algorithm. */
    itemsDeleted, errors) {
        this.items = items;
        this.itemsDeleted = itemsDeleted;
        this.errors = errors;
        this._brand = ItemsPatchInexhaustive;
    }
}
exports.ItemsPatchInexhaustive = ItemsPatchInexhaustive;
class ItemsPatchExhaustive {
    constructor(items, rekeyingMap, fieldNamesChanged, errors) {
        this.items = items;
        this.rekeyingMap = rekeyingMap;
        this.fieldNamesChanged = fieldNamesChanged;
        this.errors = errors;
        this._brand = ItemsPatchExhaustive;
    }
}
exports.ItemsPatchExhaustive = ItemsPatchExhaustive;
function serializeErrors(errors) {
    return errors && { 'errors': (0, object_1.fromEntries)(errors) };
}
function serializeRekeyingMap(rekeyingMap) {
    return rekeyingMap && { 'rekeyingMap': (0, object_1.fromEntries)(rekeyingMap) };
}
function serializeFieldNamesChanged(fieldNamesChanged) {
    return fieldNamesChanged && { 'fieldNamesChanged': (0, object_1.fromEntries)(fieldNamesChanged) };
}
function serializeItemsPatch(patch) {
    var _a;
    if (patch instanceof ItemsPatchExhaustive) {
        return Object.assign(Object.assign(Object.assign({ 'exhaustiveItems': (0, object_1.fromEntries)(patch.items.entries()) }, serializeRekeyingMap(patch.rekeyingMap)), serializeFieldNamesChanged(patch.fieldNamesChanged)), serializeErrors(patch.errors));
    }
    else {
        return Object.assign({ 'items': (0, object_1.fromEntries)(patch.items.entries()), 'itemsDeleted': (_a = patch.itemsDeleted) !== null && _a !== void 0 ? _a : [] }, serializeErrors(patch.errors));
    }
}
exports.serializeItemsPatch = serializeItemsPatch;
function serializeFieldConstraintForApi(constraint) {
    return {
        'type': constraint.type,
        'details': constraint.value,
    };
}
/** @ignore */
function serializeFieldDefinitionForApi(field) {
    var _a;
    return {
        'name': field.name,
        'type': (0, fieldtypedefinition_1.serializeFieldTypeDefinition)(field.type),
        'constraints': ((_a = field.constraints) !== null && _a !== void 0 ? _a : []).map((x) => serializeFieldConstraintForApi(x)),
        'mapping': field.mapping,
    };
}
exports.serializeFieldDefinitionForApi = serializeFieldDefinitionForApi;
function serializeSchemaForApi(schema) {
    return {
        'fields': schema.fields.map((x) => serializeFieldDefinitionForApi(x)),
        'primaryKey': schema.primaryKey,
        'fieldLabelOverrides': schema.fieldLabels,
    };
}
exports.serializeSchemaForApi = serializeSchemaForApi;
function serializeRepresentsAsPropertyForApi(represents) {
    return {
        'Represents': represents, // key needs to match 'Represents' key in cake/app/webroot/ts/property/collection/collectionproperties.ts
    };
}
function serializeNameAsPropertyForApi(name) {
    return {
        'Name': name, // key needs to match 'Name' key in cake/app/webroot/ts/property/collection/collectionproperties.ts
    };
}
function serializeHiddenFromDataPanelForApi(hiddenFromDataPanel) {
    return {
        'IsHiddenFromDataPanel': hiddenFromDataPanel, // key needs to match 'IsHiddenFromDataPanel' key in cake/app/webroot/ts/property/collection/collectionproperties.ts
    };
}
function serializeCollectionPatch(patch) {
    const representsProperty = patch.represents && serializeRepresentsAsPropertyForApi(patch.represents);
    const nameProperty = (0, checks_1.isString)(patch.name) ? serializeNameAsPropertyForApi(patch.name) : undefined;
    const isHiddenFromDataPanelProperty = (0, checks_1.isDef)(patch.hideFromDataPanel)
        ? serializeHiddenFromDataPanelForApi(patch.hideFromDataPanel)
        : undefined;
    const properties = (representsProperty || nameProperty || isHiddenFromDataPanelProperty) && Object.assign(Object.assign(Object.assign({}, representsProperty), nameProperty), isHiddenFromDataPanelProperty);
    return {
        'schema': patch.schema && serializeSchemaForApi(patch.schema),
        'itemsPatch': serializeItemsPatch(patch.patch),
        'properties': properties,
    };
}
exports.serializeCollectionPatch = serializeCollectionPatch;
/**
 * For the moment, when the upstream Google Sheet is changed in such a way that the schema has changed, we simply
 * stop updates from happening. We do need to alert the user that this has happened, though. This is a utility function
 * for creating the appropriate entry in the errors map so that the user can be alerted that updates have stopped
 * and what they need to do to fix it.
 *
 * The eventual, proposed fix is to allow schemas to have version numbers so that changes to the schema from Google
 * can simply be folded in to the on-document copies of the data and all following edits.
 *
 * @param oldPrimaryKey The primary key stored in the data sync service and which currently is used to interpret
 * patches.
 * @param newPrimaryKey The primary key as it has been changed in the real Google Sheets.
 * @returns The error map entry which alerts the document that this problem has happened.
 */
function schemaOutOfSyncStatus(oldPrimaryKey, newPrimaryKey) {
    return [
        collectionerrortypes_1.CollectionUpstreamSchemaStatus,
        {
            'dict': {
                'status': 'broken',
                'onDocumentKey': JSON.stringify(oldPrimaryKey),
                'upstreamKey': JSON.stringify(newPrimaryKey),
            },
        },
    ];
}
exports.schemaOutOfSyncStatus = schemaOutOfSyncStatus;
/**
 * For the moment, when the upstream Google Sheet is changed in such a way that the schema has changed, we simply
 * stop updates from happening. We do need to alert the user that this has happened, though. We also need to know when
 * the updates are happening properly so we can clear the error once the user has resolved the problem. Since the
 * only way to delete errors is to overwrite them, we simply overwrite the error to be OK on every successful
 * import.
 * @returns The error map entry which alerts the document that this problem has been resolved.
 */
function schemaOKStatus() {
    return [
        collectionerrortypes_1.CollectionUpstreamSchemaStatus,
        {
            'dict': {
                'status': 'ok',
                'onDocumentKey': null,
                'upstreamKey': null,
            },
        },
    ];
}
exports.schemaOKStatus = schemaOKStatus;
const assertIsJustRenamed = () => undefined;
assertIsJustRenamed();
assertIsJustRenamed();
assertIsJustRenamed();
