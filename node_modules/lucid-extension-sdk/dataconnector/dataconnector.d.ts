import { DataConnectorAction, DataConnectorAsynchronousAction, DataConnectorManageWebhookAction, DataConnectorPatchAction, Webhook } from './actions/action';
import { DataConnectorActionKeys } from './actions/dataconnectoractionkeys';
import { ItemPatch, Patch, PatchParser } from './actions/patch';
import { PatchChange } from './actions/patchresponsebody';
import { DataConnectorClient } from './dataconnectorclient';
import { ExpressAppLike, RunDebugServerOptions } from './debugserver';
import { ItemRekeyerAndRelabeler } from './itemrekeyerandrelabeler';
/** Type to define an action request handler. That is a function that can fulfil an incoming action */
type ActionRequest<ArgType, BodyType = unknown> = (args: ArgType, dataConnectorRequestState: DataConnectorRequestState) => Promise<BodyType>;
/** Type to define an arbitrary non-action request to this server. Useful for handling webhook responses in the same
 * lambda that handles data actions */
export type DataConnectorRoute = (args: {
    body: string;
    query: Record<string, undefined | string>;
    headers: Record<string, string[] | string | undefined>;
}) => Promise<{
    status: number;
    body?: string;
    headers?: Record<string, string | undefined>;
}>;
/** Throw this from an action request handler to produce a non-200 response code and not have to return the expected
 * result type */
export declare class DataConnectorRunError extends Error {
    status: number;
    body: unknown;
    constructor(status: number, body: unknown, message?: string);
    static withMessage(status: number, message: string): DataConnectorRunError;
}
/** Thrown by any failable http APIs */
export declare class DataConnectorRequestError extends Error {
    status: number;
    response: string;
    statusText?: string | undefined;
    constructor(status: number, message: string, response: string, statusText?: string | undefined);
    toString(): string;
}
export declare class DataConnectorRequestState {
    itemRekeyer: ItemRekeyerAndRelabeler;
    constructor(itemRekeyer: ItemRekeyerAndRelabeler);
}
/** Thrown by any APIs the client didn't recognize when parsing */
export declare class DataConnectorResponseError extends Error {
    response: string;
    constructor(message: string, response: string);
}
type ActionTypeForName<P extends Patch, Name extends string, Asynchronous = boolean> = Name extends `${DataConnectorActionKeys.Patch}` ? ActionRequest<DataConnectorPatchAction<P>, PatchChange[]> : Name extends `${DataConnectorActionKeys.UnbatchedPatch}` ? ActionRequest<DataConnectorPatchAction<P>, PatchChange[]> : Name extends `${DataConnectorActionKeys.ManageWebhook}` ? ActionRequest<DataConnectorManageWebhookAction, Webhook> : ActionRequest<Asynchronous extends true ? DataConnectorAsynchronousAction : DataConnectorAction>;
/** Factory class to define a bunch of action handlers. */
export declare class DataConnector<P extends Patch = ItemPatch> {
    private client;
    private patchParser;
    constructor(client: DataConnectorClient);
    constructor(client: DataConnectorClient, optPatchParser: P extends ItemPatch ? never : PatchParser<P>);
    actions: Record<string, {
        actionResponder: ActionRequest<DataConnectorAsynchronousAction>;
        asynchronous: true;
    } | {
        actionResponder: ActionRequest<DataConnectorAction>;
        asynchronous: false;
    }>;
    routes: Record<string, DataConnectorRoute>;
    /** Factory to define an action request handler */
    defineAction<T extends string>(name: T, request: ActionTypeForName<P, T>, asynchronous?: boolean): DataConnector<P>;
    /** Factory to define an asynchronous action request handler */
    defineAsynchronousAction<T extends string>(name: T, request: ActionTypeForName<P, T, true>): DataConnector<P>;
    /** Factory to define a route handler */
    defineRoute(name: string, request: DataConnectorRoute): DataConnector<P>;
    /** Call a defined action handler and gather its serialized response */
    runAction(url: string, headers: Record<string, string[] | string | undefined>, body: unknown): Promise<{
        status: number;
        body: unknown;
    }>;
    /** Add a route to the given express app (or generate a new app) to serve this data connector */
    routeDebugServer(options: RunDebugServerOptions): ExpressAppLike;
    /**
     * Serve this data connector as a simple express app for debugging purposes
     */
    runDebugServer(options: RunDebugServerOptions): void;
}
export {};
