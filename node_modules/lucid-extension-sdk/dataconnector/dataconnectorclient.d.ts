import { JsonObject } from '../core/jsonserializable';
import { DataConnectorAction } from './actions/action';
import { Patch, PatchParser } from './actions/patch';
import { CryptoDependencies } from './cryptodependencies';
import { DataSourceClient, MockDataSourceClient } from './datasourceclient';
import { SignatureValidator } from './signaturevalidator';
/** @ignore */
export type WebhookValidationSecret = {
    'oauth2': {
        'clientId': string;
        'clientSecret': string;
    };
};
/**
 * Client for requests to and from Lucid
 */
export declare class DataConnectorClient {
    private readonly cryptoDependencies;
    urls: {
        main: string;
        api: string;
    };
    private fetchMethod;
    private cachedPublicKey;
    constructor(cryptoDependencies: CryptoDependencies, urls?: {
        main: string;
        api: string;
    }, fetchMethod?: import("./defaultfetchfunction").GlobalFetchType);
    /** Get a client for DataSource related requests to Lucid */
    getDataSourceClient(updateToken: string): DataSourceClient;
    /** Get a validator to prove a given request came from Lucid */
    getSignatureValidator(): Promise<SignatureValidator>;
    /** Get Lucid's public key to verify requests came from Lucid if you don't want to use the SignatureValidator. Maybe
     * you're not running in a NodeJS environment */
    getPublicKey(): Promise<string>;
    /** Validate and parse an action request from Lucid */
    parseActions<P extends Patch>(url: string, headers: Record<string, string | string[] | unknown>, actions: unknown, patchParser: PatchParser<P>): Promise<DataConnectorAction[] | undefined>;
    /** @ignore */
    getSecretFromWebhook(webhookUpdateToken: string, WebhookValidationSecret: WebhookValidationSecret): Promise<string | undefined>;
    /** @ignore */
    getCustomWebhookData(webhookUpdateToken: string): Promise<JsonObject>;
    /** @ignore */
    patchCustomWebhookData(webhookUpdateToken: string, patch: JsonObject): Promise<JsonObject>;
}
/** Use this for writing automated tests for your data connector */
export declare class MockDataConnectorClient extends DataConnectorClient {
    /** set properties on this to modify how data source updates are mocked */
    readonly dataSourceClient: MockDataSourceClient;
    constructor();
    /** @ignore */
    getDataSourceClient(updateToken: string): DataSourceClient;
    /** Mocked version just always returns successful */
    getSignatureValidator(): Promise<SignatureValidator>;
    /** Mocked version returns an empty string */
    getPublicKey(): Promise<string>;
}
