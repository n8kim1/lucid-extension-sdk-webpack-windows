/**
 * Returns true if the specified value is not undefined.
 *
 * @param val Variable to test.
 * @return Whether variable is defined.
 */
export declare function isDef<F>(val: F | undefined): val is F;
/**
 * Returns true if the specified value is null.
 * @param val Variable to test.
 * @return Whether variable is null.
 */
export declare function isNull(val: unknown): val is null;
/**
 * Returns true if the specified value is undefined.
 * @param val Variable to test.
 * @return Whether variable is undefined.
 */
export declare function isUndefined(val: unknown): val is undefined;
/**
 * Returns true if the specified value is undefined.
 * @param val Variable to test.
 * @return Whether variable is undefined.
 */
export declare function isVoid(x: unknown): x is void;
/**
 * Returns true if the specified value is defined and not null.
 * @param val Variable to test.
 * @return Whether variable is defined and not null.
 */
export declare function isDefAndNotNull<F>(val: F | null | undefined): val is F;
/**
 * Returns true if the specified value is null or undefined.
 * @param val Variable to test
 * @return Whether the variable is null or undefined.
 */
export declare function isNullish(val: unknown): val is null | undefined;
/**
 * Returns true if the specified value is a string.
 * @param val Variable to test.
 * @return Whether variable is a string.
 */
export declare function isString(val: unknown): val is string;
/**
 * Returns true if the specified value is a boolean.
 * @param val Variable to test.
 * @return Whether variable is boolean.
 */
export declare function isBoolean(val: unknown): val is boolean;
/**
 * Returns true if the specified value is a number.
 * @param val Variable to test.
 * @return Whether variable is a number.
 */
export declare function isNumber(val: unknown): val is number;
/**
 * Returns true if the specified value is an integer.
 * @param val Variable to test.
 * @return Whether variable is an integer.
 */
export declare function isInt(val: unknown): val is number;
/**
 * Returns true if the specified value is either positive or negative infinity.
 * @param val Variable to test.
 * @returns Whether variable is positive or negative infinity.
 */
export declare function isInfinite(val: unknown): val is number;
export declare function isFunction(val: unknown): val is (...unknownArgs: any[]) => unknown;
/**
 * Returns true if the specified value is an object (including arrays and functions) (i.e. it's safe to do property accesses on it).
 *
 * @param val Variable to test.
 * @return Whether variable is an object.
 */
export declare function isObject(val: unknown): val is object;
/**
 * Returns true for objects, includings arrays and functions.
 * Matches the behavior of goog.isObject, with a more permissive type.
 *
 * @param val Variable to test.
 * @return Whether variable is an object.
 */
export declare function isObjectUnsafe(val: any): val is {
    [key: string]: unknown;
};
/**
 * Returns true for objects, includings arrays and functions.
 * Matches the behavior of goog.isObject, with an extremely permissive type.
 *
 * @param val Variable to test.
 * @return Whether variable is an object.
 */
export declare function isObjectUnsafer(val: any): val is {
    [key: string]: any;
};
/**
 * Returns true if the specified value is an object (i.e. it's safe to do property accesses on it),
 * and every value matches the record type.
 *
 * @param val Variable to test.
 * @return Whether variable is an object.
 */
export declare function isRecord<T>(typeGuard: (a: unknown) => a is T): (val: unknown) => val is Record<string, T>;
/**
 * Returns true if the specified value is an array.
 *
 * This is safer than using Array.isArray directly because it doesn't introduce an `any` type.
 * @param val Variable to test.
 * @return Whether variable is an array.
 */
export declare function isArray(val: unknown): val is unknown[];
/**
 * Returns true if the specified value is an array and every element passes the type guard function.
 *
 * @param val Variable to test.
 * @param typeGuard the type guard function to test every element in the array.
 * @return Whether variable is an array of the given type.
 */
export declare function isTypedArray<T>(typeGuard: (a: unknown) => a is T): (val: unknown) => val is T[];
/**
 * Returns true if the specified value is an array and every element is defined and not null.
 *
 * @param val Variable to test.
 * @returns Whether variable is an array of defined and not null elements.
 */
export declare function isDefinedArray<T>(val: (T | undefined | null)[]): val is T[];
/**
 * Returns true if the specified value is a map.
 *
 * @param val Variable to test.
 * @return Whether variable is a map.
 */
export declare function isMap(val: unknown): val is Map<unknown, unknown>;
export type Tuple<T, N extends number> = N extends N ? (number extends N ? T[] : TupleOfHelper<T, N, []>) : never;
type TupleOfHelper<T, N extends number, R extends unknown[]> = R['length'] extends N ? R : TupleOfHelper<T, N, [T, ...R]>;
export declare function isExactLength<T, N extends number>(arr: readonly T[], exactLength: N): arr is Tuple<T, N>;
export declare function isAtLeastLength<T, N extends number>(arr: readonly T[], minimumLength: N): arr is [...Tuple<T, N>, ...T[]];
/**
 * Returns true if the specified value is a tuple where the first element, T, passes the tGuard function
 * and the second element, U, passes the uGuard function
 * @param tGuard the type guard function to test the first element in the tuple, T
 * @param uGuard the type guard function to test the second element in the tuple, U
 * @returns whether the value is a tuple of the form [T, U]
 */
export declare function isPair<T, U>(tGuard: (x: unknown) => x is T, uGuard: (x: unknown) => x is U): (x: unknown) => x is [T, U];
/**
 * Returns true if the specified object is either empty or all existing keys map to a nullish value
 *
 * @param val Variable to test
 * @return Whether variable is empty or maps exclusively to nullish values
 */
export declare function isEmptyOrNullishObject(val: unknown): val is {};
/**
 * @deprecated Prefer isUnknown
 */
export declare function isAny(val: unknown): val is any;
export declare function isUnknown(val: unknown): val is unknown;
export declare function isPromise(val: unknown): val is Promise<unknown>;
export declare function isLiteral<T extends string | number | symbol | boolean>(t: T): (x: unknown) => x is T;
type AbstractConstructor<T> = Function & {
    prototype: T;
};
/**
 * Since `instanceof` should generally be avoided, this function should generally be avoided as well.
 *
 * A valid use case is for native types, like Uint8Array.
 */
export declare function isInstanceOf<T>(klass: AbstractConstructor<T>): (x: unknown) => x is T;
export {};
