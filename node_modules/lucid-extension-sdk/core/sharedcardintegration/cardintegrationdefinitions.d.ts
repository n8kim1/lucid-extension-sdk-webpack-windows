import { CollectionDefinition } from '../../data/collectiondefinition';
import { CollectionProxy } from '../../data/collectionproxy';
import { DataItemProxy } from '../../data/dataitemproxy';
import { FieldDefinition } from '../../data/schemadefinition';
import { isString } from '../checks';
import { isSerializedFieldTypeDefinition } from '../data/fieldtypedefinition/fieldtypedefinition';
import { SerializedFieldDefinition } from '../data/serializedfield/serializedfielddefinition';
import { SerializedFieldType, isSerializedFieldType } from '../data/serializedfield/serializedfields';
/** For fields with Option or ApiOption type, the label and value for each available option */
export interface ExtensionCardFieldOption {
    label: string;
    value: SerializedFieldType;
    iconUrl?: string | undefined;
}
export interface ExtensionCardFieldDefinition extends FieldDefinition {
    /** The label to display in the UI */
    label: string;
    /** If defined, the default value for this field */
    default?: SerializedFieldType;
    /** Additional information we can provide to users, e.g. as a hover tooltip */
    description?: string | undefined;
    /**
     * If specified, the list of options available to choose from, or the name
     * of a registered action that returns the list of options (either directly
     * or as a Promise).
     */
    options?: ExtensionCardFieldOption[] | string | undefined;
    /**
     * If set, when this field is changed, selections for any of the fields in
     * this list will be unset.
     *
     * This is useful if changing this field invalidates the values of other fields.
     */
    unsetFieldsWhenChanged?: string[] | undefined;
    /**
     * If specified, an action that takes the search text and input so far, and
     * returns the list of options that should be displayed. This is useful when
     * there are too many possible options to reasonably use the "options"
     * option for options.
     */
    search?: string | undefined;
}
export type ExtensionCardUserData = ExtensionCardFieldOption & {
    email: string | undefined;
};
/** @ignore */
export type SerializedExtensionCardUserData = SerializedCardFieldOption & {
    'e'?: string | undefined;
};
/** @ignore */
export declare function serializeCardUserData(userData: ExtensionCardUserData): SerializedExtensionCardUserData;
/** @ignore */
export declare function deserializeCardUserData(userData: SerializedExtensionCardUserData): ExtensionCardUserData;
export declare const isSerializedCardUserData: (subject: unknown) => subject is import("../guards").DestructureGuardedTypeObj<{
    e: (x: unknown) => x is string | undefined;
    l: typeof isString;
    v: typeof isSerializedFieldType;
    i: (x: unknown) => x is string | undefined;
}>;
export declare const isSerializedCardUserDataArray: (p1: unknown) => p1 is import("../guards").DestructureGuardedTypeObj<{
    e: (x: unknown) => x is string | undefined;
    l: typeof isString;
    v: typeof isSerializedFieldType;
    i: (x: unknown) => x is string | undefined;
}>[];
export type ExtensionCardUserDataSearch = ((searchText: string, inputSoFar: Map<string, SerializedFieldType>, dataSourceId?: string) => Promise<ExtensionCardUserData[]>) | undefined;
/** @ignore */
export type SerializedCardFieldOption = {
    'l': string;
    'v'?: SerializedFieldType;
    'i'?: string | undefined;
};
/** @ignore */
export declare function serializeCardFieldOption(option: ExtensionCardFieldOption): SerializedCardFieldOption;
/** @ignore */
export type SerializedExtensionCardFieldDefinition = SerializedFieldDefinition & {
    'l': string;
    'def'?: SerializedFieldType;
    'd'?: string | undefined;
    'op'?: SerializedCardFieldOption[] | string | undefined;
    's'?: string | undefined;
    'u'?: string[] | undefined;
};
/** @ignore */
export declare function serializeCardFieldDefinition(field: ExtensionCardFieldDefinition): SerializedExtensionCardFieldDefinition;
/** @ignore */
export declare function serializeCardFieldArrayDefinition(fields: ExtensionCardFieldDefinition[]): SerializedExtensionCardFieldDefinition[];
/** @ignore */
export declare function deserializeFieldOption(option: SerializedCardFieldOption): ExtensionCardFieldOption;
export declare const isSerializedFieldOption: (subject: unknown) => subject is import("../guards").DestructureGuardedTypeObj<{
    l: typeof isString;
    v: typeof isSerializedFieldType;
    i: (x: unknown) => x is string | undefined;
}>;
export declare const isSerializedFieldOptions: (p1: unknown) => p1 is import("../guards").DestructureGuardedTypeObj<{
    l: typeof isString;
    v: typeof isSerializedFieldType;
    i: (x: unknown) => x is string | undefined;
}>[];
/** @ignore */
export declare const isSerializedExtensionCardFieldDefinition: (subject: unknown) => subject is import("../guards").DestructureGuardedTypeObj<{
    Name: typeof isString;
    Type: typeof isSerializedFieldTypeDefinition;
    Constraints: (x: unknown) => x is import("../guards").DestructureGuardedTypeObj<{
        Type: (x: unknown) => x is import("../data/serializedfield/serializedfielddefinition").FieldConstraintType;
        Details: (x: unknown) => x is any;
    }>[] | undefined;
    l: typeof isString;
    d: (x: unknown) => x is string | undefined;
    def: (x: unknown) => x is SerializedFieldType;
    op: (x: unknown) => x is string | import("../guards").DestructureGuardedTypeObj<{
        l: typeof isString;
        v: typeof isSerializedFieldType;
        i: (x: unknown) => x is string | undefined;
    }>[] | undefined;
    s: (x: unknown) => x is string | undefined;
    u: (x: unknown) => x is string[] | undefined;
}>;
/** @ignore */
export declare function deserializeCardFieldDefinition(field: SerializedExtensionCardFieldDefinition): ExtensionCardFieldDefinition;
/** @ignore */
export declare function deserializeCardFieldArrayDefinition(fields: SerializedExtensionCardFieldDefinition[]): ExtensionCardFieldDefinition[];
/**
 * Result of searching for data in the import modal
 *
 * If you change this interface, check if your changes need to be synced with
 * editorextensioncardintegrationregistry.ts.
 *
 */
export interface SearchResult {
    partialImportMetadata?: {
        collectionId: string;
        syncDataSourceId?: string;
    };
    data: CollectionDefinition;
    fields: ExtensionCardFieldDefinition[];
}
/**
 * Result of importing data from the import modal or dependency mapping
 */
export interface ImportResult {
    collection: CollectionProxy;
    primaryKeys: string[];
}
/**
 * Maps a DataItemProxy of an item that was already imported
 * to a list of primary keys for items that the original item has a relationship with.
 */
export type DependenciesForItems = Map<DataItemProxy, string[]>;
