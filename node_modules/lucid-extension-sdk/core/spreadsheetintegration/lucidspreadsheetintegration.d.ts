import { CollectionProxy } from '../../data/collectionproxy';
import { SerializedUpstreamConfig } from '../data/datasource/serializedupstreamconfig';
import { SerializedFieldType } from '../data/serializedfield/serializedfields';
import { SerializedSchema } from '../data/serializedfield/serializedschema';
import { JsonSerializable } from '../jsonserializable';
import { ExtensionCardFieldDefinition } from '../sharedcardintegration/cardintegrationdefinitions';
/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */
export declare enum LucidSpreadsheetIntegrationFailureType {
    AuthorizationFailure = "AuthorizationFailure",
    GenericFailure = "GenericFailure",
    UserCancelled = "UserCanceled",
    PopupsNotAllowed = "PopupsNotAllowed"
}
/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */
export declare const lucidSpreadsheetIntegrationFailureTypeValidator: (x: unknown) => x is LucidSpreadsheetIntegrationFailureType;
/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */
export type ImportedResults = {
    'upstreamConfig': SerializedUpstreamConfig;
    'collections': {
        'collectionId': string;
        'headerRow'?: number;
        'schema': SerializedSchema;
        'upstreamConfig'?: JsonSerializable;
    }[];
};
/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */
export declare const isImportedResults: (x: unknown) => x is ImportedResults;
/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */
export declare class ListChooser {
    readonly getList: () => Promise<{
        header: string[];
        rows: {
            id: string;
            values: string[];
            icon: string;
        }[];
    } | LucidSpreadsheetIntegrationFailureType>;
    constructor(getList: () => Promise<{
        header: string[];
        rows: {
            id: string;
            values: string[];
            icon: string;
        }[];
    } | LucidSpreadsheetIntegrationFailureType>);
}
/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */
export declare class CustomDetailsChooser {
    readonly getConfig: () => Promise<string | LucidSpreadsheetIntegrationFailureType>;
    constructor(getConfig: () => Promise<string | LucidSpreadsheetIntegrationFailureType>);
}
/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */
export declare abstract class LucidSpreadsheetIntegration {
    abstract labelDescription: string;
    /**
     * @deprecated Use iconConfiguration.primaryIconUrl.
     */
    abstract labelIconUrl: string;
    iconConfiguration?: {
        /**
         * URL for the primary icon to display in most components, usually on a white background.
         * Should be at least 24x24.
         */
        primaryIconUrl: string;
        /**
         * Optional. URL for an alternate light icon to show in colored components where the primary icon may appear too dark.
         * If not provided, the primaryIconUrl will be used. Should be at least 24x24.
         */
        lightIconUrl?: string;
        /**
         * Optional. URL for an alternate dark icon to show in colored components where the primary icon may appear too light.
         * If not provided, the primaryIconUrl will be used. Should be at least 24x24.
         */
        darkIconUrl?: string;
    };
    abstract dataConnectorName: string;
    addCardsIntegration: boolean;
    abstract configChooser: ListChooser | CustomDetailsChooser;
    abstract getMultipleSheetsForSpreadsheetDetails(spreadsheetDetails: string): Promise<Map<string, string> | LucidSpreadsheetIntegrationFailureType>;
    getUpstreamSourceUrl?(spreadsheetDetails: string, sheetId: string): Promise<{
        url: string;
    } | LucidSpreadsheetIntegrationFailureType>;
    /**
     * If specified, allow the user to create new cards and convert other shapes to cards
     */
    addCard?: {
        /**
         * Given the values entered by the user so far into input fields, return the list of all input fields
         * to display in the create-card form.
         */
        getInputFields: (inputSoFar: Map<string, SerializedFieldType>) => Promise<ExtensionCardFieldDefinition[]>;
        /**
         * Given the values entered by the user into input fields, create a new data record to represent the
         * created card, and return information about that record.
         */
        createCardData: (input: Map<string, SerializedFieldType>) => Promise<{
            collection: CollectionProxy;
            primaryKey: string;
        }>;
    };
}
