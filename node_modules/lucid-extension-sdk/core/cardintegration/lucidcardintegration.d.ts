import { CollectionProxy } from '../../data/collectionproxy';
import { DataSourceProxy } from '../../data/datasourceproxy';
import { TextStyle } from '../../document/text/textstyle';
import { EditorClient } from '../../editorclient';
import { isString } from '../checks';
import { SerializedFieldType } from '../data/serializedfield/serializedfields';
import { DependenciesForItems, ExtensionCardFieldDefinition, ImportResult } from '../sharedcardintegration/cardintegrationdefinitions';
import { CardIntegrationConfig } from './cardintegrationconfig';
import { DependencyMappingPhrasesType } from './dependencymappingphrases';
import { LucidCardIntegrationCustomImportModal } from './lucidcardintegrationcustomimportmodal';
import { LucidCardIntegrationStandardImportModal } from './lucidcardintegrationstandardimportmodal';
export interface FieldDescriptor {
    name: string;
    label?: string | undefined;
    locked?: boolean | undefined;
}
export declare const isFieldDescriptor: (subject: unknown) => subject is import("../guards").DestructureGuardedTypeObj<{
    name: typeof isString;
    label: (x: unknown) => x is string | undefined;
    locked: (x: unknown) => x is boolean | undefined;
}>;
export declare abstract class LucidCardIntegration {
    protected readonly client: EditorClient;
    constructor(client: EditorClient);
    /**
     * Label used to identify the integration, e.g. "Jira", which will be used in menu items, etc.
     * Should be unique within any given extension.
     */
    abstract label: string;
    /**
     * Label used to identify one card worth of data, e.g. "Jira task"
     */
    abstract itemLabel: string;
    /**
     * Label used to identify multiple cards worth of data, e.g. "Jira tasks"
     */
    abstract itemsLabel: string;
    /**
     * @deprecated Use iconConfiguration.primaryIconUrl.
     * URL for an icon to display in toolbars, etc. Should be at least 24x24.
     */
    abstract iconUrl: string;
    /**
     * The name of the data connector associated with the card integration.
     */
    abstract dataConnectorName: string;
    /**
     * The default text style to use on cards created as part of this integration.
     * These can be overridden by values in getDefaultConfig().fieldStyles for
     * individual fields that should have different styles.
     */
    textStyle?: Partial<TextStyle>;
    abstract fieldConfiguration: {
        /**
         * Callback to provide a list of all supported field names for the card integration.
         */
        getAllFields: (dataSource: DataSourceProxy) => Promise<string[] | FieldDescriptor[]>;
        /**
         * Callback that handled changes in the fields the user wants to be displayed in the card integration.
         * If this callback is not provided then the user will not be shown the modal to configure fields.
         */
        onSelectedFieldsChange?: (dataSource: DataSourceProxy, selectedFields: string[]) => Promise<void>;
        /**
         * Specify callbacks for searching for legal values for the given fields.
         *
         * For example, a Task collection may have an Assignee field that references a User collection,
         * but you don't import all the users in the entire source data set. Here, you can provide a way
         * to search for legal values for the Assignee field, similar to the `ExtensionCardFieldDefinition.search`
         * functionality.
         *
         * Register a search callback using LucidCardIntegrationRegistry.registerFieldSearchCallback, then set
         * the returned string as a value in this Map. The `inputSoFar` parameter passed to the callback will
         * be all the current field values on the item being edited.
         */
        fieldValueSearchCallbacks?: Map<string, string>;
        /**
         * Optional callback that's used when a field name may not map to any field defined in fieldValueSearchCallbacks.
         * Useful for when you don't know the field name ahead of time (e.g. a dynamically generated field name).
         */
        defaultSearchCallback?: string;
    };
    iconConfiguration?: {
        /**
         * URL for the primary icon to display in most components, usually on a white background.
         * Should be at least 24x24.
         */
        primaryIconUrl: string;
        /**
         * Optional. URL for an alternate light icon to show in colored components where the primary icon may appear too dark.
         * If not provided, the primaryIconUrl will be used. Should be at least 24x24.
         */
        lightIconUrl?: string;
    };
    /** If we are only able to search by name and not email in the card integration (ex: for JDC) */
    searchUserByName?: boolean;
    /** This is used to search for users in the card integration. It returns an additional email field of the user if available.*/
    userSearchCallback?: string;
    /**
     * @deprecated Use AuthorizationFlowHandlerRegistry.registerAuthorizationFlowHandler.
     * WARNING: Currently unused and does nothing.
     */
    showIntro?: () => void;
    /**
     * Provide the default configuration for a new import
     */
    abstract getDefaultConfig: (dataSource: DataSourceProxy) => Promise<CardIntegrationConfig>;
    /**
     * This allows the user to import cards by selecting items from within a modal. You can either create a custom
     * import modal or the standard import modal can be used.
     */
    importModal?: LucidCardIntegrationStandardImportModal | LucidCardIntegrationCustomImportModal;
    /**
     * If specified, allow the user to create new cards and convert other shapes to cards
     */
    addCard?: {
        /**
         * Given the values entered by the user so far into input fields, return the list of all input fields
         * to display in the create-card form.
         */
        getInputFields: (inputSoFar: Map<string, SerializedFieldType>) => Promise<ExtensionCardFieldDefinition[]>;
        /**
         * Given the values entered by the user into input fields, create a new data record to represent the
         * created card, and return information about that record.
         */
        createCardData: (input: Map<string, SerializedFieldType>) => Promise<{
            collection: CollectionProxy;
            primaryKey: string;
        }>;
    };
    showCardImport(name: string): import("../../commandtypes").ImportCardsResult;
    showDependencyMapping?: boolean;
    /**
     * This allows the user to import cards, by selecting dependencies of a linked item on the canvas.
     */
    importDependencies?: (dependenciesForItems: DependenciesForItems) => Promise<ImportResult[]>;
    /**
     * If specified, the text phrases to show in the dependency mapping UI.
     * If not specified, dependency mapping for this integration uses the default fallback phrases.
     */
    dependencyMappingPhrases?: DependencyMappingPhrasesType;
}
