"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.asAssertion = exports.validatorWithMessage = exports.minLengthValidator = exports.maxLengthValidator = exports.isDate = exports.isPositiveNumber = exports.isSize = exports.isPanelSize = exports.isBoundingBox = exports.isPointLike = exports.isOpacity = exports.isFalse = exports.isTrue = exports.isFlag = exports.isRestrictions = exports.isStringOrNegativeOne = exports.isBooleanOrEmptyString = exports.isNumberOrEmptyString = exports.isSet = exports.propertyValidator = exports.exclude = exports.bothWithInvalidFieldTracking = exports.both = exports.either = exports.isNullOption = exports.nullableOption = exports.option = exports.nullableValidatorWithInvalidElementTracking = exports.nullable = exports.objectOfValidatorWithInvalidFieldTracking = exports.objectOfValidator = exports.typedRecordValidator = exports.recordValidator = exports.strictObjectValidator = exports.partialObjectValidator = exports.objectValidatorWithInvalidFieldTracking = exports.objectValidator = exports.mapValidator = exports.someValidator = exports.someValue = exports.tupleValidator = exports.arrayValidatorWithInvalidElementTracking = exports.arrayValidator = exports.rangeValidator = exports.enumValidator = exports.stringEnumValidator = void 0;
const checks_1 = require("../checks");
/*********************************************************************************
 * Validator generators:  These functions construct new composite validators
 *from elemental validators.
 ********************************************************************************/
/**
 * Creates a validator which tests if the target is a string
 * and is one of the values in the specified enum (object).
 */
function stringEnumValidator(enumMap) {
    const enumValues = new Set();
    for (const key in enumMap) {
        const enumValue = enumMap[key];
        if ((0, checks_1.isString)(enumValue)) {
            enumValues.add(enumValue);
        }
    }
    // this allows using Set:has on unknown type
    const unknownEnumValues = enumValues;
    return (x) => {
        return unknownEnumValues.has(x);
    };
}
exports.stringEnumValidator = stringEnumValidator;
/**
 * Creates a validator which tests if the target is a value in the specified enum.
 * Note that numbers in enums are reverse-mapped by the TS transpiler, so the specified keys are also values.
 */
function enumValidator(enumMap) {
    return (x) => {
        for (const key in enumMap) {
            if (enumMap[key] === x) {
                return true;
            }
        }
        return false;
    };
}
exports.enumValidator = enumValidator;
/**
 * Creates a validator which tests if the target is a number
 * and is equal to or between the min and max values.
 *
 */
function rangeValidator(min, max) {
    return (x) => {
        return (0, checks_1.isNumber)(x) && x >= min && x <= max;
    };
}
exports.rangeValidator = rangeValidator;
/**
 * Creates a validator which tests if the target is an array
 * and if all elements of the array satisfy the given
 * sub-validator.
 *
 * @return A validator for the array type
 */
function arrayValidator(subValidator) {
    return (x) => {
        return (0, checks_1.isArray)(x) && x.every(subValidator);
    };
}
exports.arrayValidator = arrayValidator;
/**
 * This validator functions the same as {@link arrayValidator}, with the option of passing in a map
 * which will track all of the elements that were found to be invalid.
 */
function arrayValidatorWithInvalidElementTracking(subValidator) {
    return (subject, invalidElements, level = 0) => {
        var _a;
        if (!(0, checks_1.isArray)(subject)) {
            return false;
        }
        let valid = true;
        const invalidList = [];
        subject.forEach((item) => {
            if (!subValidator(item, invalidElements, level + 1)) {
                invalidList.push(item);
                valid = false;
            }
        });
        if ((0, checks_1.isMap)(invalidElements)) {
            const prevInvalidList = (_a = invalidElements.get(level)) !== null && _a !== void 0 ? _a : [];
            invalidElements.set(level, prevInvalidList.concat(invalidList));
        }
        return valid;
    };
}
exports.arrayValidatorWithInvalidElementTracking = arrayValidatorWithInvalidElementTracking;
/**
 * Creates a validator for a fixed width array where each entry
 * in the array can have a separate validator
 */
function tupleValidator(...tupleValidators) {
    return (x) => {
        return (typeof x === 'object' &&
            tupleValidators.length === x.length &&
            tupleValidators.every((subX, index) => subX(x[index])));
    };
}
exports.tupleValidator = tupleValidator;
/**
 * Creates a validator that the given unknown is one of the supplied values
 */
function someValue(...values) {
    return (x) => {
        for (const value of values) {
            if (x === value) {
                return true;
            }
        }
        return false;
    };
}
exports.someValue = someValue;
/**
 * Creates a validator that the given unknown matches at least one of the given validators
 */
function someValidator(...validators) {
    return (x) => {
        for (const validator of validators) {
            if (validator(x)) {
                return true;
            }
        }
        return false;
    };
}
exports.someValidator = someValidator;
/**
 * Creates a validator which tests if the target is an object
 * and if all values in the object satisfy the given sub-validator.
 * This does *not* perform any tests on the object keys, which
 * are allowed to be arbitrary strings.
 *
 * @return A validator for the map
 * Note that unlike objectValidator, this performs no validation on the names or
 * number of the keys and treats all values equally
 */
function mapValidator(subValidator) {
    return (x) => {
        return (0, checks_1.isObject)(x) && !(0, checks_1.isArray)(x) && Object.entries(x).every(([key, value]) => subValidator(value));
    };
}
exports.mapValidator = mapValidator;
/**
 * Creates a validator which tests if the target is an object
 * and if the structure of the object matches the structure of the passed-in
 * validator object.  The values in the validator object are in turn
 * validators.  This means that if the validator object has a (key,value)
 * pair of the form ('key', keyValidator), then in order for the target object
 * (x) to match, keyValidator(x['key']) must return true for all keys in the
 * validatorStructure.
 *
 * Note that you can use `lucid.validators.option` to create optional parameters
 * in validation structure.
 */
function objectValidator(validatorStructure) {
    return (subject) => {
        if ((0, checks_1.isArray)(subject) || !(0, checks_1.isObjectUnsafe)(subject)) {
            return false;
        }
        else {
            return Object.entries(validatorStructure).every(([key, validator]) => {
                return validator(subject[key]);
            });
        }
    };
}
exports.objectValidator = objectValidator;
/**
 * This validator functions the same as {@link objectValidator}, with the option of passing in a map
 * which will track all of the fields that were found to be invalid.
 */
function objectValidatorWithInvalidFieldTracking(validatorStructure) {
    return (subject, invalidFields, level = 0) => {
        var _a;
        if ((0, checks_1.isArray)(subject) || !(0, checks_1.isObjectUnsafe)(subject)) {
            return false;
        }
        else {
            let valid = true;
            const invalidList = [];
            Object.entries(validatorStructure).forEach(([key, validator]) => {
                if (!validator(subject[key], invalidFields, level + 1)) {
                    invalidList.push([key, subject[key]]);
                    valid = false;
                }
            });
            if ((0, checks_1.isMap)(invalidFields)) {
                const prevInvalidList = (_a = invalidFields.get(level)) !== null && _a !== void 0 ? _a : [];
                invalidFields.set(level, prevInvalidList.concat(invalidList));
            }
            return valid;
        }
    };
}
exports.objectValidatorWithInvalidFieldTracking = objectValidatorWithInvalidFieldTracking;
/**
 * Creates a validator which tests if the target is an object
 * and if the structure of the object matches the structure of the passed-in
 * validator object, but with every entry being optional.
 */
function partialObjectValidator(validatorStructure) {
    return (subject) => {
        if ((0, checks_1.isArray)(subject) || !(0, checks_1.isObjectUnsafe)(subject)) {
            return false;
        }
        else {
            return Object.entries(validatorStructure).every(([key, validator]) => {
                return subject[key] === undefined || validator(subject[key]);
            });
        }
    };
}
exports.partialObjectValidator = partialObjectValidator;
/**
 * Similar to {@link objectValidator}, but if the object has any non-undefined keys, they must also be present in the validator structure.
 * This is useful for things where extra data is unwanted, like Property serialization.
 * the loose version is often prefered because this one makes backwards compatible changes to the data harder,
 * because it requires an additional PR when the data transfers between services:
 * 1. A PR that adds the option() to this validator; 2. A PR that sends the new data; 3. A PR to remove the option();
 * compared to the (non-strict)objectValidator steps:
 * 1. A PR that adds the option() to this validator and sends the new data; 2. A PR to remove the option();
 */
function strictObjectValidator(validatorStructure) {
    const looseValidator = objectValidator(validatorStructure);
    return (subject) => {
        return (looseValidator(subject) &&
            Object.entries(subject).every(([key, subx]) => subx === undefined || validatorStructure.hasOwnProperty(key)));
    };
}
exports.strictObjectValidator = strictObjectValidator;
function recordValidator(keyList, valueValidator) {
    return (x) => {
        return ((0, checks_1.isObject)(x) &&
            !(0, checks_1.isArray)(x) &&
            keyList.every((k) => k in x) &&
            Object.entries(x).every(([key, val]) => {
                return valueValidator(val);
            }));
    };
}
exports.recordValidator = recordValidator;
function typedRecordValidator(keyValidator, valueValidator) {
    return (x) => {
        if ((0, checks_1.isArray)(x) || !(0, checks_1.isObject)(x)) {
            return false;
        }
        return Object.keys(x).every((key) => keyValidator(key)) && Object.values(x).every((val) => valueValidator(val));
    };
}
exports.typedRecordValidator = typedRecordValidator;
function objectOfValidator(subValidator) {
    return (x) => {
        if ((0, checks_1.isArray)(x) || !(0, checks_1.isObject)(x)) {
            return false;
        }
        return Object.values(x).every((val) => subValidator(val));
    };
}
exports.objectOfValidator = objectOfValidator;
/**
 * This validator functions the same as {@link objectOfValidator}, with the option of passing in a map
 * which will track all of the fields that were found to be invalid.
 */
function objectOfValidatorWithInvalidFieldTracking(subValidator) {
    return (subject, invalidFields, level = 0) => {
        var _a;
        if ((0, checks_1.isArray)(subject) || !(0, checks_1.isObjectUnsafe)(subject)) {
            return false;
        }
        let valid = true;
        const invalidList = [];
        Object.entries(subject).forEach(([key, val]) => {
            if (!subValidator(val, invalidFields, level + 1)) {
                invalidList.push([key, val]);
                valid = false;
            }
        });
        if ((0, checks_1.isMap)(invalidFields)) {
            const prevInvalidList = (_a = invalidFields.get(level)) !== null && _a !== void 0 ? _a : [];
            invalidFields.set(level, prevInvalidList.concat(invalidList));
        }
        return valid;
    };
}
exports.objectOfValidatorWithInvalidFieldTracking = objectOfValidatorWithInvalidFieldTracking;
/**
 * Create a validator which allows the target to be either null or satisfy the
 * sub-validator.
 *
 * @return A validator for the array type
 */
function nullable(subValidator) {
    return (x) => {
        return x === null || subValidator(x);
    };
}
exports.nullable = nullable;
/**
 * Create a validator which allows the target to be either null or satisfy the
 * sub-validator.
 *
 * @return A validator for the array type
 */
function nullableValidatorWithInvalidElementTracking(subValidator) {
    return (subject, invalidElements, level = 0) => {
        return subject === null || subValidator(subject, invalidElements, level);
    };
}
exports.nullableValidatorWithInvalidElementTracking = nullableValidatorWithInvalidElementTracking;
/**
 * Create a validator which allows the target to be undefined or satisfy the
 * sub-validator.
 *
 * @return A validator for the array type
 */
function option(subValidator) {
    return (x) => {
        return x === undefined || subValidator(x);
    };
}
exports.option = option;
/**
 * Create a validator which allows the target to be undefined, null, or satisfy
 * the sub-validator.
 *
 * @return A validator for the array type
 */
function nullableOption(subValidator) {
    return (x) => {
        return x === null || x === undefined || subValidator(x);
    };
}
exports.nullableOption = nullableOption;
const isNullOption = (value) => {
    return value == null;
};
exports.isNullOption = isNullOption;
/**
 * Create a validator that merges two validators.
 * This is useful for validating properties that have 2 disjoint sets of possible values.
 * e.g. {someObject: string}|false
 */
function either(validatorA, validatorB) {
    return (x) => {
        return validatorA(x) || validatorB(x);
    };
}
exports.either = either;
/**
 * Create a validator that combines two validators.
 * This is useful for validating properties that have been composed of a generic and more specific values.
 */
function both(validatorA, validatorB) {
    return (x) => {
        return validatorA(x) && validatorB(x);
    };
}
exports.both = both;
function bothWithInvalidFieldTracking(validatorA, validatorB) {
    return (x, invalidFields, level = 0) => {
        return validatorA(x, invalidFields, level) && validatorB(x, invalidFields, level);
    };
}
exports.bothWithInvalidFieldTracking = bothWithInvalidFieldTracking;
/**
 * Create a validator that allows types excluding those that satisfy an excludeValidator.
 */
function exclude(validator, excludeValidator) {
    return (x) => validator(x) && !excludeValidator(x);
}
exports.exclude = exclude;
/**
 * Get a validator which returns whether the property calculation structure is
 * correct.
 */
function propertyValidator(subValidator, preSaveActions) {
    const processedValidator = (x) => {
        const y = preSaveActions.reduce((px, psa) => psa(px), x);
        return subValidator(y);
    };
    return strictObjectValidator({ 'Equation': checks_1.isString, 'StaticValue': processedValidator });
}
exports.propertyValidator = propertyValidator;
/*********************************************************************************
 * Validators:  Some useful predefined validator functions.
 ********************************************************************************/
/**
 * This validator only allows objects whose values are all booleans set to true.
 *
 * @return A validator for the map
 */
function isSet(x) {
    return (0, checks_1.isObject)(x) && !(0, checks_1.isArray)(x) && Object.entries(x).every(([key, value]) => (0, checks_1.isBoolean)(value) && !!value);
}
exports.isSet = isSet;
/**
 * This validator validates that value is either number or empty string
 */
exports.isNumberOrEmptyString = either(checks_1.isNumber, (v) => v === '');
/**
 * This validator validates that value is either boolean or empty string
 */
exports.isBooleanOrEmptyString = either(checks_1.isBoolean, (v) => v === '');
/**
 * This validator validates that value is either string or -1
 */
exports.isStringOrNegativeOne = either(checks_1.isString, (v) => v === -1);
/**
 * This validator validates model of lucid.model.restrictions
 */
exports.isRestrictions = strictObjectValidator({
    'b': nullableOption(checks_1.isBoolean),
    'p': nullableOption(checks_1.isBoolean),
    'c': nullableOption(checks_1.isBoolean),
    'f': nullableOption(checks_1.isBoolean),
    'o': nullableOption(checks_1.isBoolean),
    'e': nullableOption(checks_1.isBoolean),
    'fc': nullableOption(checks_1.isBoolean),
    'fs': nullableOption(checks_1.isBoolean),
    'l': nullableOption(checks_1.isBoolean),
    'i': nullableOption(checks_1.isBoolean),
    'u': nullableOption(checks_1.isBoolean),
    'acap': nullableOption(checks_1.isBoolean),
    'scap': nullableOption(checks_1.isBoolean),
    'imageCategory': nullableOption(checks_1.isBoolean),
    'pcad': nullableOption(checks_1.isBoolean),
});
/**
 * Returns true if the target is equal to either zero or one or is a boolean.
 *
 */
function isFlag(x) {
    return x === 0 || x === 1 || (0, checks_1.isBoolean)(x);
}
exports.isFlag = isFlag;
function isTrue(x) {
    return x === true;
}
exports.isTrue = isTrue;
function isFalse(x) {
    return x === false;
}
exports.isFalse = isFalse;
/**
 * Returns if an object is a number between 0 and 100.
 *
 */
exports.isOpacity = rangeValidator(0, 100);
/**
 * Tests if the given target satisfies the PointLike interface.
 *
 */
exports.isPointLike = objectValidator({ x: checks_1.isNumber, y: checks_1.isNumber });
/**
 * Tests if the given target is a bounding box.
 *
 */
exports.isBoundingBox = objectValidator({
    x: checks_1.isNumber,
    y: checks_1.isNumber,
    w: checks_1.isNumber,
    h: checks_1.isNumber,
});
/**
 * Tests if the given target is a panel size.
 *
 */
exports.isPanelSize = objectValidator({
    x: checks_1.isNumber,
    y: checks_1.isNumber,
    w: checks_1.isNumber,
    h: checks_1.isNumber,
    'identifier': nullableOption(checks_1.isString),
});
exports.isSize = objectValidator({
    w: checks_1.isNumber,
    h: checks_1.isNumber,
});
function isPositiveNumber(x) {
    return (0, checks_1.isNumber)(x) && x >= 0;
}
exports.isPositiveNumber = isPositiveNumber;
function isDate(x) {
    return x instanceof Date;
}
exports.isDate = isDate;
function maxLengthValidator(max) {
    return (x) => (0, checks_1.isString)(x) && x.length <= max;
}
exports.maxLengthValidator = maxLengthValidator;
function minLengthValidator(min) {
    return (x) => (0, checks_1.isString)(x) && x.length >= min;
}
exports.minLengthValidator = minLengthValidator;
function validatorWithMessage(validator, message, sub) {
    return (x) => (validator(x) ? (sub ? sub(x) : true) : message);
}
exports.validatorWithMessage = validatorWithMessage;
function asAssertion(validator) {
    return (val) => {
        if (!validator(val)) {
            throw new Error();
        }
    };
}
exports.asAssertion = asAssertion;
