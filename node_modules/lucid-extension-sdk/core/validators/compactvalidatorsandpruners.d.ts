import { WithUndefinedAsOptional } from '../optionalkey';
/**
 * ObjectAttributeType represents the possible keys for an Object.
 * (equivalent to string | number | symbol.) */
type ObjectAttributeType = keyof any;
/**
 * A generic type for a Validator that narrows FROM to TO.
 */
type Validator<TO extends FROM, FROM = unknown> = (unknownVariable: FROM) => unknownVariable is TO;
/**
 * A record that maps each key in an object to its respective ValidatorWithOptionalPruner.
 */
type ObjectValidatorConfig = Record<ObjectAttributeType, ValidatorWithOptionalPruner<unknown> | Validator<unknown>>;
/**
 * A generic type for a pruner function. It takes in any data and returns:
 *   - prunerResult: The pruned data (or possibly the same data if no pruning is needed) which also constains
 *                   invalidFields: a map of invalid fields (represented by keys) to their original invalid values.
 */
type Pruner = (unprunedData: unknown) => PrunerResult;
/**
 * The result object returned from a pruner function.
 */
export interface PrunerResult {
    prunerResult: unknown;
    invalidFields: Map<string, unknown>;
}
/**
 * Represents a validator and an optional pruner.
 *
 * - `validator` is the function used to validate the data.
 * - `pruner` can optionally used to prune invalid data fields if validation fails.
 */
interface ValidatorWithOptionalPruner<TO = unknown> {
    'validator': Validator<TO>;
    'pruner'?: Pruner;
}
interface ValidatorWithPruner<TO = unknown> {
    'validator': Validator<TO>;
    'pruner': Pruner;
}
/**
 * Helper type that extracts the "TO" type from a ValidatorWithOptionalPruner<T>.
 */
type ExtractValidatedTypeFromConfig<V> = V extends {
    validator: Validator<infer U>;
} ? U : V extends Validator<infer U> ? U : never;
/**
 * Converts an ObjectValidator into a validated TypeScript type by inferring each property's `TO` type from its `validator`.
 *  Note it also makes undefined properties optional.
 */
type ObjectValidatorToValidatedType<T extends ObjectValidatorConfig> = WithUndefinedAsOptional<{
    [K in keyof T]: ExtractValidatedTypeFromConfig<T[K]>;
}>;
/**
 * Recursively applies a "prettifying" transformation to the inferred object type.
 * - For functions, it leaves them as-is.
 * - For objects, it recurses down into properties.
 * - Otherwise, returns the type unchanged.
 */
type PrettifyDeep<T> = T extends (...args: any[]) => any ? T : T extends object ? {
    [K in keyof T]: PrettifyDeep<T[K]>;
} : T;
/**
 * Extracts the final type from @param ObjectValidatorConfig
 */
type PrettifiedObjectValidatorType<T extends ObjectValidatorConfig> = PrettifyDeep<ObjectValidatorToValidatedType<T>>;
export type ExtractValidatedTypeFromValidator<V extends Validator<unknown>> = V extends Validator<infer U> ? U : never;
/**
 * Creates a validator and pruner for an object.
 *
 * - The validator will ensure that all properties pass their respective child validator.
 * - The pruner will remove or transform invalid fields as configured by the child pruners.
 *
 * @param objectValidatorConfig A record mapping property keys to their validators (and optional pruners).
 * @returns ValidatorWithPruner for the object.
 */
export declare function getObjectValidatorAndPruner<T extends ObjectValidatorConfig>(objectValidatorConfig: T): ValidatorWithPruner<PrettifiedObjectValidatorType<T>>;
/**
 * Create a validator and pruner for an array of elements.
 *
 * - The validator ensures that each element in the array passes a common element validator.
 * - The pruner removes or transforms invalid elements as configured by the element pruner.
 *
 * @param arrayElementConfig A single validator (and optionally a pruner) used for each element.
 * @returns ValidatorWithPruner for the array.
 */
export declare function getArrayValidatorAndPruner<ElementType>(arrayElementConfig: ValidatorWithOptionalPruner<ElementType> | Validator<ElementType>): ValidatorWithPruner<ElementType[]>;
/**
 * Function used in objectFieldConfig and arrayElementConfig to speficy that invalid
 * items must be pruned/marked as undefined.
 * @param element The data that failed validation and needs pruning.
 */
export declare const pruneElement: (element: unknown) => PrunerResult;
/**
 * Combines a "per-element pruner" for an arrayâ€™s elements with an "entire array pruner."
 *
 * - If the incoming data is not an array, it applies the `wholeArrayPruner`.
 * - If it is an array, it applies the `perElementPruner` to each element.
 *
 * This is useful when you have specialized logic for array-level pruning
 * (e.g., removing the entire array if it fails some overarching condition)
 * but still want to prune individual elements if possible.
 *
 * @param perElementPruner A pruner for each element in the array.
 * @param wholeArrayPruner A pruner for the entire array.
 * @returns A Pruner that handles both array-level and element-level pruning.
 */
export declare function liftArrayPruner(perElementPruner: Pruner, wholeArrayPruner: Pruner): Pruner;
/**
 * Helper function to easily create a `ValidatorWithOptionalPruner`.
 *
 * @param validator The validation function to determine valid vs invalid data.
 * @param pruner    The optional pruner function to sanitize or remove invalid data.
 * @returns An object containing both the validator and the (optional) pruner.
 */
export declare function getValidatorPrunerConfig<TO>(validator: Validator<TO>, pruner?: Pruner): ValidatorWithOptionalPruner<TO>;
export {};
