"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getValidatorPrunerConfig = exports.liftArrayPruner = exports.pruneElement = exports.getArrayValidatorAndPruner = exports.getObjectValidatorAndPruner = void 0;
const checks_1 = require("../checks");
function getValidatorFromConfig(validatorConfig) {
    if ('validator' in validatorConfig) {
        return validatorConfig.validator;
    }
    return validatorConfig;
}
function getPrunerFromConfig(validatorConfig) {
    if ('pruner' in validatorConfig) {
        return validatorConfig.pruner;
    }
    return undefined;
}
/**
 * Creates a validator and pruner for an object.
 *
 * - The validator will ensure that all properties pass their respective child validator.
 * - The pruner will remove or transform invalid fields as configured by the child pruners.
 *
 * @param objectValidatorConfig A record mapping property keys to their validators (and optional pruners).
 * @returns ValidatorWithPruner for the object.
 */
function getObjectValidatorAndPruner(objectValidatorConfig) {
    const objectValidatorFunction = (subject) => {
        if (!(0, checks_1.isObjectUnsafe)(subject)) {
            return false;
        }
        for (const key in objectValidatorConfig) {
            const validator = getValidatorFromConfig(objectValidatorConfig[key]);
            if (!validator(subject[key])) {
                return false;
            }
        }
        return true;
    };
    const objectPrunerFunction = (subject) => {
        if ((0, checks_1.isArray)(subject) || !(0, checks_1.isObjectUnsafe)(subject)) {
            return {
                prunerResult: subject,
                invalidFields: createElementInvalidField(subject),
            };
        }
        const invalidFields = new Map();
        // Make a shallow copy to avoid mutating the original object
        const prunerResult = Object.assign({}, subject);
        for (const key in objectValidatorConfig) {
            const validator = getValidatorFromConfig(objectValidatorConfig[key]);
            const pruner = getPrunerFromConfig(objectValidatorConfig[key]);
            if (!validator(prunerResult[key])) {
                if (!pruner) {
                    // If there's no pruner, mark the field invalid but retain the original value.
                    invalidFields.set(`${key}:`, prunerResult[key]);
                    continue;
                }
                const prunerFieldResult = pruner(prunerResult[key]);
                prunerResult[key] = prunerFieldResult.prunerResult;
                for (const [invalidSubKey, invalidValue] of prunerFieldResult.invalidFields) {
                    invalidFields.set(`${key}:${invalidSubKey}`, invalidValue);
                }
            }
        }
        return { prunerResult, invalidFields };
    };
    return { validator: objectValidatorFunction, pruner: objectPrunerFunction };
}
exports.getObjectValidatorAndPruner = getObjectValidatorAndPruner;
/**
 * Create a validator and pruner for an array of elements.
 *
 * - The validator ensures that each element in the array passes a common element validator.
 * - The pruner removes or transforms invalid elements as configured by the element pruner.
 *
 * @param arrayElementConfig A single validator (and optionally a pruner) used for each element.
 * @returns ValidatorWithPruner for the array.
 */
function getArrayValidatorAndPruner(arrayElementConfig) {
    const arrayValidatorFunction = (subject) => {
        if (!(0, checks_1.isArray)(subject)) {
            return false;
        }
        const elementValidator = getValidatorFromConfig(arrayElementConfig);
        return subject.every((element) => elementValidator(element));
    };
    const arrayPrunerFunction = (subject) => {
        if (!(0, checks_1.isArray)(subject)) {
            return {
                prunerResult: subject,
                invalidFields: createElementInvalidField(subject),
            };
        }
        const elementValidator = getValidatorFromConfig(arrayElementConfig);
        const elementPruner = getPrunerFromConfig(arrayElementConfig);
        const invalidFields = new Map();
        const prunerResult = subject
            .map((item, index) => {
            if (!elementValidator(item)) {
                if (!elementPruner) {
                    invalidFields.set(`${index}:`, item);
                    return item;
                }
                const prunerElementResult = elementPruner(item);
                for (const [subKey, subValue] of prunerElementResult.invalidFields) {
                    invalidFields.set(`${index}:${subKey}`, subValue);
                }
                return prunerElementResult.prunerResult;
            }
            return item;
        })
            .filter(checks_1.isDef);
        return { prunerResult, invalidFields };
    };
    return { validator: arrayValidatorFunction, pruner: arrayPrunerFunction };
}
exports.getArrayValidatorAndPruner = getArrayValidatorAndPruner;
/**
 * Creates a Map signifying that the entire `element` was invalid,
 * with a key of `""` or some placeholder to represent the entire item.
 */
function createElementInvalidField(element) {
    return new Map([['', element]]);
}
/**
 * Function used in objectFieldConfig and arrayElementConfig to speficy that invalid
 * items must be pruned/marked as undefined.
 * @param element The data that failed validation and needs pruning.
 */
const pruneElement = (element) => {
    return { prunerResult: undefined, invalidFields: createElementInvalidField(element) };
};
exports.pruneElement = pruneElement;
/**
 * Combines a "per-element pruner" for an arrayâ€™s elements with an "entire array pruner."
 *
 * - If the incoming data is not an array, it applies the `wholeArrayPruner`.
 * - If it is an array, it applies the `perElementPruner` to each element.
 *
 * This is useful when you have specialized logic for array-level pruning
 * (e.g., removing the entire array if it fails some overarching condition)
 * but still want to prune individual elements if possible.
 *
 * @param perElementPruner A pruner for each element in the array.
 * @param wholeArrayPruner A pruner for the entire array.
 * @returns A Pruner that handles both array-level and element-level pruning.
 */
function liftArrayPruner(perElementPruner, wholeArrayPruner) {
    return (data) => {
        if (!(0, checks_1.isArray)(data)) {
            return wholeArrayPruner(data);
        }
        return perElementPruner(data);
    };
}
exports.liftArrayPruner = liftArrayPruner;
/**
 * Helper function to easily create a `ValidatorWithOptionalPruner`.
 *
 * @param validator The validation function to determine valid vs invalid data.
 * @param pruner    The optional pruner function to sanitize or remove invalid data.
 * @returns An object containing both the validator and the (optional) pruner.
 */
function getValidatorPrunerConfig(validator, pruner) {
    return { validator, pruner };
}
exports.getValidatorPrunerConfig = getValidatorPrunerConfig;
