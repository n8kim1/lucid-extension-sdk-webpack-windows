"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pruneObjectField = exports.arrayPruner = exports.objectPruner = void 0;
const checks_1 = require("../checks");
/**
 * Creates a pruner function that will remove object fields that are invalid.
 * If a sub-pruner is provided for a field, then the object field values will be pruned.
 * If no pruner is provided for field, nothing happens to that field.
 *
 * @returns A pruner function that takes data and invalid fields. If data is not an
 * object, it will return the data as is instead of pruning.
 */
function objectPruner(subPruners) {
    return (data, invalidFields, level = 0) => {
        if ((0, checks_1.isArray)(data) || !(0, checks_1.isObjectUnsafe)(data)) {
            return data;
        }
        const dataToBePruned = Object.assign({}, data);
        Object.entries(subPruners).forEach(([key, pruner]) => {
            dataToBePruned[key] = pruner(dataToBePruned[key], invalidFields, level + 1, key);
        });
        return dataToBePruned;
    };
}
exports.objectPruner = objectPruner;
/**
 * Creates a pruner function that will remove array elements that are invalid.
 * If a sub-pruner is provided, then the elements themselves will be pruned rather
 * than removed from the list.
 *
 * @returns A pruner function that takes data and invalid fields. If data is not an
 * array, it will return the data as is instead of pruning.
 */
function arrayPruner(subPruner) {
    return (data, invalidElements, level = 0) => {
        if (!(0, checks_1.isArray)(data)) {
            return data;
        }
        if (subPruner) {
            return data.reduce((acc, item) => {
                var _a;
                const prunedItem = subPruner(item, invalidElements, level + 1);
                /* Here we are relying on the fact that the pruner will return the same object reference, if it is not
                   pruned, but will return a new object reference, if it is pruned. This is a bit of a hack but
                    TODO EI 50 we're overhauling how this works in future
                */
                if (prunedItem === item && ((_a = invalidElements === null || invalidElements === void 0 ? void 0 : invalidElements.get(level)) === null || _a === void 0 ? void 0 : _a.includes(item))) {
                    return acc;
                }
                acc.push(prunedItem);
                return acc;
            }, []);
        }
        else {
            return data.filter((item) => { var _a; return !((_a = invalidElements === null || invalidElements === void 0 ? void 0 : invalidElements.get(level)) === null || _a === void 0 ? void 0 : _a.includes(item)); });
        }
    };
}
exports.arrayPruner = arrayPruner;
/*
 * Creates a pruner function to be passed in with the object pruner that will remove the field if it is invalid.
 */
function pruneObjectField() {
    return (data, invalidFields, level = 0, key = undefined) => {
        var _a;
        // When this is called as a part of objectPruner, level will be atleast 1
        if ((0, checks_1.isArray)(data) || level <= 0) {
            return data;
        }
        const invalidFieldAtCurrentLevel = (_a = invalidFields === null || invalidFields === void 0 ? void 0 : invalidFields.get(level - 1)) === null || _a === void 0 ? void 0 : _a.filter(checks_1.isArray);
        if (!(0, checks_1.isDef)(invalidFieldAtCurrentLevel)) {
            return data;
        }
        if (invalidFieldAtCurrentLevel.some((value) => value[0] === key && value[1] === data)) {
            return undefined;
        }
        return data;
    };
}
exports.pruneObjectField = pruneObjectField;
