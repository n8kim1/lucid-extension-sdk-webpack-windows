"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeBase64 = exports.decodeBase64 = void 0;
const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
//This gives a ~8x speedup vs. using alphabet.indexOf() in the main decode loop.
const charCodeToEncodedInt = [];
for (let i = 0; i < alphabet.length; i++) {
    charCodeToEncodedInt[alphabet.charCodeAt(i)] = i;
}
function decodeBase64(base64String) {
    //Filter out whitespace, etc
    base64String = base64String.replace(/[^A-Za-z0-9\+\/\=]/g, '');
    if (base64String.length % 4 !== 0) {
        throw new Error('Invalid base64 input; length must be a multiple of 4');
    }
    //4 characters of input turns into 3 bytes of output
    let bytes = (base64String.length / 4) * 3;
    //But each trailing = (up to 2) is one fewer byte of output
    if (base64String.endsWith('==')) {
        bytes -= 2;
    }
    else if (base64String.endsWith('=')) {
        bytes -= 1;
    }
    const output = new Uint8Array(bytes);
    let inputIndex = 0;
    for (let outputIndex = 0; outputIndex < bytes; outputIndex += 3) {
        //Get the 4 numbers 0-63 encoded in the next 4 characters
        const enc1 = charCodeToEncodedInt[base64String.charCodeAt(inputIndex++)];
        const enc2 = charCodeToEncodedInt[base64String.charCodeAt(inputIndex++)];
        const enc3 = charCodeToEncodedInt[base64String.charCodeAt(inputIndex++)];
        const enc4 = charCodeToEncodedInt[base64String.charCodeAt(inputIndex++)];
        if (enc1 === undefined || enc2 === undefined || enc3 === undefined || enc4 === undefined) {
            throw new Error('char code to encoded int contains an undefined index');
        }
        //Read 8 total bits into each of the output values. Skip one byte
        //for each padding = at the end of the string
        output[outputIndex] = (enc1 << 2) | (enc2 >> 4);
        if (enc3 != 64) {
            output[outputIndex + 1] = ((enc2 & 15) << 4) | (enc3 >> 2);
        }
        if (enc4 != 64) {
            output[outputIndex + 2] = ((enc3 & 3) << 6) | enc4;
        }
    }
    return output;
}
exports.decodeBase64 = decodeBase64;
function encodeBase64(byteArray) {
    // 3 bytes of input become 4 chars of output
    // i.e. every 6 bits of input becomes 1 char of output
    const fullByteChunkCount = Math.floor(byteArray.length / 3);
    const outputLength = Math.ceil(byteArray.length / 3) * 4;
    const output = new Array(outputLength);
    let inputIndex = 0;
    let outputIndex = 0;
    for (let byteChunkIndex = 0; byteChunkIndex < fullByteChunkCount; byteChunkIndex++) {
        const byte1 = byteArray[inputIndex++];
        const byte2 = byteArray[inputIndex++];
        const byte3 = byteArray[inputIndex++];
        if (byte1 === undefined || byte2 === undefined || byte3 === undefined) {
            throw new Error('byteArray contains undefined indexes');
        }
        const enc1 = byte1 >> 2; // first 6 bits of byte1
        const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4); // last 2 bits of byte1 and first 4 bits of byte2
        const enc3 = ((byte2 & 15) << 2) | (byte3 >> 6); // last 4 bits of byte2 and first 2 bits of byte3
        const enc4 = byte3 & 63; // last 6 bits of byte3
        output[outputIndex++] = alphabet[enc1];
        output[outputIndex++] = alphabet[enc2];
        output[outputIndex++] = alphabet[enc3];
        output[outputIndex++] = alphabet[enc4];
    }
    // handle remainder, i.e. trailing one or two bytes
    if (inputIndex < byteArray.length) {
        const byte1 = byteArray[inputIndex++];
        const hasSecondByte = inputIndex < byteArray.length;
        const byte2 = hasSecondByte ? byteArray[inputIndex++] : 0;
        const enc1 = byte1 >> 2; // first 6 bits of byte1
        const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4); // last 2 bits of byte1 and first 4 bits of byte2
        const enc3 = hasSecondByte ? (byte2 & 15) << 2 : 64; // last 4 bits of byte2
        output[outputIndex++] = alphabet[enc1];
        output[outputIndex++] = alphabet[enc2];
        output[outputIndex++] = alphabet[enc3];
        output[outputIndex++] = '=';
    }
    return output.join('');
}
exports.encodeBase64 = encodeBase64;
