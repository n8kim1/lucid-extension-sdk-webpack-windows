import { CollectionEnumFieldType, SerializedCollectionEnumFieldType } from './collectionenumfieldtype';
import { DeserializedMapEnumFieldType, SerializedMapEnumFieldType } from './deserializedmapenumfieldtype';
import { LiteralFieldType, SerializedLiteralFieldType } from './literalfieldtype';
import { ScalarFieldTypeEnum } from './scalarfieldtype';
export declare abstract class BaseFieldTypeArray<Type> {
    readonly validTypesArray: Type[];
    constructor(validTypesArray: Type[]);
    protected abstract serializeType(t: Type): SerializedFieldTypeArraySubTypes;
    getInnerTypes(): Type[];
    getInnerNonArrayTypes(): Exclude<Type, BaseFieldTypeArray<Type>>[];
    toJSON(): SerializedFieldTypeArray;
}
export type FieldTypeArraySubTypes = ScalarFieldTypeEnum | CollectionEnumFieldType | DeserializedMapEnumFieldType | LiteralFieldType | FieldTypeArray<any>;
export type SerializedFieldTypeArraySubTypes = ScalarFieldTypeEnum | SerializedLiteralFieldType | SerializedFieldTypeArray | SerializedCollectionEnumFieldType | SerializedMapEnumFieldType;
export declare class FieldTypeArray<SubTypes extends FieldTypeArraySubTypes = FieldTypeArraySubTypes> extends BaseFieldTypeArray<SubTypes> {
    protected serializeType(t: FieldTypeArraySubTypes): string | SerializedCollectionEnumFieldType | ScalarFieldTypeEnum | SerializedMapEnumFieldType | SerializedFieldTypeArray;
}
export type SerializedFieldTypeArray = {
    'ND': false;
    'validTypes': SerializedFieldTypeArraySubTypes[];
};
export declare function isSerializedFieldTypeArray(fieldType: any, validateTypeCheck: (t: unknown) => boolean): fieldType is SerializedFieldTypeArray;
export declare function deserializeFieldTypeArray(serializedFieldTypeArray: SerializedFieldTypeArray): FieldTypeArray;
