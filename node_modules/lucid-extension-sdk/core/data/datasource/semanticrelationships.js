"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSemanticRelationship = exports.getInverseSemanticRelationship = exports.SemanticRelationships = void 0;
const validators_1 = require("../../validators/validators");
/**
 * Semantic Relationships serve as standardized categories of relationships which exist in multiple data sources but potentially under different names.
 * For instance, regardless of the data source, relationships that pertains to parent/child structures can be categorized under the Semantic Relationship "IsParentOf" and "IsChildOf".
 *
 * Benefits of Semantic Relationships:
 * Uniformity: Ensures that data from diverse sources is referenced consistently within Lucid.
 * Integration Simplicity: Simplifies the process of integrating new data sources into Lucid by mapping to an established set of Semantic Relationships.
 * Feature Compatibility: Allows for seamless use of Lucidâ€™s intelligent features across all data, regardless of its origin.
 * Data Organization: Provides a structured approach to organizing and grouping data within the Lucid ecosystem.
 */
var SemanticRelationships;
(function (SemanticRelationships) {
    SemanticRelationships["RelatesTo"] = "Relates To";
    SemanticRelationships["Duplicates"] = "Duplicates";
    SemanticRelationships["IsDuplicatedBy"] = "Is Duplicated By";
    SemanticRelationships["Blocks"] = "Blocks";
    SemanticRelationships["IsBlockedBy"] = "Is Blocked By";
    SemanticRelationships["Clones"] = "Clones";
    SemanticRelationships["IsClonedBy"] = "Is Cloned By";
    SemanticRelationships["IsParentOf"] = "Is Parent Of";
    SemanticRelationships["IsChildOf"] = "Is Child Of";
})(SemanticRelationships || (exports.SemanticRelationships = SemanticRelationships = {}));
function getInverseSemanticRelationship(relationship) {
    switch (relationship) {
        case SemanticRelationships.Duplicates:
            return SemanticRelationships.IsDuplicatedBy;
        case SemanticRelationships.IsDuplicatedBy:
            return SemanticRelationships.Duplicates;
        case SemanticRelationships.Blocks:
            return SemanticRelationships.IsBlockedBy;
        case SemanticRelationships.IsBlockedBy:
            return SemanticRelationships.Blocks;
        case SemanticRelationships.Clones:
            return SemanticRelationships.IsClonedBy;
        case SemanticRelationships.IsClonedBy:
            return SemanticRelationships.Clones;
        case SemanticRelationships.IsParentOf:
            return SemanticRelationships.IsChildOf;
        case SemanticRelationships.IsChildOf:
            return SemanticRelationships.IsParentOf;
        default:
            return relationship;
    }
}
exports.getInverseSemanticRelationship = getInverseSemanticRelationship;
exports.isSemanticRelationship = (0, validators_1.stringEnumValidator)(SemanticRelationships);
