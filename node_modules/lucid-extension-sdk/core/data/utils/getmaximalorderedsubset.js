"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMaximalOrderedSubset = void 0;
const checks_1 = require("../../checks");
/**
 * This function implements the O(n*log(n)) algorithm from the wikipedia article
 * https://en.wikipedia.org/wiki/Longest_increasing_subsequence to get the longest increasing sub-sequence of the numbers
 * in the array. Note that the algorithm simply ignores undefined entries. This is current used to optimize data usage
 * in the ItemOrderPatch metadata collection.
 *
 * @param X an array of distinct numbers (or undefineds, which are ignored)
 * @returns An array of numeric entries pulled from X which are in the same order as they were in X, and have the
 *             longest possible length of all such possible arrays. This answer may not be unique, but it will be
 *             as long or longer than all other candidates.
 */
function getMaximalOrderedSubset(X) {
    var _a;
    const M = [];
    const P = [];
    X.forEach((val, valInd) => {
        if ((0, checks_1.isNumber)(val)) {
            let lo = 0;
            let hi = M.length;
            while (lo < hi) {
                const mid = lo + Math.floor((hi - lo) / 2);
                const compValue = X[M[mid]];
                if (compValue != null && compValue > val) {
                    hi = mid;
                }
                else {
                    lo = mid + 1;
                }
            }
            P.push(lo > 0 ? M[lo - 1] : undefined);
            M[lo] = valInd;
        }
        else {
            P.push(undefined);
        }
    });
    const S = [];
    if (M.length > 0) {
        let k = M[M.length - 1];
        for (let j = M.length - 1; j >= 0; j--) {
            const val = X[k];
            val != null && S.unshift(val);
            k = (_a = P[k]) !== null && _a !== void 0 ? _a : -1;
        }
    }
    return S;
}
exports.getMaximalOrderedSubset = getMaximalOrderedSubset;
