"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormattedPrimaryKey = exports.declareSchema = void 0;
function isArrayAndAssertReadonly(val) {
    return Array.isArray(val);
}
/**
 * Specifies all the fields that this itegration will be sending to the data-sync service.
 * Give you well typed methods to convert from `YourType[]` to `{[PrimaryKey:string]: YourType}`
 * which is what most of the data sync service calls expect.
 *
 * There is fromItems which does the above will full type information, and fromItems sparse
 * which allows all the fields not part of the primaryKey to be undefined. The former should
 * be used with initial imports, and the latter can be used for updates.
 *
 * If you declare your schema using PrimaryKey values that *exactly* match (case sensitive) the enum values of
 * `collectionenumfieldtype.ts` (e.g. using a key with the value "id" for your ID field) you will be opting in to some
 * additional (and valuable) user functionality. This includes better support in the edit panel, and better user facing
 * descriptions of your fields.
 */
function declareSchema({ primaryKey, fields }) {
    const primaryKeyObj = new FormattedPrimaryKey(...primaryKey);
    return {
        example: fields,
        array: Object.entries(fields).map(([name, { type, constraints, mapping }]) => {
            return {
                'name': name,
                'type': isArrayAndAssertReadonly(type) ? type.slice() : type,
                'constraints': constraints,
                'mapping': mapping,
            };
        }),
        primaryKey: primaryKeyObj,
        fromItemsSparse: (items) => {
            return new Map(items.map((item) => [primaryKeyObj.forItem(item), item]));
        },
        fromItems: (items) => {
            return new Map(items.map((item) => [primaryKeyObj.forItem(item), item]));
        },
    };
}
exports.declareSchema = declareSchema;
/**
 * Generates a mapper that, given a primary key definition is able to produce the primary key for that item.
 **/
class FormattedPrimaryKey {
    constructor(...elements) {
        this.elements = [...elements].sort();
    }
    /**
     * Generate the serialized form of the item's primary key.
     *
     * For single value primary keys, the encoded values are just the json representation of the primary
     * key. For example, if the primary key is ['id'] the following table shows encodings:
     *
     * | type    | value     | encoded                            |
     * |---------|-----------|------------------------------------|
     * | number  | `15`      | `new Map([["15", ...], ...])`      |
     * | boolean | `false`   | `new Map([["false", ...], ...])`   |
     * | string  | `"hello"` | `new Map([['"hello"', ...], ...])` |
     *
     * Take note of the extra quotes in the string case.
     *
     * For primary keys with multiple values, first sort the array of primary keys then join the json encoded values
     * from of the keys with commas. For example:
     *
     * ```
     * primary key = ["lastName", "firstName"]
     * sorted key = ["firstName", "lastName"]
     * row = {"lastName": "Smith", "firstName": "John", "age": 42}
     * row key = '"John","Smith"'
     * items = new Map([['"John","Smith"', {"lastName": "Smith", "firstName": "John", "age": 42}]])
     * ```
     */
    forItem(item) {
        return FormattedPrimaryKey.serializeList(this.elements.map((field) => item[field]));
    }
    static serializeList(items) {
        let pk = JSON.stringify(items);
        pk = pk.substring(1, pk.length - 1);
        return pk;
    }
}
exports.FormattedPrimaryKey = FormattedPrimaryKey;
