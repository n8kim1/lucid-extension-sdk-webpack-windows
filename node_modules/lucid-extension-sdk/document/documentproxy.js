"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentProxy = void 0;
const cardconfigproxy_1 = require("./documentelement/cardconfigproxy");
const documentelementtype_1 = require("./documentelement/documentelementtype");
const ruleproxy_1 = require("./documentelement/ruleproxy");
const elementproxy_1 = require("./elementproxy");
const itemproxy_1 = require("./itemproxy");
const mapproxy_1 = require("./mapproxy");
const pageproxy_1 = require("./pageproxy");
/**
 * The currently-open Lucid document
 */
class DocumentProxy extends elementproxy_1.ElementProxy {
    static getNextHookName() {
        return '__documentproxy__hook' + DocumentProxy.nextHookId++;
    }
    constructor(client) {
        super(client.sendCommand("gdid" /* CommandName.GetDocumentId */, undefined), client);
        /**
         * The set of pages on this document, organized by ID
         */
        this.pages = new mapproxy_1.MapProxy(() => this.client.sendCommand("lp" /* CommandName.ListPages */, undefined), (pageId) => new pageproxy_1.PageProxy(pageId, this.client));
        this.cardIntegrationConfigs = new mapproxy_1.MapProxy(() => this.client.sendCommand("lde" /* CommandName.ListDocumentElements */, { 't': documentelementtype_1.DocumentElementType.TaskCardFieldsConfig }), (id) => new cardconfigproxy_1.CardConfigProxy(id, this.client));
        this.rules = new mapproxy_1.MapProxy(() => this.client
            .sendCommand("lde" /* CommandName.ListDocumentElements */, { 't': documentelementtype_1.DocumentElementType.Rule })
            //Filter down to only the rules with source User (i.e. ones visible in the UI, not ones created internally by the app)
            .filter((id) => this.client.sendCommand("gp" /* CommandName.GetProperty */, { 'id': id, 'p': 'SourceType' }) === 0), (id) => new ruleproxy_1.RuleProxy(id, this.client));
    }
    /**
     * An iterator over all blocks on all pages of the document
     */
    *allBlocks() {
        for (const page of this.pages.values()) {
            for (const block of page.blocks.values()) {
                yield block;
            }
        }
    }
    /**
     * An iterator over all lines on all pages of the document
     */
    *allLines() {
        for (const page of this.pages.values()) {
            for (const line of page.lines.values()) {
                yield line;
            }
        }
    }
    /**
     * Add a new page to the current document
     * @param def Definition of the page to add
     * @returns The created page
     */
    addPage(def) {
        const id = this.client.sendCommand("cp" /* CommandName.CreatePage */, undefined);
        const page = new pageproxy_1.PageProxy(id, this.client);
        page.setTitle(def.title);
        return page;
    }
    /**
     * Updates the title of this document
     * @param title The new title for this document
     */
    setTitle(title) {
        this.properties.set('Title', title);
    }
    /**
     * @returns The title of this document
     */
    getTitle() {
        return this.properties.get('Title');
    }
    /** @ignore */
    getDocumentChunks(types) {
        const chunks = this.client.sendCommand("gdc" /* CommandName.GetDocumentChunks */, { 't': types });
        return chunks.map((chunk) => {
            return {
                boundingBox: chunk['bb'],
                items: chunk['i']
                    .map((id) => this.client.getElementProxy(id))
                    .filter((element) => element instanceof itemproxy_1.ItemProxy),
                text: chunk['t'],
                description: chunk['d'],
            };
        });
    }
    /**
     * Infrequently, you may need to watch for *any* changes to the document. These changes may be
     * the local user adding content, or a data integration sending updated records to a data collection,
     * or a remote user hitting undo, or any user entering or exiting an intra-document mutex.
     *
     * Because these changes may happen rapidly, the callback you provide here will only be called on
     * a heavily-debounced schedule. The callback will happen between 1-10 seconds after changes are
     * made to the document, depending on the frequency with which changes are happening.
     * @param callback
     * @returns A handle that can be passed into `unhookAllChanges`
     */
    hookAllChanges(callback) {
        const actionName = DocumentProxy.getNextHookName();
        this.client.registerAction(actionName, () => {
            callback();
        });
        this.client.sendCommand("hac" /* CommandName.HookAllChanges */, { 'n': actionName });
        return actionName;
    }
    /**
     * @param handle Return value from `hookAllChanges`
     */
    unhookAllChanges(handle) {
        this.client.deleteAction(handle);
        this.client.sendCommand("uac" /* CommandName.UnhookAllChanges */, { 'n': handle });
    }
    /**
     * Watch for new blocks, lines, or groups added to this document. The callback will
     * be called with new items created by the current user, but will not be called with items
     * created
     *
     *  - As part of a generated diagram, e.g. org chart
     *  - By another user on the same document
     *
     * @param callback
     * @returns A handle that can be passed to `unhookCreateItems`
     */
    hookCreateItems(callback) {
        const actionName = DocumentProxy.getNextHookName();
        this.client.registerAction(actionName, (msg) => {
            callback(msg['ids'].map((id) => this.client.getItemProxy(id)));
        });
        this.client.sendCommand("hci" /* CommandName.HookCreateItems */, { 'n': actionName });
        return actionName;
    }
    /**
     * @param handle Return value from `hookCreateItems`
     */
    unhookCreateItems(handle) {
        this.client.deleteAction(handle);
        this.client.sendCommand("uci" /* CommandName.UnhookCreateItems */, { 'n': handle });
    }
    addRule(definition) {
        let maxOrder = 0;
        for (const rule of this.rules.values()) {
            maxOrder = Math.max(maxOrder, rule.getOrder());
        }
        const id = this.client.sendCommand("cde" /* CommandName.CreateDocumentElement */, {
            't': documentelementtype_1.DocumentElementType.Rule,
            'p': Object.assign(Object.assign({}, ruleproxy_1.RuleProxy.getRuleProperties(definition)), { 'Order': maxOrder + 1 }),
        });
        if (id === undefined) {
            return undefined;
        }
        return new ruleproxy_1.RuleProxy(id, this.client);
    }
    /**
     * Watch for new blocks, lines, or groups deleted from this document. The callback will
     * be called with items deleted by the current user, but will not be called with items
     * deleted
     *
     *  - As part of a generated diagram, e.g. org chart
     *  - By another user on the same document
     *
     * @param callback
     * @returns A handle that can be passed to `unhookDeleteItems`
     */
    hookDeleteItems(callback) {
        const actionName = DocumentProxy.getNextHookName();
        this.client.registerAction(actionName, (msg) => {
            callback(msg['ids']);
        });
        this.client.sendCommand("hdi" /* CommandName.HookDeleteItems */, { 'n': actionName });
        return actionName;
    }
    /**
     * @param handle Return value from `hookDeleteItems`
     */
    unhookDeleteItems(handle) {
        this.client.deleteAction(handle);
        this.client.sendCommand("udi" /* CommandName.UnhookDeleteItems */, { 'n': handle });
    }
    async duplicateItems(ids) {
        return await this.client.sendCommand("dis" /* CommandName.DuplicateItems */, { 'ids': ids });
    }
}
exports.DocumentProxy = DocumentProxy;
DocumentProxy.nextHookId = 0;
