import { ZOrderOperation } from '../commandtypes';
import { LinearOffsetType } from '../core/offsettype';
import { EditorClient } from '../editorclient';
import { Box, Point } from '../math';
import { RuleProxy } from './documentelement/ruleproxy';
import { ElementProxy } from './elementproxy';
import { WriteableMapProxy } from './mapproxy';
import { TextStyle } from './text/textstyle';
/**
 * A block, line, or group on a page of the current document.
 */
export declare class ItemProxy extends ElementProxy {
    readonly id: string;
    /**
     * @param id ID of this item
     * @param client
     */
    constructor(id: string, client: EditorClient);
    /**
     * The plain text in each of the text areas on this item, organized by text area name.
     */
    readonly textAreas: WriteableMapProxy<string, string, undefined, string>;
    /**
     * The text style in each of the text areas on this item, organized by text area name.
     */
    readonly textStyles: WriteableMapProxy<string, TextStyle, Promise<undefined>, Partial<TextStyle>>;
    /**
     * @returns The bounding box of this item relative to its containing page. As pages may change size
     * to fit the content on them, note that these coordinates may be negative or very large.
     *
     * If this is a rotated block, the bounding box returned here is where the block would be if it were
     * unrotated.
     */
    getBoundingBox(): Box;
    /**
     * Attempts to move and resize this item to fit into the given bounding box. If this item (or another
     * item it contains) has size or aspect ratio restrictions, it may not be possible to fit the requested
     * location exactly.
     *
     * This is done by moving this item to the requested location, then attempting to resize it from the
     * bottom-right corner to the requested size.
     *
     * @param bb The bounding box to attempt to make this item fill
     */
    setBoundingBox(bb: Box): void;
    /**
     * @returns The ID of the page containing this item
     */
    getPageId(): string;
    /**
     * @returns The page containing this item
     */
    getPage(): import("./pageproxy").PageProxy;
    /**
     * @returns The x/y location of this item
     */
    getLocation(): {
        x: number;
        y: number;
    };
    /**
     * Moves this item so that its upper-left corner is positioned at the given location (prior to any rotation)
     * @param location The target location
     */
    setLocation(location: Point): void;
    /**
     * Offset this item in the given direction by the given amount.
     * @param type The type of offset to apply to this item
     * @param offset The amount to offset
     */
    offset(type: LinearOffsetType, offset: Point): void;
    /**
     * Measure the amount of space necessary to render the text in the given text area, given a
     * width to measure that text within.
     * @param name Name of the text area whose content we should measure
     * @param maxWidth Width of the area in which to measure this text. The result will usually be no wider than this, but if a single word is long enough to go beyond this maxWidth, the width of that word will be returned.
     * @returns The size of rectangle necessary to render this text area's content.
     */
    measureText(name: string, maxWidth: number): import("../commandtypes").MeasureTextResult;
    /**
     * Delete this item from the document
     */
    delete(): void;
    /**
     * @returns An array of blocks whose bounding boxes contain this item's upper-left corner
     */
    getContainers(): import("./blockproxy").BlockProxy[];
    /**
     * @param operation How to adjust the Z order of this item relative to the other items it overlaps on the page
     */
    changeZOrder(operation: ZOrderOperation): void;
    /**
     * @param rule Rule to apply to this item
     */
    applyRule(rule: RuleProxy): void;
    /**
     * @param rule Rule to remove from this item
     */
    unapplyRule(rule: RuleProxy): void;
}
