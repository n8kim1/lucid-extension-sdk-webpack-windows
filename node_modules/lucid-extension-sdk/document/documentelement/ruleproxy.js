"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuleProxy = exports.RuleEffect = exports.RuleCondition = void 0;
const badgeposition_1 = require("../../core/properties/datagraphic/badgeposition");
const mapproxy_1 = require("../mapproxy");
const ruledefinition_1 = require("../ruledefinition");
const documentelementproxy_1 = require("./documentelementproxy");
class RuleCondition {
    constructor(rule, client, key) {
        this.rule = rule;
        this.client = client;
        this.key = key;
        this.definition = this.rule.properties.get(this.key);
        /** What kind of condition is this? e.g. a formula evaluation, checking for non-empty text, etc. */
        this.type = this.definition['Type'];
        /**
         * If this.type == ConditionType.Text, this is a TextConditions.
         * If this.type == ConditionType.ShapeData, this is a ShapeDataConditions.
         * If this.type == ConditionType.ShapeType, this is a ShapeTypeConditions.
         * If this.type == ConditionType.ConnectedShapes, this is a ConnectedShapesConditions.
         */
        this.condition = this.definition['Condition'];
        /**
         * For formula conditions, the formula string.
         *
         * For other conditions,the value against which the condition is tested. For example, a condition with
         *  type = ConditionType.ShapeData
         *  condition = ShapeDataConditions.GreaterThan
         *  field = 'TheField'
         *  value = 14
         *
         * will trigger when the shape data field "TheField" has a value that is greater than 14.
         */
        this.value = this.definition['Value'];
        /** For shape data conditions, the name of the shape data field to test */
        this.field = this.definition['Label'];
        /** For shape data conditions, the name to display to the end user to identify the field name */
        this.fieldLabel = this.definition['DisplayLabel'];
    }
    /** Update this condition to reflect a new definition */
    update(definition) {
        this.rule.properties.set(this.key, (0, ruledefinition_1.serializeConditionDefinition)(definition));
        this.definition = this.rule.properties.get(this.key);
    }
}
exports.RuleCondition = RuleCondition;
class RuleEffect {
    constructor(rule, client, key) {
        this.rule = rule;
        this.client = client;
        this.key = key;
        this.definition = this.rule.properties.get(this.key);
        this.conditions = new mapproxy_1.MapProxy(() => this.definition['ConditionOrder'].map((order) => 'Condition_' + order), (key) => new RuleCondition(this.rule, this.client, key));
        /** How multiple conditions are combined (AND vs OR) */
        this.combination = this.definition['Combination'];
        /** What kind of effect is displayed? Formatting vs. icons vs. dynamic stencil, etc. */
        this.formatType = this.definition['FormatType'];
        /** For formatType = RuleFormattingType.FORMATTING, what styles are applied to blocks, lines, and pages? */
        this.formatting = this.definition['Formatting'];
        /** For formatType = RuleFormattingType.DATA_GRAPHICS, a description of which icon appears and where */
        this.dataGraphic = this.definition['DataGraphic'] && {
            set: this.definition['DataGraphic']['Set'],
            index: this.definition['DataGraphic']['Index'],
            position: (0, badgeposition_1.deserializeBadgeEnumPosition)(this.definition['DataGraphic']['Position']),
            color: this.definition['DataGraphic']['Color'],
            image: this.definition['DataGraphic']['Image'] && {
                url: this.definition['DataGraphic']['Image']['url'],
                w: this.definition['DataGraphic']['Image']['w'],
                h: this.definition['DataGraphic']['Image']['h'],
            },
        };
    }
    /** Update this effect to reflect a new definition */
    update(definition) {
        //Find the maximum used condition index in the entire rule, in case we need to add more.
        let nextConditionIndex = 1;
        for (const effect of this.rule.effects.values()) {
            nextConditionIndex = Math.max(nextConditionIndex, ...effect.definition.ConditionOrder.map((index) => index + 1));
        }
        const conditionIndexes = this.definition.ConditionOrder;
        definition.conditions.forEach((condition, index) => {
            let conditionIndex = conditionIndexes[index];
            if (conditionIndex === undefined) {
                //Added a new condition
                conditionIndex = nextConditionIndex;
                conditionIndexes.push(nextConditionIndex++);
            }
            const conditionKey = 'Condition_' + conditionIndex;
            this.rule.properties.set(conditionKey, (0, ruledefinition_1.serializeConditionDefinition)(condition));
        });
        this.rule.properties.set(this.key, (0, ruledefinition_1.serializeEffectDefinition)(definition, conditionIndexes.slice(0, definition.conditions.length)));
    }
}
exports.RuleEffect = RuleEffect;
class RuleProxy extends documentelementproxy_1.DocumentElementProxy {
    /**
     * @param id The ID of this conditional formatting rule
     * @param client
     */
    constructor(id, client) {
        super(id, client);
        this.id = id;
        this.effects = new mapproxy_1.MapProxy(() => this.properties.get('EffectOrder').map((order) => 'Effect_' + order), (key) => new RuleEffect(this, this.client, key));
    }
    getName() {
        return this.properties.get('Name');
    }
    setName(name) {
        this.properties.set('Name', name);
    }
    getOrder() {
        return this.properties.get('Order');
    }
    /**
     * Delete this conditional formatting rule from the document
     */
    delete() {
        this.client.sendCommand("dde" /* CommandName.DeleteDocumentElement */, this.id);
    }
    /** @ignore */
    static getRuleProperties(definition) {
        const properties = {
            'EffectOrder': definition.effects.map((effect, index) => index + 1),
            'SourceType': 0,
            'Name': definition.name,
        };
        let nextConditionIndex = 1;
        let nextEffectIndex = 1;
        for (const effect of definition.effects) {
            const effectKey = 'Effect_' + nextEffectIndex++;
            const conditionOrder = [];
            for (const condition of effect.conditions) {
                conditionOrder.push(nextConditionIndex);
                const conditionKey = 'Condition_' + nextConditionIndex++;
                properties[conditionKey] = (0, ruledefinition_1.serializeConditionDefinition)(condition);
            }
            properties[effectKey] = (0, ruledefinition_1.serializeEffectDefinition)(effect, conditionOrder);
        }
        return properties;
    }
    /** Update this rule to reflect a new definition */
    update(definition) {
        const properties = RuleProxy.getRuleProperties(definition);
        for (const key in properties) {
            this.properties.set(key, properties[key]);
        }
    }
}
exports.RuleProxy = RuleProxy;
