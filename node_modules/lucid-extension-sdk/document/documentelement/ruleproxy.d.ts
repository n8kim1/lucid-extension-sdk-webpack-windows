import { JsonSerializable } from '../../core/jsonserializable';
import { EditorClient } from '../../editorclient';
import { MapProxy } from '../mapproxy';
import { ConditionDefinition, EffectDefinition, RuleDefinition } from '../ruledefinition';
import { DocumentElementProxy } from './documentelementproxy';
export declare class RuleCondition {
    readonly rule: RuleProxy;
    private readonly client;
    readonly key: string;
    private definition;
    constructor(rule: RuleProxy, client: EditorClient, key: string);
    /** What kind of condition is this? e.g. a formula evaluation, checking for non-empty text, etc. */
    readonly type: import("../..").ConditionType;
    /**
     * If this.type == ConditionType.Text, this is a TextConditions.
     * If this.type == ConditionType.ShapeData, this is a ShapeDataConditions.
     * If this.type == ConditionType.ShapeType, this is a ShapeTypeConditions.
     * If this.type == ConditionType.ConnectedShapes, this is a ConnectedShapesConditions.
     */
    readonly condition: import("../..").Conditions;
    /**
     * For formula conditions, the formula string.
     *
     * For other conditions,the value against which the condition is tested. For example, a condition with
     *  type = ConditionType.ShapeData
     *  condition = ShapeDataConditions.GreaterThan
     *  field = 'TheField'
     *  value = 14
     *
     * will trigger when the shape data field "TheField" has a value that is greater than 14.
     */
    readonly value: import("../../core/rules/serializedcondition").ConditionValueType;
    /** For shape data conditions, the name of the shape data field to test */
    readonly field: string | undefined;
    /** For shape data conditions, the name to display to the end user to identify the field name */
    readonly fieldLabel: string | undefined;
    /** Update this condition to reflect a new definition */
    update(definition: ConditionDefinition): void;
}
export declare class RuleEffect {
    readonly rule: RuleProxy;
    private readonly client;
    readonly key: string;
    private definition;
    constructor(rule: RuleProxy, client: EditorClient, key: string);
    readonly conditions: MapProxy<string, RuleCondition>;
    /** How multiple conditions are combined (AND vs OR) */
    readonly combination: import("../..").ConditionCombination;
    /** What kind of effect is displayed? Formatting vs. icons vs. dynamic stencil, etc. */
    readonly formatType: import("../../core/rules/serializedeffect").RuleFormattingType;
    /** For formatType = RuleFormattingType.FORMATTING, what styles are applied to blocks, lines, and pages? */
    readonly formatting: import("../../core/rules/serializedeffect").SerializedFormatting;
    /** For formatType = RuleFormattingType.DATA_GRAPHICS, a description of which icon appears and where */
    readonly dataGraphic: {
        set: import("../..").DataGraphicIconSets;
        index: number;
        position: import("../../core/properties/datagraphic/badgeposition").BadgeEnumPosition;
        color: string | undefined;
        image: {
            url: string;
            w: number;
            h: number;
        } | undefined;
    } | undefined;
    /** Update this effect to reflect a new definition */
    update(definition: EffectDefinition): void;
}
export declare class RuleProxy extends DocumentElementProxy {
    readonly id: string;
    /**
     * @param id The ID of this conditional formatting rule
     * @param client
     */
    constructor(id: string, client: EditorClient);
    getName(): string;
    setName(name: string): void;
    getOrder(): number;
    readonly effects: MapProxy<string, RuleEffect>;
    /**
     * Delete this conditional formatting rule from the document
     */
    delete(): void;
    /** @ignore */
    static getRuleProperties(definition: RuleDefinition): Record<string, JsonSerializable>;
    /** Update this rule to reflect a new definition */
    update(definition: RuleDefinition): void;
}
