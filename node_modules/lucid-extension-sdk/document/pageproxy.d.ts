import { GetItemsAtSearchType, GetLLMContextType, MermaidDiagramType } from '../commandtypes';
import { EditorClient } from '../editorclient';
import { Box, Point } from '../math';
import { BlockDefinition } from './blockdefinition';
import { BlockProxy } from './blockproxy';
import { RuleProxy } from './documentelement/ruleproxy';
import { ElementProxy } from './elementproxy';
import { GroupProxy } from './groupproxy';
import { ImageDefinition } from './imagedefinition';
import { ItemProxy } from './itemproxy';
import { LineDefinition } from './linedefinition';
import { LineProxy } from './lineproxy';
import { MapProxy } from './mapproxy';
/**
 * One page in the current Lucid document
 */
export declare class PageProxy extends ElementProxy {
    readonly id: string;
    /**
     * @param id The ID of this page
     * @param client
     */
    constructor(id: string, client: EditorClient);
    /**
     * @returns All conditional formatting rules that are applied to every item on this page
     */
    getRulesAppliedToAllItems(): RuleProxy[];
    /**
     * @param rule Rule to apply to all items on this page
     */
    applyRuleToAllItems(rule: RuleProxy): void;
    /**
     * @param rule Rule to remove from the list applied to all items on this page
     */
    unapplyRuleToAllItems(rule: RuleProxy): void;
    /**
     * Find available space on this page for adding new content.
     * @param searchX Place to start the search
     * @param searchY Place to start the search
     * @param width
     * @param height
     * @returns a reference to the page and origin (upper-left point) of the space you can add new
     * content of the given size to.
     */
    findAvailableSpace(searchX: number, searchY: number, width: number, height: number): {
        page: PageProxy;
        x: number;
        y: number;
    };
    /**
     * The blocks contained directly on this page, not including ones inside groups
     */
    readonly blocks: MapProxy<string, BlockProxy>;
    /**
     * The lines contained directly on this page, not including ones inside groups
     */
    readonly lines: MapProxy<string, LineProxy>;
    /**
     * The groups contained directly on this page, not including ones inside groups
     */
    readonly groups: MapProxy<string, GroupProxy>;
    /**
     * The blocks contained on this page, including ones inside groups
     */
    readonly allBlocks: MapProxy<string, BlockProxy>;
    /**
     * The lines contained on this page, including ones inside groups
     */
    readonly allLines: MapProxy<string, LineProxy>;
    /**
     * The groups contained on this page, including ones inside groups
     */
    readonly allGroups: MapProxy<string, GroupProxy>;
    /**
     * All blocks, lines, and groups on the page, including ones inside groups
     */
    readonly allItems: MapProxy<string, BlockProxy | LineProxy | GroupProxy>;
    /**
     * Add a new block to this page.
     *
     * IMPORTANT: Because code for block classes are loaded incrementally, you MUST call
     * EditorClient.loadBlockClasses with the given block class name (and wait for it to
     * resolve) before attempting to create a block. If you don't, an error will be thrown.
     *
     * @param def The definition of the new block to add
     * @returns The added block
     */
    addBlock(def: BlockDefinition): BlockProxy;
    /**
     * Creates a new group from a list of items.
     *
     * @param blocks A non-empty array of items to group
     * @returns The added group
     */
    groupBlocks(blocks: BlockProxy[]): GroupProxy;
    /**
     * Add a new line to this page.
     * @param def The definition of the new line to add
     * @returns The added line
     */
    addLine(def: LineDefinition): LineProxy;
    /**
     * Add a new image to this page.
     * @param def The definition of the new image to add
     * @returns The added image
     */
    addImage(def: ImageDefinition): Promise<BlockProxy>;
    /**
     * Add a diagram described by Mermaid markup to this page.
     *
     * See https://mermaid.js.org/intro/syntax-reference.html for information on Mermaid markup syntax.
     *
     * @param diagramType The type of the diagram. Note that this is redundant because the Mermaid markup also contains
     *                         the diagram type.
     * @param mermaid Mermaid markup text describing the diagram to add.
     * @param origin Where to place the diagram on the page. If absent some free
     *                  space within or near the current viewport is automatically chosen.
     * @param exactPlacement If true and if origin is specified, places the diagram exactly at the specified origin
     *                          instead of trying to find free space.
     * @returns An array of the proxies for all the objects in the added diagram.
     */
    addDiagramFromMermaid(diagramType: MermaidDiagramType, mermaid: string, origin?: Point, exactPlacement?: boolean): Promise<(BlockProxy | LineProxy | GroupProxy)[]>;
    /**
     * Updates the page of this page
     * @param title The new title for this page
     */
    setTitle(title: string): void;
    /**
     * @returns the title of this page
     */
    getTitle(): string;
    /**
     * Delete this page from the document if possible
     */
    delete(): void;
    /**
     *
     * @param boundingBox An area of this page to search for blocks, lines, and groups
     * @param searchType
     * @returns Items in the given bounding box, based on the search type
     */
    findItems(boundingBox: Box, searchType: GetItemsAtSearchType): (BlockProxy | LineProxy | GroupProxy)[];
    /**
     * Import links onto this page as link unfurl blocks
     *
     * NOTE: links will be unfurled by Lucid based on extensions installed by user
     *
     * @param links links to be imported onto the canvas as link unfurl blocks
     */
    importLinks(links: string[]): Promise<void>;
    /**
     * @param items
     * @returns A string representing the content of the items provided, including immediate surrounding context if
     * necessary, in a format that is easily understandable by LLMs like ChatGPT. Also a map of IDs, from the shortened
     * IDs provided for the items in the context to the actual Lucid item IDs.
     */
    getLLMContextForItems(items: ItemProxy[], contextType?: GetLLMContextType): {
        prompt: string;
        idToLucidId: Map<string, string>;
    };
    /**
     *
     * @param items If specified, only include these items in the resulting SVG
     * @param includeBackground If true, include the background of the page in the SVG. Otherwise the background is transparent.
     * @param viewBox If specified, crop the resulting SVG to the specified bounding box in page coordinates
     * @returns A promise resolving to an SVG string
     */
    getSvg(items?: ItemProxy[], includeBackground?: boolean, viewBox?: Box): import("../commandtypes").GetSvgResult;
    /**
     * @returns the page number of this page
     */
    getPageNumber(): number;
    /**
     * Duplicates the page represented by the page proxy
     */
    duplicate(): Promise<void>;
}
