"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PageProxy = void 0;
const commandtypes_1 = require("../commandtypes");
const ruleproxy_1 = require("./documentelement/ruleproxy");
const elementproxy_1 = require("./elementproxy");
const groupproxy_1 = require("./groupproxy");
const imagedefinition_1 = require("./imagedefinition");
const lineproxy_1 = require("./lineproxy");
const mapproxy_1 = require("./mapproxy");
/**
 * One page in the current Lucid document
 */
class PageProxy extends elementproxy_1.ElementProxy {
    /**
     * @param id The ID of this page
     * @param client
     */
    constructor(id, client) {
        super(id, client);
        this.id = id;
        /**
         * The blocks contained directly on this page, not including ones inside groups
         */
        this.blocks = new mapproxy_1.MapProxy(() => this.client.sendCommand("lb" /* CommandName.ListBlocks */, { id: this.id }), (id) => this.client.getBlockProxy(id));
        /**
         * The lines contained directly on this page, not including ones inside groups
         */
        this.lines = new mapproxy_1.MapProxy(() => this.client.sendCommand("ll" /* CommandName.ListLines */, { id: this.id }), (id) => new lineproxy_1.LineProxy(id, this.client));
        /**
         * The groups contained directly on this page, not including ones inside groups
         */
        this.groups = new mapproxy_1.MapProxy(() => this.client.sendCommand("lg" /* CommandName.ListGroups */, { id: this.id }), (id) => new groupproxy_1.GroupProxy(id, this.client));
        /**
         * The blocks contained on this page, including ones inside groups
         */
        this.allBlocks = new mapproxy_1.MapProxy(() => this.client.sendCommand("lb" /* CommandName.ListBlocks */, { id: this.id, d: true }), (id) => this.client.getBlockProxy(id));
        /**
         * The lines contained on this page, including ones inside groups
         */
        this.allLines = new mapproxy_1.MapProxy(() => this.client.sendCommand("ll" /* CommandName.ListLines */, { id: this.id, d: true }), (id) => new lineproxy_1.LineProxy(id, this.client));
        /**
         * The groups contained on this page, including ones inside groups
         */
        this.allGroups = new mapproxy_1.MapProxy(() => this.client.sendCommand("lg" /* CommandName.ListGroups */, { id: this.id, d: true }), (id) => new groupproxy_1.GroupProxy(id, this.client));
        /**
         * All blocks, lines, and groups on the page, including ones inside groups
         */
        this.allItems = new mapproxy_1.MapProxy(() => [...this.allBlocks.keys(), ...this.allLines.keys(), ...this.allGroups.keys()], (id) => this.client.getItemProxy(id));
    }
    /**
     * @returns All conditional formatting rules that are applied to every item on this page
     */
    getRulesAppliedToAllItems() {
        const ids = this.properties.get('ChildRuleList');
        return ids.map((id) => new ruleproxy_1.RuleProxy(id, this.client));
    }
    /**
     * @param rule Rule to apply to all items on this page
     */
    applyRuleToAllItems(rule) {
        const ids = this.properties.get('ChildRuleList');
        if (!ids.includes(rule.id)) {
            ids.push(rule.id);
            this.properties.set('ChildRuleList', ids);
        }
    }
    /**
     * @param rule Rule to remove from the list applied to all items on this page
     */
    unapplyRuleToAllItems(rule) {
        const ids = this.properties.get('ChildRuleList');
        if (ids.includes(rule.id)) {
            this.properties.set('ChildRuleList', ids.filter((id) => id !== rule.id));
        }
    }
    /**
     * Find available space on this page for adding new content.
     * @param searchX Place to start the search
     * @param searchY Place to start the search
     * @param width
     * @param height
     * @returns a reference to the page and origin (upper-left point) of the space you can add new
     * content of the given size to.
     */
    findAvailableSpace(searchX, searchY, width, height) {
        const result = this.client.sendCommand("fas" /* CommandName.FindAvailableSpace */, {
            'p': this.id,
            'x': searchX,
            'y': searchY,
            'w': width,
            'h': height,
        });
        return {
            page: this,
            x: result['x'],
            y: result['y'],
        };
    }
    /**
     * Add a new block to this page.
     *
     * IMPORTANT: Because code for block classes are loaded incrementally, you MUST call
     * EditorClient.loadBlockClasses with the given block class name (and wait for it to
     * resolve) before attempting to create a block. If you don't, an error will be thrown.
     *
     * @param def The definition of the new block to add
     * @returns The added block
     */
    addBlock(def) {
        const id = this.client.sendCommand("cb" /* CommandName.CreateBlock */, {
            'p': this.id,
            'c': def.className,
            's': def.stencil,
        });
        const block = this.client.getBlockProxy(id);
        block.setBoundingBox(def.boundingBox);
        if (def.properties) {
            for (const key in def.properties) {
                block.properties.set(key, def.properties[key]);
            }
        }
        if (def.fillStyle !== undefined) {
            block.setFillStyle(def.fillStyle);
        }
        if (def.lineWidth !== undefined) {
            block.setLineWidth(def.lineWidth);
        }
        return block;
    }
    /**
     * Creates a new group from a list of items.
     *
     * @param blocks A non-empty array of items to group
     * @returns The added group
     */
    groupBlocks(blocks) {
        const id = this.client.sendCommand("cg" /* CommandName.CreateGroup */, {
            'p': this.id,
            'i': blocks.map((block) => block.id),
        });
        return new groupproxy_1.GroupProxy(id, this.client);
    }
    /**
     * Add a new line to this page.
     * @param def The definition of the new line to add
     * @returns The added line
     */
    addLine(def) {
        const id = this.client.sendCommand("cl" /* CommandName.CreateLine */, {
            'p': this.id,
        });
        const line = new lineproxy_1.LineProxy(id, this.client);
        line.setEndpoint1(def.endpoint1);
        line.setEndpoint2(def.endpoint2);
        return line;
    }
    /**
     * Add a new image to this page.
     * @param def The definition of the new image to add
     * @returns The added image
     */
    async addImage(def) {
        await this.client.loadBlockClasses(['UserImage2Block']);
        return this.addBlock((0, imagedefinition_1.imageToBlockDefinition)(def));
    }
    /**
     * Add a diagram described by Mermaid markup to this page.
     *
     * See https://mermaid.js.org/intro/syntax-reference.html for information on Mermaid markup syntax.
     *
     * @param diagramType The type of the diagram. Note that this is redundant because the Mermaid markup also contains
     *                         the diagram type.
     * @param mermaid Mermaid markup text describing the diagram to add.
     * @param origin Where to place the diagram on the page. If absent some free
     *                  space within or near the current viewport is automatically chosen.
     * @param exactPlacement If true and if origin is specified, places the diagram exactly at the specified origin
     *                          instead of trying to find free space.
     * @returns An array of the proxies for all the objects in the added diagram.
     */
    async addDiagramFromMermaid(diagramType, mermaid, origin, exactPlacement) {
        return (await this.client.sendCommand("adfm" /* CommandName.AddDiagramFromMermaid */, {
            't': diagramType,
            'm': mermaid,
            'o': origin,
            'e': exactPlacement,
        })).map((id) => this.client.getItemProxy(id));
    }
    /**
     * Updates the page of this page
     * @param title The new title for this page
     */
    setTitle(title) {
        this.properties.set('Title', title);
    }
    /**
     * @returns the title of this page
     */
    getTitle() {
        return this.properties.get('Title');
    }
    /**
     * Delete this page from the document if possible
     */
    delete() {
        this.client.sendCommand("dp" /* CommandName.DeletePage */, this.id);
    }
    /**
     *
     * @param boundingBox An area of this page to search for blocks, lines, and groups
     * @param searchType
     * @returns Items in the given bounding box, based on the search type
     */
    findItems(boundingBox, searchType) {
        return this.client
            .sendCommand("gia" /* CommandName.GetItemsAt */, { 'p': this.id, 'bb': boundingBox, 's': searchType })
            .map((id) => this.client.getItemProxy(id));
    }
    /**
     * Import links onto this page as link unfurl blocks
     *
     * NOTE: links will be unfurled by Lucid based on extensions installed by user
     *
     * @param links links to be imported onto the canvas as link unfurl blocks
     */
    async importLinks(links) {
        return await this.client.sendCommand("il" /* CommandName.ImportLinks */, { 'p': this.id, 'l': links });
    }
    /**
     * @param items
     * @returns A string representing the content of the items provided, including immediate surrounding context if
     * necessary, in a format that is easily understandable by LLMs like ChatGPT. Also a map of IDs, from the shortened
     * IDs provided for the items in the context to the actual Lucid item IDs.
     */
    getLLMContextForItems(items, contextType = commandtypes_1.GetLLMContextType.Relational) {
        //We don't check that the items are on this page here; that is done in the implementation
        //of the API command. It would be a lot of extra API calls for no benefit.
        const result = this.client.sendCommand("llm" /* CommandName.GetLLMContextFromItems */, {
            'p': this.id,
            'i': items.map((item) => item.id),
            't': contextType,
        });
        return {
            prompt: result['p'],
            idToLucidId: new Map(Object.entries(result['id'])),
        };
    }
    /**
     *
     * @param items If specified, only include these items in the resulting SVG
     * @param includeBackground If true, include the background of the page in the SVG. Otherwise the background is transparent.
     * @param viewBox If specified, crop the resulting SVG to the specified bounding box in page coordinates
     * @returns A promise resolving to an SVG string
     */
    getSvg(items, includeBackground = false, viewBox) {
        return this.client.sendCommand("gsvg" /* CommandName.GetSvg */, {
            'p': this.id,
            'bb': viewBox,
            'bg': includeBackground,
            'i': items === null || items === void 0 ? void 0 : items.map((item) => item.id),
        });
    }
    /**
     * @returns the page number of this page
     */
    getPageNumber() {
        return this.properties.get('Order');
    }
    /**
     * Duplicates the page represented by the page proxy
     */
    async duplicate() {
        await this.client.duplicatePages([this.getPageNumber()]);
    }
}
exports.PageProxy = PageProxy;
