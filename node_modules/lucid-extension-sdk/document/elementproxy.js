"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ElementProxy = void 0;
const referencekeydefinition_1 = require("../data/referencekeydefinition");
const referencekeyproxy_1 = require("../data/referencekeyproxy");
const mapproxy_1 = require("./mapproxy");
const propertystoreproxy_1 = require("./propertystoreproxy");
const shapedataproxy_1 = require("./shapedataproxy");
/**
 * An element is anything on a Lucid document that can have properties and shape data:
 *  * [The document itself](#classes_document_documentproxy-DocumentProxy)
 *  * [Pages](#classes_document_pageproxy-PageProxy)
 *  * [Blocks](#classes_document_blockproxy-BlockProxy)
 *  * [Lines](#classes_document_lineproxy-LineProxy)
 *  * [Groups](#classes_document_groupproxy-GroupProxy)
 */
class ElementProxy extends propertystoreproxy_1.PropertyStoreProxy {
    /**
     * Set a reference key on this element, replacing any existing reference at the specified key.
     *
     * @param key
     * @param settings
     */
    setReferenceKey(key, settings) {
        this.client.sendCommand("srk" /* CommandName.SetReferenceKey */, {
            'id': this.id,
            'k': key,
            'v': (0, referencekeydefinition_1.serializeReferenceKeyDefinition)(settings),
        });
    }
    /**
     * Remove the specified reference key from this element.
     * @param key
     */
    removeReferenceKey(key) {
        this.client.sendCommand("srk" /* CommandName.SetReferenceKey */, { 'id': this.id, 'k': key });
    }
    /**
     *
     * @param id ID of this element
     * @param client
     */
    constructor(id, client) {
        super(id, client);
        /**
         * The shape data set directly on this element (not including any shape data inherited from the page or a containing group).
         */
        this.shapeData = new shapedataproxy_1.ShapeDataProxy(this.id, this.client);
        /**
         * All shape data accessible on this element, including shape data inherited from the page or a containing group.
         * This collection is read-only.
         */
        this.allShapeData = new mapproxy_1.MapProxy(() => this.client.sendCommand("lsd" /* CommandName.ListShapeData */, { 'id': this.id, 'i': true }), (name) => shapedataproxy_1.ShapeDataProxy.parseData(this.client.sendCommand("gsd" /* CommandName.GetShapeData */, {
            'id': this.id,
            'n': name,
        })));
        /**
         * The set of reference keys, organized by their ID, which can be either a string or number.
         *
         * For more information, see the [Developer Guide](/extension-api#guide-reference-keys).
         */
        this.referenceKeys = new mapproxy_1.MapProxy(() => this.client.sendCommand("lrk" /* CommandName.ListReferenceKeys */, { 'id': this.id }), (key) => new referencekeyproxy_1.ReferenceKeyProxy(this.id, key, this.client, this.client.sendCommand("grk" /* CommandName.GetReferenceKey */, { 'id': this.id, 'k': key })));
    }
    /**
     * @returns `true` if this element still exists on the document, or `false` otherwise
     */
    exists() {
        return this.client.sendCommand("ee" /* CommandName.ElementExists */, { 'id': this.id });
    }
    /**
     * Execute a formula in the context of this element
     * @param formula The formula text, e.g. "@a + @b" to add together the shape data values a and b.
     * @returns The result of the formula, or an error.
     */
    executeFormula(formula) {
        return shapedataproxy_1.ShapeDataProxy.parseData(this.client.sendCommand("ef" /* CommandName.ExecuteFormula */, { 'id': this.id || '', 'f': formula }));
    }
}
exports.ElementProxy = ElementProxy;
