"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TableBlockProxy = exports.TableColumnProxy = exports.TableRowProxy = exports.TableCellProxy = void 0;
const fillcolor_1 = require("../../core/properties/fillcolor");
const blockproxy_1 = require("../blockproxy");
class TableCellProxy {
    constructor(table, row, column) {
        this.table = table;
        this.row = row;
        this.column = column;
    }
    getText() {
        return this.table.textAreas.get(`Cell_${this.row},${this.column}`);
    }
    setText(text) {
        return this.table.textAreas.set(`Cell_${this.row},${this.column}`, text);
    }
    getTextStyle() {
        return this.table.textStyles.get(`Cell_${this.row},${this.column}`);
    }
    setTextStyle(style) {
        this.table.textStyles.set(`Cell_${this.row},${this.column}`, style);
    }
    setFill(fill) {
        this.table.properties.set(`CellFill_${this.row},${this.column}`, (0, fillcolor_1.serializeSimpleFill)(fill));
    }
    /**
     * Cells in a table can be merged together with adjacent cells into one larger cell. In this case, the upper-
     * left cell remains visible but is enlarged to cover additional cells, and the other cells are hidden.
     *
     * @returns the size of this cell, in how many cells horizontally and vertically have been merged into it.
     * For most cells, this will be {w:1, h:1}, but if it has been merged with the cell to the right of it, it
     * would be {w:2, h:1}.
     */
    getMergedCellSize() {
        var _a;
        return ((_a = this.table.properties.get(`CellSize_${this.row},${this.column}`)) !== null && _a !== void 0 ? _a : { w: 1, h: 1 });
    }
    /**
    /**
     * Cells in a table can be merged together with adjacent cells into one larger cell. In this case, the upper-
     * left cell remains visible but is enlarged to cover additional cells, and the other cells are hidden.
     *
     * @param size the desired size of this cell, in how many cells horizontally and vertically are merged into it.
     * This normally {w:1, h:1} for a normal cell, or {w:2, h:1} to merge a cell with the one to the right of it, etc.
     */
    setMergedCellSize(size) {
        this.table.properties.set(`CellSize_${this.row},${this.column}`, size);
    }
    /**
     * @returns the pixel width of the cell, including any cells it is merged with.
     */
    getWidth() {
        return this.table
            .getColumnWidths()
            .slice(this.column, this.column + this.getMergedCellSize().w)
            .reduce((a, b) => a + b, 0);
    }
    /**
     * @returns the pixel height of the cell, including any cells it is merged with.
     */
    getHeight() {
        return this.table
            .getRowHeights()
            .slice(this.row, this.row + this.getMergedCellSize().h)
            .reduce((a, b) => a + b, 0);
    }
    getBoundingBox() {
        const tableBB = this.table.getBoundingBox();
        const x = tableBB.x +
            this.table
                .getColumnWidths()
                .slice(0, this.column)
                .reduce((a, b) => a + b, 0);
        const y = tableBB.y +
            this.table
                .getRowHeights()
                .slice(0, this.row)
                .reduce((a, b) => a + b, 0);
        return { x, y, w: this.getWidth(), h: this.getHeight() };
    }
}
exports.TableCellProxy = TableCellProxy;
class TableRowProxy {
    constructor(table, row) {
        this.table = table;
        this.row = row;
    }
    getCells() {
        return this.table.getColumnWidths().map((_, index) => new TableCellProxy(this.table, this.row, index));
    }
    getHeight() {
        var _a;
        return (_a = this.table.getRowHeights()[this.row]) !== null && _a !== void 0 ? _a : 1;
    }
}
exports.TableRowProxy = TableRowProxy;
class TableColumnProxy {
    constructor(table, col) {
        this.table = table;
        this.col = col;
    }
    getCells() {
        return this.table.getRowHeights().map((_, index) => new TableCellProxy(this.table, this.col, index));
    }
    getWidth() {
        var _a;
        return (_a = this.table.getColumnWidths()[this.col]) !== null && _a !== void 0 ? _a : 1;
    }
}
exports.TableColumnProxy = TableColumnProxy;
class TableBlockProxy extends blockproxy_1.BlockProxy {
    /**
     *
     * @param referenceCell The cell to add the new column before or after.
     * @param before If true, the new column will be added before the reference cell, otherwise it will be added after.
     * @returns The TableColumnProxy for the newly added column.
     */
    addColumn(referenceCell, before = false) {
        const col = this.client.sendCommand("atc" /* CommandName.AddTableColumn */, {
            'id': this.id,
            'r': referenceCell.row,
            'c': referenceCell.column,
            'b': before,
        });
        return new TableColumnProxy(this, col);
    }
    /**
     *
     * @param referenceCell The cell to add the new row before or after.
     * @param before If true, the new row will be added before the reference cell, otherwise it will be added after.
     * @returns The TableRowProxy for the newly added row.
     */
    addRow(referenceCell, before = false) {
        const row = this.client.sendCommand("atr" /* CommandName.AddTableRow */, {
            'id': this.id,
            'r': referenceCell.row,
            'c': referenceCell.column,
            'b': before,
        });
        return new TableRowProxy(this, row);
    }
    /**
     * @param column The index of the column to delete.
     */
    deleteColumn(column) {
        return this.client.sendCommand("dtc" /* CommandName.DeleteTableColumn */, { 'id': this.id, 'i': column });
    }
    /**
     * @param row The index of the row to delete.
     */
    deleteRow(row) {
        return this.client.sendCommand("dtr" /* CommandName.DeleteTableRow */, { 'id': this.id, 'i': row });
    }
    /**
     * @param textAreaKey The text area key of a cell in the table
     * @returns The TableCellProxy represented by the text area key, or undefined if the text area key does not exist in the table.
     */
    getCellByTextAreaKey(textAreaKey) {
        const value = textAreaKey.match(/(\d+)/g);
        if (value && value.length === 2) {
            const row = +value[0];
            const column = +value[1];
            return new TableCellProxy(this, row, column);
        }
        return undefined;
    }
    getRowCount() {
        return this.getRowHeights().length;
    }
    getColumnCount() {
        return this.getColumnWidths().length;
    }
    getRows() {
        return this.getRowHeights().map((_, index) => new TableRowProxy(this, index));
    }
    getRowHeights() {
        return this.properties.get('RowHeights');
    }
    getColumnWidths() {
        return this.properties.get('ColWidths');
    }
    setColumnWidths(widths) {
        this.properties.set('ColWidths', widths);
    }
    setRowHeights(heights) {
        this.properties.set('RowHeights', heights);
    }
    getAutoResizeColumns() {
        return this.properties.get('AutoColWidth');
    }
    getAutoResizeRows() {
        return this.properties.get('AutoRowHeight');
    }
    setAutoResizeColumns(auto) {
        this.properties.set('AutoColWidth', auto);
    }
    setAutoResizeRows(auto) {
        this.properties.set('AutoRowHeight', auto);
    }
    /**
     * @param margin The inset margin to be used, it control the margin for each table cell.
     */
    setInsetMargin(margin) {
        this.properties.set('InsetMargin', margin);
    }
}
exports.TableBlockProxy = TableBlockProxy;
TableBlockProxy.classNameRegex = /^DefaultTableBlock$/;
