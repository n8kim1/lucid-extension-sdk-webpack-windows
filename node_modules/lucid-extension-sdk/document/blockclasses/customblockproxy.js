"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomBlockProxy = void 0;
const checks_1 = require("../../core/checks");
const blockproxy_1 = require("../blockproxy");
/**
 * Custom shapes defined in extension packages (or other stencil-providing means like Visio stencil imports)
 * are represented by a CustomBlockProxy.
 */
class CustomBlockProxy extends blockproxy_1.BlockProxy {
    static registerCustomBlockClass(klass) {
        let byLibrary = CustomBlockProxy.subclassRegistry.get(klass.library);
        if (!byLibrary) {
            byLibrary = new Map();
            CustomBlockProxy.subclassRegistry.set(klass.library, byLibrary);
        }
        byLibrary.set(klass.shape, klass);
    }
    /**
     * @ignore
     */
    static getCustomBlockClass(client, id) {
        if (this.subclassRegistry.size > 0) {
            const stencil = client.sendCommand("gp" /* CommandName.GetProperty */, { 'id': id, 'p': 'Stencil' });
            if ((0, checks_1.isObjectUnsafe)(stencil)) {
                const sourceStencil = client.sendCommand("gp" /* CommandName.GetProperty */, { 'p': 'Stencil-' + stencil['id'] });
                if ((0, checks_1.isObjectUnsafe)(sourceStencil) && (0, checks_1.isObjectUnsafe)(sourceStencil['sourcePackage'])) {
                    if (sourceStencil['sourcePackage']['packageId'] === lucid.getPackageId()) {
                        const byLibrary = CustomBlockProxy.subclassRegistry.get(String(sourceStencil['sourcePackage']['library']));
                        const klass = byLibrary === null || byLibrary === void 0 ? void 0 : byLibrary.get(String(sourceStencil['sourcePackage']['shape']));
                        if (klass) {
                            return klass;
                        }
                    }
                }
            }
        }
        return CustomBlockProxy;
    }
    isFromStencil(library, shape) {
        const stencil = this.properties.get('Stencil');
        if ((0, checks_1.isObjectUnsafe)(stencil)) {
            const sourceStencil = this.client.sendCommand("gp" /* CommandName.GetProperty */, { 'p': 'Stencil-' + stencil['id'] });
            if ((0, checks_1.isObjectUnsafe)(sourceStencil) && (0, checks_1.isObjectUnsafe)(sourceStencil['sourcePackage'])) {
                return (sourceStencil['sourcePackage']['packageId'] === lucid.getPackageId() &&
                    sourceStencil['sourcePackage']['library'] === library &&
                    sourceStencil['sourcePackage']['shape'] === shape);
            }
        }
        return false;
    }
    getCustomShapeType() {
        const stencil = this.properties.get('Stencil');
        if ((0, checks_1.isObjectUnsafe)(stencil)) {
            const sourceStencil = this.client.sendCommand("gp" /* CommandName.GetProperty */, { 'p': 'Stencil-' + stencil['id'] });
            if ((0, checks_1.isObjectUnsafe)(sourceStencil) && (0, checks_1.isObjectUnsafe)(sourceStencil['sourcePackage'])) {
                return {
                    packageId: sourceStencil['sourcePackage']['packageId'],
                    library: sourceStencil['sourcePackage']['library'],
                    shape: sourceStencil['sourcePackage']['shape'],
                };
            }
        }
        throw new Error('Custom shape has no source');
    }
    getStencilTextAreaName(stencilTextAreaName) {
        return this.textAreas.keys().find((name) => name.endsWith('_' + stencilTextAreaName));
    }
}
exports.CustomBlockProxy = CustomBlockProxy;
CustomBlockProxy.classNameRegex = /^CustomBlock$/;
CustomBlockProxy.subclassRegistry = new Map();
