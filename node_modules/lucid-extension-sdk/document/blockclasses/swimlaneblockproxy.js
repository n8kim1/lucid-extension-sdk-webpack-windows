"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwimLaneBlockProxy = exports.SwimLanePrimaryLaneProxy = void 0;
const fillcolor_1 = require("../../core/properties/fillcolor");
const blockproxy_1 = require("../blockproxy");
class SwimLanePrimaryLaneProxy {
    constructor(swimlane, index) {
        this.swimlane = swimlane;
        this.index = index;
    }
    /**
     * For horizontal lanes, the lane height.
     * For vertical lanes, the lane width.
     */
    getSize() {
        return this.swimlane.getPrimaryLaneSizes()[this.index];
    }
    getBoundingBox() {
        const bb = this.swimlane.getBoundingBox();
        const sizes = this.swimlane.getPrimaryLaneSizes();
        if (this.swimlane.getPrimaryLanesVertical()) {
            return {
                x: bb.x + sizes.slice(0, this.index).reduce((a, b) => a + b, 0),
                y: bb.y,
                w: sizes[this.index],
                h: bb.h,
            };
        }
        else {
            return {
                x: bb.x,
                y: bb.y + sizes.slice(0, this.index).reduce((a, b) => a + b, 0),
                w: bb.w,
                h: sizes[this.index],
            };
        }
    }
    getTitleTextAreaId() {
        const existing = this.swimlane.properties.get('PrimaryLaneTextAreaIds')[this.index];
        if (existing) {
            return existing;
        }
        this.swimlane.updateTextAreaNames();
        return this.swimlane.properties.get('PrimaryLaneTextAreaIds')[this.index];
    }
    getTitle() {
        return this.swimlane.textAreas.get(this.getTitleTextAreaId());
    }
    setTitle(title) {
        return this.swimlane.textAreas.set(this.getTitleTextAreaId(), title);
    }
    setFill(fill) {
        this.swimlane.properties.set(`CellFill_0,${this.index}`, (0, fillcolor_1.serializeSimpleFill)(fill));
    }
}
exports.SwimLanePrimaryLaneProxy = SwimLanePrimaryLaneProxy;
class SwimLaneBlockProxy extends blockproxy_1.BlockProxy {
    getPrimaryLaneSizes() {
        return this.properties.get('PrimaryLane');
    }
    setPrimaryLaneSizes(sizes) {
        this.properties.set('PrimaryLane', sizes);
        this.updateTextAreaNames();
    }
    getPrimaryLanes() {
        return this.getPrimaryLaneSizes().map((size, index) => new SwimLanePrimaryLaneProxy(this, index));
    }
    getPrimaryLanesVertical() {
        return this.properties.get('IsPrimaryLaneVertical');
    }
    getMagnetized() {
        return this.properties.get('Magnetize');
    }
    setMagnetized(magnetize) {
        this.properties.set('Magnetize', magnetize);
    }
    /** @ignore */
    updateTextAreaNames() {
        this.properties.set('PrimaryLaneTextAreaIds', this.getPrimaryLaneSizes().map((_, index) => 'Primary_' + index));
    }
    /**
     * Swim lanes only use the normal BoundingBox property for location.
     * For size, it uses the PrimaryLane and SecondaryLane properties.
     */
    setBoundingBox(bb) {
        super.setBoundingBox(bb); //To get position correct
        const minLaneSize = 40;
        const oldBB = this.getBoundingBox();
        const primarySizes = this.getPrimaryLaneSizes();
        const secondarySizes = this.properties.get('SecondaryLane');
        const adjustLanesByDelta = (lanes, delta, laneIndex = lanes.length - 1) => {
            if (laneIndex >= 0 && laneIndex < lanes.length) {
                lanes[laneIndex] += delta;
                if (lanes[laneIndex] < minLaneSize) {
                    const deltaLeft = minLaneSize - lanes[laneIndex];
                    lanes[laneIndex] = minLaneSize;
                    adjustLanesByDelta(lanes, deltaLeft, laneIndex - 1);
                }
            }
        };
        if (bb.w != oldBB.w) {
            if (this.getPrimaryLanesVertical()) {
                adjustLanesByDelta(primarySizes, bb.w - oldBB.w);
                this.setPrimaryLaneSizes(primarySizes);
            }
            else {
                adjustLanesByDelta(secondarySizes, bb.w - oldBB.w);
                this.properties.set('SecondaryLane', secondarySizes);
            }
        }
        if (bb.h != oldBB.h) {
            if (this.getPrimaryLanesVertical()) {
                adjustLanesByDelta(secondarySizes, bb.h - oldBB.h);
                this.properties.set('SecondaryLane', secondarySizes);
            }
            else {
                adjustLanesByDelta(primarySizes, bb.h - oldBB.h);
                this.setPrimaryLaneSizes(primarySizes);
            }
        }
    }
}
exports.SwimLaneBlockProxy = SwimLaneBlockProxy;
SwimLaneBlockProxy.classNameRegex = /^AdvancedSwimLaneBlock$/;
