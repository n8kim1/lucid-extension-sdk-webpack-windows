"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeEffectDefinition = exports.serializeConditionDefinition = void 0;
const badgeposition_1 = require("../core/properties/datagraphic/badgeposition");
const datagraphicindexes_1 = require("../core/properties/datagraphic/datagraphicindexes");
const conditiontype_1 = require("../core/rules/conditiontype");
const serializedeffect_1 = require("../core/rules/serializedeffect");
/** @ignore */
function serializeConditionDefinition(condition) {
    switch (condition.type) {
        case conditiontype_1.ConditionType.Formula:
            return {
                'Type': condition.type,
                'Source': 'this',
                'Condition': 0,
                'Value': condition.formula,
            };
        case conditiontype_1.ConditionType.Text:
            return {
                'Type': condition.type,
                'Source': 'this',
                'Condition': condition.condition,
                'Value': condition.value,
            };
        case conditiontype_1.ConditionType.ShapeData:
            return {
                'Type': condition.type,
                'Source': 'this',
                'Condition': condition.condition,
                'Value': condition.value,
                'Label': condition.field,
                'DisplayLabel': condition.fieldLabel,
            };
        case conditiontype_1.ConditionType.ShapeType:
            return {
                'Type': condition.type,
                'Source': 'this',
                'Condition': condition.condition,
                'Value': condition.classNames,
            };
        default:
            throw new Error('Unsupported ConditionType');
    }
}
exports.serializeConditionDefinition = serializeConditionDefinition;
/** @ignore */
function serializeEffectDefinition(effect, conditionOrder) {
    var _a;
    return {
        'ConditionOrder': conditionOrder,
        'Combination': effect.combination,
        'FormatType': effect.formatType,
        'Formatting': effect.formatType === serializedeffect_1.RuleFormattingType.FORMATTING
            ? {
                'Block': {
                    'FillColor': JSON.stringify(effect.formatting.fillColor),
                    'LineColor': JSON.stringify(effect.formatting.borderColor),
                    'LineWidth': JSON.stringify(effect.formatting.borderWidth),
                    'StrokeStyle': JSON.stringify(effect.formatting.borderStyle),
                },
                'Line': {
                    'LineColor': JSON.stringify(effect.formatting.lineColor),
                    'LineWidth': JSON.stringify(effect.formatting.lineWidth),
                    'StrokeStyle': JSON.stringify(effect.formatting.lineStyle),
                },
            }
            : {},
        'DataGraphic': effect.formatType === serializedeffect_1.RuleFormattingType.DATA_GRAPHICS
            ? effect.dataGraphic.set === datagraphicindexes_1.DataGraphicIconSets.CUSTOM_ICONS
                ? {
                    'Set': effect.dataGraphic.set,
                    'Index': 0,
                    'Position': (0, badgeposition_1.serializeBadgeEnumPosition)(effect.dataGraphic.position),
                    'Image': {
                        'url': effect.dataGraphic.image.url,
                        'w': effect.dataGraphic.image.width,
                        'h': effect.dataGraphic.image.height,
                    },
                }
                : {
                    'Set': effect.dataGraphic.set,
                    'Index': (_a = effect.dataGraphic.index) !== null && _a !== void 0 ? _a : 0,
                    'Position': (0, badgeposition_1.serializeBadgeEnumPosition)(effect.dataGraphic.position),
                    'Color': effect.dataGraphic.color,
                }
            : undefined,
        'Tooltip': effect.tooltip,
    };
}
exports.serializeEffectDefinition = serializeEffectDefinition;
