import { DuplicateItemsResult, GetDocumentChunksType } from '../commandtypes';
import { EditorClient } from '../editorclient';
import { DocumentChunk } from './documentchunk';
import { CardConfigProxy } from './documentelement/cardconfigproxy';
import { RuleProxy } from './documentelement/ruleproxy';
import { ElementProxy } from './elementproxy';
import { ItemProxy } from './itemproxy';
import { MapProxy } from './mapproxy';
import { PageDefinition } from './pagedefinition';
import { PageProxy } from './pageproxy';
import { RuleDefinition } from './ruledefinition';
/**
 * The currently-open Lucid document
 */
export declare class DocumentProxy extends ElementProxy {
    private static nextHookId;
    private static getNextHookName;
    /**
     * The set of pages on this document, organized by ID
     */
    readonly pages: MapProxy<string, PageProxy>;
    constructor(client: EditorClient);
    /**
     * An iterator over all blocks on all pages of the document
     */
    allBlocks(): Generator<import("./blockproxy").BlockProxy, void, unknown>;
    /**
     * An iterator over all lines on all pages of the document
     */
    allLines(): Generator<import("./lineproxy").LineProxy, void, unknown>;
    /**
     * Add a new page to the current document
     * @param def Definition of the page to add
     * @returns The created page
     */
    addPage(def: PageDefinition): PageProxy;
    /**
     * Updates the title of this document
     * @param title The new title for this document
     */
    setTitle(title: string): void;
    /**
     * @returns The title of this document
     */
    getTitle(): string;
    /** @ignore */
    getDocumentChunks(types: GetDocumentChunksType[]): DocumentChunk[];
    /**
     * Infrequently, you may need to watch for *any* changes to the document. These changes may be
     * the local user adding content, or a data integration sending updated records to a data collection,
     * or a remote user hitting undo, or any user entering or exiting an intra-document mutex.
     *
     * Because these changes may happen rapidly, the callback you provide here will only be called on
     * a heavily-debounced schedule. The callback will happen between 1-10 seconds after changes are
     * made to the document, depending on the frequency with which changes are happening.
     * @param callback
     * @returns A handle that can be passed into `unhookAllChanges`
     */
    hookAllChanges(callback: () => void): string;
    /**
     * @param handle Return value from `hookAllChanges`
     */
    unhookAllChanges(handle: string): void;
    /**
     * Watch for new blocks, lines, or groups added to this document. The callback will
     * be called with new items created by the current user, but will not be called with items
     * created
     *
     *  - As part of a generated diagram, e.g. org chart
     *  - By another user on the same document
     *
     * @param callback
     * @returns A handle that can be passed to `unhookCreateItems`
     */
    hookCreateItems(callback: (items: ItemProxy[]) => void): string;
    /**
     * @param handle Return value from `hookCreateItems`
     */
    unhookCreateItems(handle: string): void;
    readonly cardIntegrationConfigs: MapProxy<string, CardConfigProxy>;
    readonly rules: MapProxy<string, RuleProxy>;
    addRule(definition: RuleDefinition): RuleProxy | undefined;
    /**
     * Watch for new blocks, lines, or groups deleted from this document. The callback will
     * be called with items deleted by the current user, but will not be called with items
     * deleted
     *
     *  - As part of a generated diagram, e.g. org chart
     *  - By another user on the same document
     *
     * @param callback
     * @returns A handle that can be passed to `unhookDeleteItems`
     */
    hookDeleteItems(callback: (itemIds: string[]) => void): string;
    /**
     * @param handle Return value from `hookDeleteItems`
     */
    unhookDeleteItems(handle: string): void;
    duplicateItems(ids: string[]): DuplicateItemsResult;
}
