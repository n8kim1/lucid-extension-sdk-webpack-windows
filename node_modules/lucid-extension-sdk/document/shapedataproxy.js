"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShapeDataProxy = void 0;
const checks_1 = require("../core/checks");
const serializeddataerror_1 = require("../core/serializeddataerror");
const shapedatainheritance_1 = require("../core/shapedatainheritance");
const dataerror_1 = require("../data/dataerror");
const mapproxy_1 = require("./mapproxy");
/**
 * The shape data fields on a single element of the current document
 */
class ShapeDataProxy extends mapproxy_1.WriteableMapProxy {
    /**
     * @param id The ID of the element, or undefined for the document itself
     * @param client
     */
    constructor(id, client) {
        super(() => this.client.sendCommand("lsd" /* CommandName.ListShapeData */, { 'id': this.id }), (name) => ShapeDataProxy.parseData(this.client.sendCommand("gsd" /* CommandName.GetShapeData */, {
            'id': this.id,
            'n': name,
        })), (name, value) => {
            if ((0, serializeddataerror_1.isSerializedDataError)(value)) {
                throw new Error('Cannot store an error value');
            }
            if (this.keys().includes(name)) {
                this.client.sendCommand("ssd" /* CommandName.SetShapeData */, { 'id': this.id, 'n': name, 'v': value });
            }
            else {
                this.client.sendCommand("asd" /* CommandName.AddShapeData */, {
                    'id': this.id,
                    'i': shapedatainheritance_1.ShapeDataInheritance.NONE,
                    'n': name,
                    'v': value,
                });
            }
        });
        this.id = id;
        this.client = client;
    }
    /**
     * Add shape data to this element that is inherited by its descendants.
     *
     * If you add an inheritable shape data to a page, whose formula is "=@Cost * 4", then
     * each item on that page will have a new shape data entry (in `allShapeData`) by that
     * name with the value calculated in the context of that individual item.
     *
     * Inheritable shape data on a page affects all items on the page. Inheritable shape
     * data on a group affects all items inside that group.
     *
     * @param name Name of the new shape data
     * @param value Value (or formula, if starting with "=") of the new shape data
     */
    addInheritable(name, value) {
        this.client.sendCommand("asd" /* CommandName.AddShapeData */, {
            'id': this.id,
            'i': shapedatainheritance_1.ShapeDataInheritance.VALUE,
            'n': name,
            'v': value,
        });
    }
    /**
     * Delete the specified shape data from this element
     * @param key
     */
    delete(key) {
        if (this.keys().includes(key)) {
            this.client.sendCommand("dsd" /* CommandName.DeleteShapeData */, { 'id': this.id, 'n': key });
        }
    }
    /** @ignore */
    static parseData(raw) {
        if ((0, serializeddataerror_1.isSerializedDataError)(raw)) {
            return new dataerror_1.DataError(raw['error'], raw['type']);
        }
        //TODO, eventually: parse these
        return raw;
    }
    /**
     * @param key Name of the shape data to read
     * @returns The value if it is a string, or an empty string if it does not exist or is not a string.
     */
    getString(key) {
        const val = this.get(key);
        if (!(0, checks_1.isString)(val)) {
            return '';
        }
        return val;
    }
}
exports.ShapeDataProxy = ShapeDataProxy;
