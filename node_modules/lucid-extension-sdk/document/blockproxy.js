"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockProxy = void 0;
const badgeposition_1 = require("../core/properties/datagraphic/badgeposition");
const staticdatagraphicsettings_1 = require("../core/properties/datagraphic/staticdatagraphicsettings");
const fillcolor_1 = require("../core/properties/fillcolor");
const shadow_1 = require("../core/properties/shadow");
const math_1 = require("../math");
const itemproxy_1 = require("./itemproxy");
/**
 * A block is a single shape on the document. A BlockProxy provides an interface to
 * read and write the content of an existing block, and is typically accessed through
 * [PageProxy.blocks](#classes_document_pageproxy-PageProxy_blocks) or another
 * similar mechanism.
 */
class BlockProxy extends itemproxy_1.ItemProxy {
    /**
     * @returns The class name of this block. This name is not necessarily human-readable,
     * and will remain consistent over time, e.g. "ProcessBlock"..
     */
    getClassName() {
        return this.properties.get('ClassName');
    }
    /**
     * @returns The amount this block is rotated around its own center, in radians.
     */
    getRotation() {
        return this.properties.get('Rotation');
    }
    /**
     * @returns An axis-aligned bounding box containing this full item after any rotation it might have
     */
    getRotatedBoundingBox() {
        return (0, math_1.rotatedBoundingBox)(this.getBoundingBox(), this.getRotation());
    }
    /**
     * @param radians Angle the block should be rotated
     */
    setRotation(radians) {
        this.properties.set('Rotation', radians);
    }
    /**
     * @returns The current drop shadow on this block, or undefined if no shadow is set
     */
    getShadow() {
        const raw = this.properties.get('Shadow');
        if (!raw) {
            return undefined;
        }
        return (0, shadow_1.deserializeShadow)(raw);
    }
    /**
     * @param shadow The drop shadow to set on the block, or undefined to clear the drop shadow
     */
    setShadow(shadow) {
        if (shadow) {
            this.properties.set('Shadow', (0, shadow_1.serializeShadow)(shadow));
        }
        else {
            this.properties.set('Shadow', null);
        }
    }
    /**
     * Set the fill style used (by most kinds of blocks) to fill in their main opaque areas.
     * This can be a string color (e.g. `'#ff00ff80'`) or an image fill.
     */
    setFillStyle(fillStyle) {
        this.properties.set('FillColor', (0, fillcolor_1.serializeSimpleFill)(fillStyle));
    }
    /**
     * @returns An array of lines that have one or both endpoints connected to this block.
     */
    getConnectedLines() {
        const ids = this.client.sendCommand("gcl" /* CommandName.GetConnectedLines */, this.id);
        return ids.map((id) => this.client.getLineProxy(id));
    }
    /**
     * @param settings Information about the static data graphic icon to set on this block.
     */
    setSimpleStaticDataGraphic(settings) {
        if (settings) {
            this.properties.set('StaticDataGraphic', (0, staticdatagraphicsettings_1.serializeSimpleStaticDataGraphicSettings)(settings));
        }
        else {
            this.properties.set('StaticDataGraphic', undefined);
        }
    }
    /**
     * @returns Settings for the simple static data graphic currently set on this block, or undefined
     * if no simple data graphic is currently set. Note that if a data graphic exists that is not an
     * icon, this will return undefined. This function will not consider data graphics set via
     * conditional formatting rules.
     */
    getSimpleStaticDataGraphic() {
        const settings = this.properties.get('StaticDataGraphic');
        if ((0, staticdatagraphicsettings_1.isSerializedSimpleStaticDataGraphicSettings)(settings)) {
            return (0, staticdatagraphicsettings_1.deserializeSimpleStaticDataGraphicSettings)(settings);
        }
        else {
            return undefined;
        }
    }
    /**
     * Lock this block's aspect ratio to its current value.
     * This can be reversed with unlockAspectRatio.
     */
    lockAspectRatio() {
        const bb = this.getBoundingBox();
        this.properties.set('AspectRatio', bb.w / bb.h);
    }
    /**
     * Unlock the aspect ratio of this block, allowing it to be stretched vertically or horizontally independently.
     */
    unlockAspectRatio() {
        this.properties.set('AspectRatio', undefined);
    }
    /**
     * @returns The line width used by most kinds of blocks to render their outline.
     */
    getLineWidth() {
        return this.properties.get('LineWidth');
    }
    /**
     * @param width The line width to be used (by most kinds of blocks) to render this block's outline
     */
    setLineWidth(width) {
        this.properties.set('LineWidth', width);
    }
    /**
     * Link a text area to a data field, so that editing the text area will also update the
     * associated data, and vice versa.
     *
     * To use this, first establish a reference key on this block with
     * [setReferenceKey](/extension-sdk/#classes_document_blockproxy-BlockProxy_setreferencekey).
     *
     * @param textAreaKey
     * @param referenceKey
     * @param field
     */
    linkText(textAreaKey, referenceKey, field) {
        if (!this.textAreas.keys().includes(textAreaKey)) {
            throw new Error('Invalid text area key');
        }
        if (!this.referenceKeys.keys().includes(referenceKey)) {
            throw new Error('Invalid reference key');
        }
        this.properties.set(textAreaKey + '_Link', {
            'ref': referenceKey,
            'f': field,
        });
    }
    /**
     * @param position The postion where the data sync state icon should be displayed on the block. If this position is
     * set to undefined then the state icon position will fallback to the default position for the block.
     */
    setDataSyncStateIconPosition(position) {
        this.properties.set('DataSyncStateIconPosition', position ? (0, badgeposition_1.serializeBadgeEnumPosition)(position) : null);
    }
}
exports.BlockProxy = BlockProxy;
