"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ItemProxy = void 0;
const offsettype_1 = require("../core/offsettype");
const elementproxy_1 = require("./elementproxy");
const mapproxy_1 = require("./mapproxy");
/**
 * A block, line, or group on a page of the current document.
 */
class ItemProxy extends elementproxy_1.ElementProxy {
    /**
     * @param id ID of this item
     * @param client
     */
    constructor(id, client) {
        super(id, client);
        this.id = id;
        /**
         * The plain text in each of the text areas on this item, organized by text area name.
         */
        this.textAreas = new mapproxy_1.WriteableMapProxy(() => this.client.sendCommand("lta" /* CommandName.ListTextAreas */, this.id), (name) => this.client.sendCommand("gp" /* CommandName.GetProperty */, {
            'id': this.id,
            'p': name,
        }), (name, plainText, options) => this.client.sendCommand("st" /* CommandName.SetText */, {
            'id': this.id,
            'n': name,
            't': plainText,
            'f': options === null || options === void 0 ? void 0 : options.force,
        }));
        /**
         * The text style in each of the text areas on this item, organized by text area name.
         */
        this.textStyles = new mapproxy_1.WriteableMapProxy(() => this.textAreas.keys(), (name) => this.client.sendCommand("gts" /* CommandName.GetTextStyle */, {
            'id': this.id,
            'n': name,
        }), (name, style) => this.client.sendCommand("sts" /* CommandName.SetTextStyle */, {
            'id': this.id,
            'n': name,
            's': style,
        }));
    }
    /**
     * @returns The bounding box of this item relative to its containing page. As pages may change size
     * to fit the content on them, note that these coordinates may be negative or very large.
     *
     * If this is a rotated block, the bounding box returned here is where the block would be if it were
     * unrotated.
     */
    getBoundingBox() {
        return this.properties.get('BoundingBox');
    }
    /**
     * Attempts to move and resize this item to fit into the given bounding box. If this item (or another
     * item it contains) has size or aspect ratio restrictions, it may not be possible to fit the requested
     * location exactly.
     *
     * This is done by moving this item to the requested location, then attempting to resize it from the
     * bottom-right corner to the requested size.
     *
     * @param bb The bounding box to attempt to make this item fill
     */
    setBoundingBox(bb) {
        const current = this.getBoundingBox();
        if (current.x !== bb.x || current.y !== bb.y) {
            this.offset(offsettype_1.OffsetType.MOVE, { x: bb.x - current.x, y: bb.y - current.y });
        }
        if (current.w !== bb.w || current.h !== bb.h) {
            this.offset(offsettype_1.OffsetType.SE, {
                x: bb.w - current.w,
                y: bb.h - current.h,
            });
        }
    }
    /**
     * @returns The ID of the page containing this item
     */
    getPageId() {
        return this.client.sendCommand("gip" /* CommandName.GetItemPageId */, this.id);
    }
    /**
     * @returns The page containing this item
     */
    getPage() {
        return this.client.getPageProxy(this.getPageId());
    }
    /**
     * @returns The x/y location of this item
     */
    getLocation() {
        const bb = this.getBoundingBox();
        return { x: bb.x, y: bb.y };
    }
    /**
     * Moves this item so that its upper-left corner is positioned at the given location (prior to any rotation)
     * @param location The target location
     */
    setLocation(location) {
        const current = this.getBoundingBox();
        if (current.x !== location.x || current.y !== location.y) {
            this.offset(offsettype_1.OffsetType.MOVE, { x: location.x - current.x, y: location.y - current.y });
        }
    }
    /**
     * Offset this item in the given direction by the given amount.
     * @param type The type of offset to apply to this item
     * @param offset The amount to offset
     */
    offset(type, offset) {
        this.client.sendCommand("oi" /* CommandName.OffsetItems */, { 'ids': [this.id], 't': type, 'o': offset });
    }
    /**
     * Measure the amount of space necessary to render the text in the given text area, given a
     * width to measure that text within.
     * @param name Name of the text area whose content we should measure
     * @param maxWidth Width of the area in which to measure this text. The result will usually be no wider than this, but if a single word is long enough to go beyond this maxWidth, the width of that word will be returned.
     * @returns The size of rectangle necessary to render this text area's content.
     */
    measureText(name, maxWidth) {
        return this.client.sendCommand("mt" /* CommandName.MeasureText */, { 'id': this.id, 'n': name, 'w': maxWidth });
    }
    /**
     * Delete this item from the document
     */
    delete() {
        this.client.sendCommand("di" /* CommandName.DeleteItem */, this.id);
    }
    /**
     * @returns An array of blocks whose bounding boxes contain this item's upper-left corner
     */
    getContainers() {
        const containers = this.executeFormula('LABEL(CONTAINEDBY)');
        return containers.map((id) => this.client.getBlockProxy(id));
    }
    /**
     * @param operation How to adjust the Z order of this item relative to the other items it overlaps on the page
     */
    changeZOrder(operation) {
        this.client.sendCommand("z" /* CommandName.ZOrder */, { 'i': [this.id], 'o': operation });
    }
    /**
     * @param rule Rule to apply to this item
     */
    applyRule(rule) {
        const ids = this.properties.get('RuleList');
        if (!ids.includes(rule.id)) {
            ids.push(rule.id);
            this.properties.set('RuleList', ids);
        }
    }
    /**
     * @param rule Rule to remove from this item
     */
    unapplyRule(rule) {
        const ids = this.properties.get('RuleList');
        if (ids.includes(rule.id)) {
            this.properties.set('RuleList', ids.filter((id) => id !== rule.id));
        }
    }
}
exports.ItemProxy = ItemProxy;
