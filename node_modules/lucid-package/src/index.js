"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const argparse_1 = require("argparse");
const path = require("path");
const angularframeworkutils_1 = require("./angularframeworkutils");
const dataconnector_1 = require("./dataconnector");
const editorextension_1 = require("./editorextension");
const interactive = require("./interactibilityutil");
const package_1 = require("./package");
const reactframeworkutils_1 = require("./reactframeworkutils");
const shapelibrary_1 = require("./shapelibrary");
class LucidSuiteExtensionCLI {
    async run(args) {
        const parser = new argparse_1.ArgumentParser({
            description: 'Create and manage Lucid extension packages',
        });
        // For internal development, creating and operating on a package via bazel
        parser.add_argument('--is-internal', {
            default: false,
            action: 'store_true',
            help: argparse_1.SUPPRESS,
        });
        // Gives the root directory to create projects in.
        parser.add_argument('--chdir', { type: 'str', help: argparse_1.SUPPRESS });
        // If running with the chdir argument, specifies a project name inside the chdir.
        // Otherwise (if not running with the chdir argument), directly specifies a directory to chdir to.
        parser.add_argument('--project', '-p', {
            type: 'str',
            help: argparse_1.SUPPRESS,
        });
        const subparsers = parser.add_subparsers({ dest: 'command' });
        const createParser = subparsers.add_parser('create', {
            help: 'Create a new Lucid extension package in a new directory',
        });
        createParser.add_argument('name', { nargs: '?', type: 'str' });
        const packageParser = subparsers.add_parser('bundle', {
            help: 'Prepare the current package for upload to the developer dashboard',
        });
        packageParser.add_argument('--quiet', {
            default: false,
            action: 'store_true',
            help: argparse_1.SUPPRESS,
        });
        packageParser.add_argument('--env', {
            help: 'Provide the environment to define which manifest.<env>.json is combined with manifest.json when bundling. If not provided, uses manifest.json only.',
        });
        packageParser.add_argument('--skip-sdk', {
            default: false,
            action: 'store_true',
            help: argparse_1.SUPPRESS,
        });
        const updateSDKParser = subparsers.add_parser('update-sdk', {
            help: 'Update the editor extension SDK to the latest published version for all editor extensions in this package',
        });
        const createExtensionParser = subparsers.add_parser('create-editor-extension', {
            help: 'Create a new editor extension as part of the current package',
        });
        createExtensionParser.add_argument('name');
        createExtensionParser.add_argument('--skip-sdk', {
            default: false,
            action: 'store_true',
            help: argparse_1.SUPPRESS,
        });
        const buildExtensionParser = subparsers.add_parser('build-editor-extension', {
            help: 'Compile an editor extension in production mode; use this to check types and validate final compiled output',
        });
        buildExtensionParser.add_argument('name');
        buildExtensionParser.add_argument('--quiet', {
            default: false,
            action: 'store_true',
            help: argparse_1.SUPPRESS,
        });
        buildExtensionParser.add_argument('--skip-sdk', {
            default: false,
            action: 'store_true',
            help: argparse_1.SUPPRESS,
        });
        const testExtensionParser = subparsers.add_parser('test-editor-extension', {
            help: 'Compile one or more editor extensions in debug mode, and serve them at localhost:9900, along with any shape libraries in this package at localhost:9901. Watch for changes to the code and recompile as needed',
        });
        testExtensionParser.add_argument('name', { nargs: '*' });
        testExtensionParser.add_argument('--quiet', {
            default: false,
            action: 'store_true',
            help: argparse_1.SUPPRESS,
        });
        testExtensionParser.add_argument('--anyport', {
            default: false,
            action: 'store_true',
            help: argparse_1.SUPPRESS,
        });
        testExtensionParser.add_argument('--watch-ignore-node-modules', {
            default: false,
            action: 'store_true',
            help: 'Do not recompile extension when files in node_modules are changed',
        });
        const watchExtensionParser = subparsers.add_parser('watch-editor-extension', {
            help: 'Compile an editor extension in debug mode',
        });
        watchExtensionParser.add_argument('name');
        watchExtensionParser.add_argument('--quiet', {
            default: false,
            action: 'store_true',
            help: argparse_1.SUPPRESS,
        });
        watchExtensionParser.add_argument('--watch-ignore-node-modules', {
            default: false,
            action: 'store_true',
            help: 'Do not recompile extension when files in node_modules are changed',
        });
        const testShapeLibraries = subparsers.add_parser('test-shape-libraries', {
            help: 'Serve any shape libraries in this package at localhost:9901. Watch for changes to the code and live-update as needed',
        });
        const createShapeLibrary = subparsers.add_parser('create-shape-library', {
            help: 'Create a new shape library as part of the current package',
        });
        createShapeLibrary.add_argument('name');
        const generateImageShapeLibrary = subparsers.add_parser('create-image-shape-library', {
            help: 'Create a new shape library as part of the current package',
        });
        generateImageShapeLibrary.add_argument('name');
        generateImageShapeLibrary.add_argument('path');
        generateImageShapeLibrary.add_argument('--width', {
            type: 'str',
            help: argparse_1.SUPPRESS,
        });
        generateImageShapeLibrary.add_argument('--height', {
            type: 'str',
            help: argparse_1.SUPPRESS,
        });
        generateImageShapeLibrary.add_argument('--aspectRatio', {
            default: false,
            action: 'store_true',
            help: 'Lock the aspect ratio of all images',
        });
        const createDataConnectorParser = subparsers.add_parser('create-data-connector', {
            help: 'Create a new data-connector as part of the current package',
        });
        createDataConnectorParser.add_argument('name');
        createDataConnectorParser.add_argument('--skip-sdk', {
            default: false,
            action: 'store_true',
            help: argparse_1.SUPPRESS,
        });
        const parsed = parser.parse_args(args);
        //For internal development, creating and operating on a package via bazel
        const isInternal = parsed['is_internal'] ||
            // If we've spawned a child process recursively calling a new lucid-package target,
            // as long as it's originally triggered by Bazel then we're still using Bazel flows.
            process.env['BAZEL_TARGET'];
        let isChdir = !!parsed['chdir'];
        if (isChdir) {
            if (parsed['project']) {
                process.chdir(path.join(parsed['chdir'], parsed['project']));
            }
            else {
                process.chdir(parsed['chdir']);
            }
        }
        else if (parsed['project']) {
            process.chdir(parsed['project']);
        }
        switch (parsed['command']) {
            case 'create':
                if (parsed['name'] == null) {
                    parsed['name'] = await interactive.inputPrompt('Please enter the name of the Lucid Package');
                }
                await (0, package_1.createEmptyPackage)(parsed['name']);
                const options = ['Editor Extension', 'Shape Library', 'Data Connector'];
                const choices = await interactive.multiSelect('Select components to add to package (can select none or more than one)', options);
                const packagePath = path.join(process.cwd(), parsed['name']);
                for (let choice of choices) {
                    switch (choice) {
                        case 0:
                            process.chdir(packagePath);
                            const editorExtensionName = await interactive.inputPrompt('Please enter the name of the editor extension');
                            const wantFramework = await interactive.confirmPrompt('Do you want to use a framework for custom UI?');
                            if (wantFramework) {
                                const options = ['Angular', 'React'];
                                const choice = await interactive.selectPrompt('Please select a framework', options);
                                switch (choice) {
                                    case 0:
                                        await (0, angularframeworkutils_1.createAngularEditorExtension)(editorExtensionName, isInternal, false);
                                        break;
                                    case 1:
                                        const options = ['Javascript', 'Typescript'];
                                        const choice = await interactive.selectPrompt('Please select flavor', options);
                                        await (0, reactframeworkutils_1.createReactEditorExtension)(editorExtensionName, options[choice], isInternal, false);
                                        break;
                                }
                            }
                            else {
                                await (0, editorextension_1.createEditorExtension)(editorExtensionName, isInternal, false);
                            }
                            break;
                        case 1:
                            process.chdir(packagePath);
                            const shapeLibraryName = await interactive.inputPrompt('Please enter the name of the shape library');
                            await (0, shapelibrary_1.createEmptyShapeLibrary)(shapeLibraryName);
                            break;
                        case 2:
                            process.chdir(packagePath);
                            const dataConnectorName = await interactive.inputPrompt('Please enter the name of the data connector');
                            await (0, dataconnector_1.createDataConnector)(dataConnectorName, isInternal, false);
                            break;
                    }
                }
                break;
            default:
                // All the following commands can only be executed inside a Lucid extension package folder
                if (!(0, package_1.currentlyInPackage)()) {
                    console.error('Not currently in a Lucid extension package folder');
                }
                else {
                    switch (parsed['command']) {
                        case 'bundle':
                            await (0, package_1.writePackage)(parsed['quiet'], parsed['env'], parsed['skip_sdk']);
                            break;
                        case 'update-sdk':
                            await (0, package_1.updateAllExtensionSDK)();
                            break;
                        case 'create-editor-extension':
                            await (0, editorextension_1.createEditorExtension)(parsed['name'], isInternal, parsed['skip_sdk']);
                            break;
                        case 'build-editor-extension':
                            await (0, editorextension_1.buildEditorExtension)(parsed['name'], isInternal, parsed['quiet'], parsed['skip_sdk']);
                            break;
                        case 'create-shape-library':
                            await (0, shapelibrary_1.createEmptyShapeLibrary)(parsed['name']);
                            break;
                        case 'create-image-shape-library':
                            const width = Number(parsed['width']) ?? undefined;
                            const height = Number(parsed['height']) ?? undefined;
                            const config = {
                                width: width,
                                height: height,
                                lockAspect: parsed['aspectRatio'],
                            };
                            await (0, shapelibrary_1.createImageShapeLibrary)(parsed['name'], parsed['path'], config);
                            break;
                        case 'create-data-connector':
                            await (0, dataconnector_1.createDataConnector)(parsed['name'], isInternal, parsed['skip_sdk']);
                            break;
                        case 'test-shape-libraries':
                            await (0, shapelibrary_1.debugShapeLibraries)();
                            break;
                        case 'test-editor-extension':
                            if (parsed['name'].length === 0) {
                                parsed['name'] = await (0, editorextension_1.getAllExtensionNames)();
                            }
                            await (0, editorextension_1.debugEditorExtension)(parsed['name'], isInternal, parsed['quiet'], parsed['anyport'], parsed['watch_ignore_node_modules']);
                            break;
                        case 'watch-editor-extension':
                            await (0, editorextension_1.watchEditorExtension)(parsed['name'], isInternal, parsed['quiet']);
                            break;
                        default:
                            parser.print_help();
                    }
                }
        }
    }
}
new LucidSuiteExtensionCLI().run(process.argv.slice(2)).catch((reason) => {
    let reasonMessage = reason;
    if (reason instanceof Object && reason.toString) {
        reasonMessage = reason.toString();
    }
    console.error('Error running Lucid Suite Extension CLI', reasonMessage);
});
