"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllExtensionNames = exports.debugEditorExtension = exports.watchEditorExtension = exports.updateExtensionSDK = exports.buildEditorExtension = exports.createEditorExtension = void 0;
const child_process_1 = require("child_process");
const express = require("express");
const oldFs = require("fs");
const fs = require("fs/promises");
const checks_1 = require("lucid-extension-sdk/sdk/core/checks");
const path = require("path");
const cors_1 = require("./cors");
const filesystemutil_1 = require("./filesystemutil");
const installationutil_1 = require("./installationutil");
const package_1 = require("./package");
const packagemanifest_1 = require("./packagemanifest");
const shapelibrary_1 = require("./shapelibrary");
const shellutil_1 = require("./shellutil");
const supportedproduct_1 = require("./supportedproduct");
const theme_1 = require("./theme");
const webpack = require('webpack');
const WebPackCLI = require('webpack-cli');
const ws = require('ws');
const chokidar = require('chokidar');
async function createEditorExtension(name, isInternal, skipSDKDependency, source = 'vanilla', deps = []) {
    const editorExtensionSource = path.join(__dirname, '..', 'templates', 'editorextension', source);
    const editorExtensionTargetFolder = path.join('editorextensions', name);
    const publicSource = path.join(__dirname, '..', 'templates', 'public');
    const publicTargetFolder = 'public';
    const codePath = path.join('editorextensions', name, 'bin', 'extension.js');
    console.log((0, theme_1.success)('Creating empty editor extension in ' + editorExtensionTargetFolder));
    (0, filesystemutil_1.copyFolderRecursiveSync)(editorExtensionSource, editorExtensionTargetFolder);
    (0, filesystemutil_1.copyFolderRecursiveSync)(publicSource, publicTargetFolder);
    await (0, package_1.modifyManifest)((manifest) => {
        if (!manifest['extensions']) {
            manifest['extensions'] = [];
        }
        manifest['extensions'].push({
            'name': name,
            'title': name,
            'products': [supportedproduct_1.SupportedProduct.Chart, supportedproduct_1.SupportedProduct.Spark, supportedproduct_1.SupportedProduct.TeamSpaces],
            'codePath': codePath,
            'scopes': ['READ', 'WRITE', 'DOWNLOAD', 'SHOW_MODAL', 'CUSTOM_UI', 'NETWORK'],
        });
    });
    console.log(`Installing dependencies`);
    process.chdir(editorExtensionTargetFolder);
    (0, installationutil_1.installDependenciesIfNeeded)(isInternal, skipSDKDependency, deps);
}
exports.createEditorExtension = createEditorExtension;
async function buildEditorExtension(name, isInternal, quiet = false, skipSdkDependency = false) {
    const extensionCodePath = path.join('editorextensions', await getExtensionCodeDirectoryName(name));
    process.chdir(extensionCodePath);
    (0, installationutil_1.installDependenciesIfNeeded)(isInternal, skipSdkDependency);
    const cli = new WebPackCLI();
    await cli.run(['node', 'webpack', '--mode', 'production', ...(quiet ? ['--stats', 'errors-only'] : [])]);
}
exports.buildEditorExtension = buildEditorExtension;
async function updateExtensionSDK(name) {
    const extensionCodePath = path.join('editorextensions', await getExtensionCodeDirectoryName(name));
    process.chdir(extensionCodePath);
    console.log((0, theme_1.success)('Installing latest SDK in extension ' + name));
    console.log((0, shellutil_1.execSyncLoggingOutputOnError)('npm install lucid-extension-sdk@latest').toString());
}
exports.updateExtensionSDK = updateExtensionSDK;
/**
 * Uses webpack to watch for changes in the editor extension
 * @param name The editor extension name
 * @param quiet If true, will only show errors in output
 * @param ignoreNodeModules If true, while serving, will not autoreload on changes to node_modules files
 */
async function watchEditorExtension(name, isInternal, quiet = false, ignoreNodeModules = false) {
    const originalDirectory = process.cwd();
    const extensionCodePath = path.join('editorextensions', await getExtensionCodeDirectoryName(name));
    process.chdir(extensionCodePath);
    (0, installationutil_1.installDependenciesIfNeeded)(isInternal);
    const webpackConfigExport = require(path.resolve('webpack.config.js'));
    // For backwards compatibility, we need to support extensions where the webpack config is a fuction or an object
    const webpackConfig = typeof webpackConfigExport == 'function' ? webpackConfigExport({ environment: 'dev' }) : webpackConfigExport;
    webpackConfig.mode = 'development';
    if (quiet) {
        webpackConfig.stats = 'errors-only';
    }
    if (ignoreNodeModules) {
        // It's possible that `ignored` isn't defined yet, or is a single object
        // So if needed, we create and modify objects, so they can be added to
        // (For more info: https://webpack.js.org/configuration/watch/#watchoptionsignored)
        if (!(0, checks_1.isDef)(webpackConfig.watchOptions)) {
            webpackConfig.watchOptions = {};
        }
        let directoriesToIgnore = webpackConfig.watchOptions.ignored;
        if (!(0, checks_1.isDef)(directoriesToIgnore)) {
            directoriesToIgnore = [];
        }
        if (!(0, checks_1.isArray)(directoriesToIgnore)) {
            directoriesToIgnore = [directoriesToIgnore];
        }
        directoriesToIgnore = ['**/node_modules', ...directoriesToIgnore];
        webpackConfig.watchOptions = { ...webpackConfig.watchOptions, ignored: directoriesToIgnore };
    }
    const compiler = webpack(webpackConfig);
    const watchOptions = webpackConfig.watchOptions ?? {};
    compiler.watch(watchOptions, (err, stats) => {
        console.log(stats?.toString({ colors: true }));
    });
    process.chdir(originalDirectory);
    return { name, compiler };
}
exports.watchEditorExtension = watchEditorExtension;
/**
 * Runs the editor extensions and shape libraries in debug mode, possibly including watching code for changes.
 * @param extensionNames The names of the editor extensions
 * @param quiet If true, will only show errors in output
 * @param watchIgnoreNodeModules If true, while serving, will not autoreload on changes to node_modules files
 */
async function debugEditorExtension(extensionNames, isInternal, quiet = false, pickAnyPort = false, watchIgnoreNodeModules = false) {
    const port = 9900;
    const watchers = await Promise.all(extensionNames.map(async (name) => watchEditorExtension(name, isInternal, quiet, watchIgnoreNodeModules)));
    startCustomUIServers(extensionNames);
    const app = express();
    const server = listen(app, port, pickAnyPort);
    setupWebSockets(server);
    const errorLog = new Map();
    recordErrors(watchers, errorLog);
    app.use(cors_1.corsAllowLucid);
    app.get(['/extension.js', '/editorextension/:name/extension.js'], async (req, res) => {
        const name = req.params['name'] ?? extensionNames[0];
        const directory = await getExtensionCodeDirectoryName(name);
        //Give it several seconds for the extension to finish generating before failing.
        const before = Date.now();
        const bundlePath = path.join('editorextensions', directory, 'bin', 'extension.js');
        while (!oldFs.existsSync(bundlePath) && Date.now() - before < 5000) {
            await new Promise((resolve) => setTimeout(resolve, 50));
        }
        res.send((await fs.readFile(bundlePath)).toString());
    });
    app.get(['/scopes', '/editorextension/:name/scopes'], async (req, res) => {
        const name = req.params['name'] ?? extensionNames[0];
        const manifest = await (0, packagemanifest_1.readManifest)('local');
        res.send(JSON.stringify(manifest['extensions']?.find((extension) => extension['name'] === name)?.scopes));
    });
    app.get('/packageId', async (req, res) => {
        const manifest = await (0, packagemanifest_1.readManifest)('local');
        res.send(manifest['id'] ?? '__local__');
    });
    app.get(['/editorextension', '/editorextension/:name'], async (req, res) => {
        const name = req.params['name'] ?? extensionNames[0];
        const rawExtension = await getRawEditorExtension(name, port);
        res.send(rawExtension);
    });
    app.get('/editorextensions', async (req, res) => {
        res.send(await Promise.all(extensionNames.map((name) => getRawEditorExtension(name, port))));
    });
    app.get('/settings', async (req, res) => {
        const manifest = await (0, packagemanifest_1.readManifest)('local');
        const settings = manifest.settings ?? [];
        res.send(JSON.stringify(settings.map((setting, index) => {
            return {
                'Id': '__local__' + index,
                'PackageVersionId': '__local__',
                'Name': setting.name,
                'Order': index,
                'Label': setting.label,
                'Description': setting.description,
                'DataType': setting.type,
                'DefaultValue': setting.default,
            };
        })));
    });
    app.get('/dataConnector/:name', async (req, res) => {
        const name = req.params['name'];
        if (name) {
            const manifest = await (0, packagemanifest_1.readManifest)('local');
            const connector = manifest['dataConnectors']?.find((one) => one.name === name);
            if (connector) {
                res.send(JSON.stringify(connector));
            }
            else {
                res.sendStatus(404);
            }
        }
        else {
            res.sendStatus(404);
        }
    });
    app.get('/oauthCredentials/:name', async (req, res) => {
        const name = req.params['name'];
        if (name) {
            const manifest = await (0, packagemanifest_1.readManifest)('local');
            const provider = manifest['oauthProviders']?.find((one) => one.name === name);
            if (provider && oldFs.existsSync(`${name}.credentials.local`)) {
                const credentials = JSON.parse((await fs.readFile(`${name}.credentials.local`)).toString());
                res.send(JSON.stringify({ ...provider, ...credentials }));
            }
            else {
                res.sendStatus(404);
            }
        }
        else {
            res.sendStatus(404);
        }
    });
    app.get('/manifest', async (req, res) => {
        const manifest = await (0, packagemanifest_1.readManifest)('local');
        res.send(JSON.stringify(manifest));
    });
    // iframes (modals and panels) loaded in dev mode from a string (legacy style) will redirect here to get the
    // iframe bootstrap code, so that any requests for static assets from localhost won't fail due to mixed
    // HTTPS and HTTP. But to avoid duplicating the modal-frame.html source here, we just send it in the query
    // string as part of the redirect.
    app.get('/resources/modal-frame.html', async (req, res) => {
        res.set({ 'Content-Type': 'text/html' });
        res.send(req.query['source']);
    });
    app.get('/editorextensions/errors', async (req, res) => {
        res.send(JSON.stringify(Array.from(errorLog.entries())));
    });
    // Static resources in the "public" directory of the package
    const manifest = await (0, packagemanifest_1.readManifest)('local');
    if (manifest['public']) {
        for (const url in manifest['public']) {
            const source = manifest['public'][url];
            app.use('/resources/' + url, express.static(source));
        }
    }
    app.use('/resources', express.static('public'));
}
exports.debugEditorExtension = debugEditorExtension;
function listen(app, port, pickAnyPort) {
    return app
        .listen(port, 'localhost', () => {
        console.log((0, theme_1.success)('Listening at http://localhost:' + port + '/extension.js'));
        (0, shapelibrary_1.debugShapeLibraries)(undefined, pickAnyPort);
    })
        .on('error', (err) => {
        if (err.code === 'EADDRINUSE') {
            if (pickAnyPort && port < 15000) {
                port++;
                listen(app, port, pickAnyPort);
            }
            else {
                console.error('Failed to listen for extension');
                console.error(err);
                process.exit(1);
            }
        }
    });
}
/**
 * Inform the editor that extensions need to be refreshed when watchers detect changes.
 */
function setupWebSockets(server) {
    // We use chokidar to listen for changes instead of webpacks's on compilation done hook. This is because
    // changes to the manifest or credentials file do not trigger webpack to recompile the extension.
    const sockets = [];
    const wss = new ws.Server({ server, path: '/editorExtensions/changes' });
    wss.on('connection', (ws) => sockets.push(ws));
    // Changes to a file can trigger changes in other files. We debounce all changes so that
    // we don't send multiple "refresh" messages.
    let timeout = null;
    chokidar.watch([['./']]).on('all', () => {
        if (timeout) {
            clearTimeout(timeout);
        }
        timeout = setTimeout(() => {
            for (const socket of sockets) {
                socket.send('refresh');
            }
        }, 100);
    });
}
function recordErrors(watchers, errorLog) {
    watchers.forEach((watcher) => {
        watcher.compiler.hooks.done.tap('CompilationDonePlugin', (stats) => {
            if (stats.hasErrors()) {
                errorLog.set(watcher.name, stats.toString({ all: false, colors: false, errors: true }));
            }
            else {
                errorLog.delete(watcher.name);
            }
        });
    });
}
async function getExtensionManifest(name) {
    const manifest = await (0, packagemanifest_1.readManifest)('local');
    return { manifest, extensionManifest: manifest['extensions']?.find((one) => one['name'] === name) };
}
/**
 * We allow the creation of editor extensions that use the same code as a different editor extension in the same
 * package. This is a workaround to have one extension work with multiple products. For example, one can build a
 * "google-sheets-spark" extension and then add a "google-sheets-chart" extension to the manifest.json file and enter
 * the same codePath for the chart extension as the spark extension.
 */
async function getExtensionCodeDirectoryName(name) {
    const extensionManifest = (await getExtensionManifest(name)).extensionManifest;
    const codePath = extensionManifest?.['codePath'];
    return codePath ? ((await getExtensionCodeDirectoryNameFromCodePath(codePath)) ?? name) : name;
}
/**
 * Our codePath has the form '/editorextensions/{extensionName}/bin/extension.js'. This function returns the
 * extensionName.
 */
async function getExtensionCodeDirectoryNameFromCodePath(codePath) {
    const parts = codePath.split(path.sep) ?? [];
    if (parts[0] === 'editorextensions' && parts[1]) {
        return `${parts[1]}`;
    }
    return undefined;
}
async function getRawEditorExtension(name, port) {
    const { manifest, extensionManifest } = await getExtensionManifest(name);
    const codePath = extensionManifest?.['codePath'];
    const directory = codePath ? ((await getExtensionCodeDirectoryNameFromCodePath(codePath)) ?? name) : name;
    const products = extensionManifest
        ? getExtensionProducts(extensionManifest['product'], extensionManifest['products'])
        : [supportedproduct_1.SupportedProduct.Chart];
    return {
        id: '__local__',
        packageId: manifest['id'] ?? '__local__',
        packageVersionId: '__local__',
        version: manifest['version'],
        name: name,
        title: extensionManifest?.['title'] ?? 'Local dev extension',
        products: products,
        scopes: extensionManifest?.['scopes'],
        codeUrl: `http://localhost:${port}/editorextension/${directory}/extension.js`,
    };
}
function getExtensionProducts(product, products) {
    if (products && products.length !== 0) {
        return products;
    }
    if (product) {
        return [product];
    }
    throw new Error('Either "product" or "products" must be spcified for the editor extension in the package manifest');
}
async function getAllExtensionNames() {
    const manifest = await (0, packagemanifest_1.readManifest)('local');
    if (manifest.extensions) {
        return manifest.extensions.map((extn) => extn.name);
    }
    else {
        return [];
    }
}
exports.getAllExtensionNames = getAllExtensionNames;
async function startCustomUIServers(extensionNames) {
    for (let extensionName of extensionNames) {
        const extensionCodePath = path.resolve(path.join('editorextensions', await getExtensionCodeDirectoryName(extensionName)));
        const potentialCustomUIServer = (await fs.readdir(extensionCodePath, { withFileTypes: true }))
            .filter((dirent) => dirent.isDirectory())
            .map((dirent) => path.join(extensionCodePath, dirent.name));
        for (let potentialPaths of potentialCustomUIServer) {
            runNpmStartIfExists(potentialPaths);
        }
    }
}
async function runNpmStartIfExists(directoryPath) {
    try {
        // Read the package.json file
        const packageJsonPath = path.join(directoryPath, 'package.json');
        if (oldFs.existsSync(packageJsonPath)) {
            const packageJson = await fs.readFile(packageJsonPath, 'utf-8');
            const packageData = JSON.parse(packageJson);
            // Check if package.json has "scripts" object and it contains "start"
            if (packageData && packageData.scripts && packageData.scripts.start) {
                console.log((0, theme_1.success)(`Found npm start script in ${directoryPath}.`));
                // Execute npm start
                const npmStart = (0, child_process_1.spawn)('npm', ['start'], { cwd: directoryPath, stdio: ['inherit', 'pipe', 'pipe'] });
                npmStart.stdout.on('data', (data) => {
                    process.stdout.write(data);
                });
                npmStart.stderr.on('data', (data) => {
                    process.stderr.write(data);
                });
                npmStart.on('exit', (code) => {
                    console.log(`npm start process exited with code ${code}`);
                });
            }
            else {
                console.log(`No npm start script found in ${directoryPath}.`);
            }
        }
    }
    catch (error) {
        console.error(error(`Error occurred: ${error.message}`));
    }
}
