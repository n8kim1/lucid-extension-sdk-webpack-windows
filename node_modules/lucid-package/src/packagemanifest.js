"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readManifest = exports.SettingType = void 0;
const fs = require("fs");
const fsPromises = require("fs/promises");
const lucid_extension_sdk_1 = require("lucid-extension-sdk");
const path = require("path");
const supportedproduct_1 = require("./supportedproduct");
var SettingType;
(function (SettingType) {
    SettingType["STRING"] = "string";
})(SettingType || (exports.SettingType = SettingType = {}));
const versionRegex = /^\d+\.\d+\.\d+$/;
function validateManifestOrThrow(manifest) {
    if (!(0, lucid_extension_sdk_1.isObject)(manifest)) {
        throw new Error('manifest.json must be a valid JSON object');
    }
    if ((0, lucid_extension_sdk_1.isDef)(manifest['version']) && (!(0, lucid_extension_sdk_1.isString)(manifest['version']) || !versionRegex.test(manifest['version']))) {
        throw new Error('manifest.json: "version" must be a string in the format <major>.<minor>.<patch>');
    }
    function validateUniqueNames(kindOfThings, things) {
        if (new Set(things.map((one) => one['name'])).size !== things.length) {
            throw new Error(kindOfThings + ' must have unique names');
        }
    }
    if (manifest['settings']) {
        if (!(0, lucid_extension_sdk_1.isTypedArray)(lucid_extension_sdk_1.isObject)(manifest['settings'])) {
            throw new Error('manifest.json: "settings" must be an array of objects');
        }
        validateUniqueNames('settings', manifest['settings']);
        for (const setting of manifest['settings']) {
            if (!(0, lucid_extension_sdk_1.isString)(setting['name'])) {
                throw new Error('manifest.json: setting "name" must be a string');
            }
            if (!(0, lucid_extension_sdk_1.isString)(setting['label'])) {
                throw new Error('manifest.json: setting "label" must be a string');
            }
            if (!(0, lucid_extension_sdk_1.isString)(setting['description'])) {
                throw new Error('manifest.json: setting "description" must be a string');
            }
            if (!(0, lucid_extension_sdk_1.enumValidator)(SettingType)(setting['type'])) {
                throw new Error('manifest.json: setting "type" must be "string"');
            }
            if ((0, lucid_extension_sdk_1.isDef)(setting['default'])) {
                if (setting['type'] === SettingType.STRING) {
                    if (!(0, lucid_extension_sdk_1.isString)(setting['default'])) {
                        throw new Error('manifest.json: setting "default" must be of the type specified for the setting');
                    }
                }
                else {
                    throw new Error('manifest.json: unsupported setting type');
                }
            }
        }
    }
    if (manifest['extensions']) {
        if (!(0, lucid_extension_sdk_1.isTypedArray)(lucid_extension_sdk_1.isObject)(manifest['extensions'])) {
            throw new Error('manifest.json: "extensions" must be an array of objects');
        }
        validateUniqueNames('extensions', manifest['extensions']);
        for (const extension of manifest['extensions']) {
            if (!(0, lucid_extension_sdk_1.isString)(extension['name'])) {
                throw new Error('manifest.json: extension "name" must be a string');
            }
            if (!(0, lucid_extension_sdk_1.isString)(extension['title'])) {
                throw new Error('manifest.json: extension "title" must be a string');
            }
            if (!(0, lucid_extension_sdk_1.isString)(extension['codePath'])) {
                throw new Error('manifest.json: extension "codePath" must be a string');
            }
            if (!(0, lucid_extension_sdk_1.isTypedArray)(lucid_extension_sdk_1.isString)(extension['scopes'])) {
                throw new Error('manifest.json: extension "scopes" must be a string array');
            }
            if ((extension['product'] && extension['products']) ||
                (!(0, lucid_extension_sdk_1.isDef)(extension['product']) && !(0, lucid_extension_sdk_1.isDef)(extension['products']))) {
                throw new Error('either the "product" or "products" field must be specified and not both');
            }
            const supportedProducts = Object.values(supportedproduct_1.SupportedProduct);
            if (extension['product']) {
                if (!(0, lucid_extension_sdk_1.enumValidator)(supportedproduct_1.SupportedProduct)(extension['product'])) {
                    throw new Error(`manifest.json: found ${extension['product']}. extension "product" must be one of ${supportedProducts}`);
                }
            }
            if (extension['products']) {
                if (!(0, lucid_extension_sdk_1.isTypedArray)((0, lucid_extension_sdk_1.enumValidator)(supportedproduct_1.SupportedProduct))(extension['products']) ||
                    extension['products'].length === 0) {
                    throw new Error(`manifest.json: found ${extension['products']}. extension "products" must be an array containing values from ${supportedProducts}`);
                }
            }
        }
    }
    if (manifest['shapeLibraries']) {
        if (!(0, lucid_extension_sdk_1.isTypedArray)(lucid_extension_sdk_1.isObject)(manifest['shapeLibraries'])) {
            throw new Error('manifest.json: "shapeLibraries" must be an array of objects');
        }
        validateUniqueNames('shapeLibraries', manifest['shapeLibraries']);
        for (const shapeLibrary of manifest['shapeLibraries']) {
            if (!(0, lucid_extension_sdk_1.isString)(shapeLibrary['name'])) {
                throw new Error('manifest.json: shape library "name" must be a string');
            }
            if (!(0, lucid_extension_sdk_1.isString)(shapeLibrary['lcszPath'])) {
                throw new Error('manifest.json: shape library "lcszPath" must be a string');
            }
            if (shapeLibrary['product'] !== 'chart' && shapeLibrary['product'] !== 'spark') {
                throw new Error('manifest.json: shape library "product" must be "chart" or "spark"');
            }
        }
    }
    if (manifest['oauthProviders']) {
        if (!(0, lucid_extension_sdk_1.isTypedArray)(lucid_extension_sdk_1.isObject)(manifest['oauthProviders'])) {
            throw new Error('manifest.json: "oauthProviders" must be an array of objects');
        }
        validateUniqueNames('oauthProviders', manifest['oauthProviders']);
        for (const provider of manifest['oauthProviders']) {
            if (!(0, lucid_extension_sdk_1.isString)(provider['name'])) {
                throw new Error('manifest.json: OAuth provider "name" must be a string');
            }
            if (!(0, lucid_extension_sdk_1.isString)(provider['title'])) {
                throw new Error('manifest.json: OAuth provider "title" must be a string');
            }
            if (provider['grantType'] &&
                provider['grantType'] !== 'authorizationCode' &&
                provider['grantType'] !== 'clientCredentials') {
                throw new Error('manifest.json: OAuth provider "grantType" must be "authorizationCode" or "clientCredentials"');
            }
            if (provider['grantType'] === 'authorizationCode' && !(0, lucid_extension_sdk_1.isString)(provider['authorizationUrl'])) {
                throw new Error('manifest.json: OAuth provider "authorizationUrl" must be a string');
            }
            if (provider['grantType'] === 'clientCredentials' && provider['authorizationUrl']) {
                throw new Error('manifest.json: OAuth provider "authorizationUrl" must not be provided when grantType is "clientCredentials"');
            }
            if (provider['grantType'] === 'clientCredentials' && provider['usePkce']) {
                throw new Error('manifest.json: OAuth provider "usePkce" must not be provided when grantType is "clientCredentials"');
            }
            if (!(0, lucid_extension_sdk_1.isString)(provider['tokenUrl'])) {
                throw new Error('manifest.json: OAuth provider "tokenUrl" must be a string');
            }
            if (provider['refreshTokenUrl'] && !(0, lucid_extension_sdk_1.isString)(provider['refreshTokenUrl'])) {
                throw new Error('manifest.json: OAuth provider "refreshTokenUrl" must be a string');
            }
            if (!(0, lucid_extension_sdk_1.isTypedArray)(lucid_extension_sdk_1.isString)(provider['scopes'])) {
                throw new Error('manifest.json: OAuth provider "scopes" must be a string array');
            }
            if (!(0, lucid_extension_sdk_1.isTypedArray)(lucid_extension_sdk_1.isString)(provider['domainWhitelist'])) {
                throw new Error('manifest.json: OAuth provider "domainWhitelist" must be a string array');
            }
            if (provider['clientAuthentication'] !== 'basic' &&
                provider['clientAuthentication'] !== 'clientParameters') {
                throw new Error('manifest.json: OAuth provider "clientAuthentication" must be "basic" or "clientParameters"');
            }
            if (provider['faviconUrl']) {
                if (!(0, lucid_extension_sdk_1.isString)(provider['faviconUrl'])) {
                    throw new Error('manifest.json: faviconUrl must be a string');
                }
            }
        }
    }
    if (manifest['mergeProviders']) {
        if (!(0, lucid_extension_sdk_1.isTypedArray)(lucid_extension_sdk_1.isObject)(manifest['mergeProviders'])) {
            throw new Error('manifest.json: "mergeProviders" must be an array of objects');
        }
        validateUniqueNames('mergeProviders', manifest['mergeProviders']);
        for (const provider of manifest['mergeProviders']) {
            if (!(0, lucid_extension_sdk_1.isString)(provider['name'])) {
                throw new Error('manifest.json: Merge provider "name" must be a string');
            }
            if (!(0, lucid_extension_sdk_1.isString)(provider['title'])) {
                throw new Error('manifest.json: Merge provider "title" must be a string');
            }
            if (!(0, lucid_extension_sdk_1.isTypedArray)(lucid_extension_sdk_1.isString)(provider['categories'])) {
                throw new Error('manifest.json: Merge provider "categories" must be a string array');
            }
            if (provider['integration'] && !(0, lucid_extension_sdk_1.isString)(provider['integration'])) {
                throw new Error('manifest.json: Merge provider "integration" must be a string');
            }
        }
    }
    if ((0, lucid_extension_sdk_1.isTypedArray)(lucid_extension_sdk_1.isObject)(manifest['mergeProviders']) && (0, lucid_extension_sdk_1.isTypedArray)(lucid_extension_sdk_1.isObject)(manifest['oauthProviders'])) {
        validateUniqueNames('mergeProviders & oauthProviders', manifest['mergeProviders'].concat(manifest['oauthProviders']));
    }
    if (manifest['dataConnectors']) {
        if (!(0, lucid_extension_sdk_1.isTypedArray)(lucid_extension_sdk_1.isObject)(manifest['dataConnectors'])) {
            throw new Error('manifest.json: "dataConnectors" must be an array of objects');
        }
        validateUniqueNames('dataConnectors', manifest['dataConnectors']);
        for (const provider of manifest['dataConnectors']) {
            if (!(0, lucid_extension_sdk_1.isString)(provider['name'])) {
                throw new Error('manifest.json: Data connector "name" must be a string');
            }
            if (!(0, lucid_extension_sdk_1.isString)(provider['oauthProviderName'])) {
                throw new Error('manifest.json: Data connector "oauthProviderName" must be a string');
            }
            if (!(0, lucid_extension_sdk_1.isString)(provider['callbackBaseUrl'])) {
                throw new Error('manifest.json: Data connector "callbackBaseUrl" must be a string');
            }
            if (!(0, lucid_extension_sdk_1.isRecord)(lucid_extension_sdk_1.isString)(provider['dataActions'])) {
                throw new Error('manifest.json: Data connector "dataActions" must be a record from strings to strings');
            }
        }
    }
    if (manifest['public']) {
        if (!(0, lucid_extension_sdk_1.objectOfValidator)(lucid_extension_sdk_1.isString)(manifest['public'])) {
            throw new Error('manifest.json: "public" must be an object of strings');
        }
    }
}
function deepMixin(target, mixin) {
    if ((0, lucid_extension_sdk_1.isArray)(target) && (0, lucid_extension_sdk_1.isArray)(mixin)) {
        for (let i = 0; i < mixin.length; i++) {
            const value = mixin[i];
            if (i >= target.length) {
                target[i] = value;
            }
            else if ((0, lucid_extension_sdk_1.isObject)(value) || (0, lucid_extension_sdk_1.isArray)(value)) {
                deepMixin(target[i], value);
            }
            else {
                target[i] = value;
            }
        }
    }
    else if ((0, lucid_extension_sdk_1.isObject)(target) && (0, lucid_extension_sdk_1.isObject)(mixin)) {
        for (var key in mixin) {
            const value = mixin[key];
            if ((0, lucid_extension_sdk_1.isObject)(value) || (0, lucid_extension_sdk_1.isArray)(value)) {
                deepMixin(target[key], value);
            }
            else {
                target[key] = value;
            }
        }
    }
}
/**
 * @param manifestOverrideEnv The environment to override the manifest with
 * @param basePath The path to read the manifest from
 */
async function readManifest(manifestOverrideEnv, basePath = '.') {
    const raw = JSON.parse((await fsPromises.readFile(path.join(basePath, 'manifest.json'))).toString());
    if (manifestOverrideEnv) {
        const manifestOverridePath = path.join(basePath, `manifest.${manifestOverrideEnv}.json`);
        try {
            const overrides = JSON.parse((await fsPromises.readFile(manifestOverridePath)).toString());
            deepMixin(raw, overrides);
        }
        catch (e) {
            if (manifestOverrideEnv == 'local') {
                // Warn if the file exists (this means it's invalid), otherwise fail silently
                if (fs.existsSync(manifestOverridePath)) {
                    console.warn('Local manifest overrides could not be applied', e);
                }
            }
            else {
                throw new Error(`Missing or malformated \"manifest.${manifestOverrideEnv}.json\". Please create and run the command again.`);
            }
        }
    }
    validateManifestOrThrow(raw);
    return raw;
}
exports.readManifest = readManifest;
