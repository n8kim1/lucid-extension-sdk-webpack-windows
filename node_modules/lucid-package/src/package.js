"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writePackage = exports.updateAllExtensionSDK = exports.modifyManifest = exports.readJson = exports.currentlyInPackage = exports.createEmptyPackage = void 0;
const fsOld = require("fs");
const fs = require("fs/promises");
const JSZip = require("jszip");
const lucid_extension_sdk_1 = require("lucid-extension-sdk");
const path = require("path");
const editorextension_1 = require("./editorextension");
const filesystemutil_1 = require("./filesystemutil");
const packagemanifest_1 = require("./packagemanifest");
const shapelibrary_1 = require("./shapelibrary");
const shellutil_1 = require("./shellutil");
const theme_1 = require("./theme");
async function createEmptyPackage(root) {
    console.log((0, theme_1.success)('Creating Lucid Suite package in ' + root));
    const source = path.join(__dirname, '..', 'templates', 'package');
    (0, filesystemutil_1.copyFolderRecursiveSync)(source, root);
}
exports.createEmptyPackage = createEmptyPackage;
function currentlyInPackage() {
    return ((fsOld.existsSync('editorextensions') || fsOld.existsSync('shapelibraries')) &&
        fsOld.existsSync('manifest.json'));
}
exports.currentlyInPackage = currentlyInPackage;
async function readJson(path) {
    return JSON.parse(await fs.readFile(path, 'utf8'));
}
exports.readJson = readJson;
const allScopes = new Set([
    'DOWNLOAD',
    'NETWORK',
    'READ',
    'SHOW_MODAL',
    'CUSTOM_UI',
    'WRITE',
    'USER_INFO',
    'OAUTH_TOKEN',
]);
const uuidRegex = /^[a-f\d]{8}-[a-f\d]{4}-[a-f\d]{4}-[a-f\d]{4}-[a-f\d]{12}$/i;
async function modifyManifest(callback, manifestOverrideEnv) {
    const manifest = await (0, packagemanifest_1.readManifest)(manifestOverrideEnv);
    await callback(manifest);
    await fs.writeFile('manifest.json', JSON.stringify(manifest, undefined, 2));
}
exports.modifyManifest = modifyManifest;
async function updateAllExtensionSDK() {
    const manifest = await (0, packagemanifest_1.readManifest)();
    for (const extension of manifest['extensions'] || []) {
        const parts = extension['codePath'].split(path.sep);
        if (parts[0] === 'editorextensions') {
            await (0, editorextension_1.updateExtensionSDK)(parts[1]);
        }
    }
}
exports.updateAllExtensionSDK = updateAllExtensionSDK;
/**
 *
 * @param manifestOverrideEnv The environment definine what manifest to read from. `manifest.env.json`
 */
async function writePackage(quiet = false, manifestOverrideEnv, skipSdkDependency = false) {
    const zip = new JSZip();
    const quietableConsoleLog = (...data) => {
        if (!quiet) {
            console.log(data);
        }
    };
    //Increment the patch number automatically on each build
    await modifyManifest(async (manifest) => {
        if (manifest['id'] !== undefined && (!(0, lucid_extension_sdk_1.isString)(manifest['id']) || !uuidRegex.test(manifest['id']))) {
            throw new Error('manifest.json: If "id" is specified, must be a UUID matching the package ID from the Lucid developer portal');
        }
        if (manifest['version']) {
            const parts = manifest['version'].split('.');
            parts[parts.length - 1] = String(parseInt(parts[parts.length - 1], 10) + 1);
            manifest['version'] = parts.join('.');
        }
        //For each extension, compile it and add it to the archive
        for (const extension of manifest['extensions'] || []) {
            //Check that the scopes are valid
            if (!extension['scopes'].every((one) => allScopes.has(one))) {
                console.error(`Invalid scope specified for extension ${extension['name']}: ${extension['scopes']
                    .filter((one) => !allScopes.has(one))
                    .join(', ')}`);
                process.exit(1);
            }
            const parts = extension['codePath'].split(path.sep);
            if (parts[0] === 'editorextensions') {
                //Can't just call the method, as the WebpackCLI class does process.exit(2) :facepalm:
                quietableConsoleLog((0, theme_1.success)(`Compiling editor extension ${parts[1]}`));
                // Quotes are needed around every use of a path to deal with spaces
                const cmd = '"' +
                    process.argv[0] +
                    '" "' +
                    process.argv[1] +
                    '" build-editor-extension ' +
                    (quiet ? '--quiet ' : '') +
                    (skipSdkDependency ? '--skip-sdk ' : '') +
                    '"' +
                    parts[1] +
                    '"';
                quietableConsoleLog(cmd);
                quietableConsoleLog((0, shellutil_1.execSyncLoggingOutputOnError)(cmd, (quiet = quiet)).toString());
            }
            zip.file(extension['codePath'], await fs.readFile(extension['codePath']));
        }
        //Do the same for each shape library
        for (const library of manifest['shapeLibraries'] || []) {
            const parts = library['lcszPath'].split(path.sep);
            if (parts[0] === 'shapelibraries') {
                quietableConsoleLog((0, theme_1.success)(`Building shape library ${parts[1]}`));
                await (0, shapelibrary_1.buildShapeLibrary)(parts[1].replace('.lcsz', ''), quiet);
            }
            zip.file(library['lcszPath'], await fs.readFile(library['lcszPath']));
        }
        //Add any static resources
        const checkDirForResources = async (directory, zipDirectory) => {
            if (!fsOld.existsSync(directory)) {
                return;
            }
            for (const fileName of await fs.readdir(directory)) {
                const filePath = path.join(directory, fileName);
                const stat = await fs.stat(filePath);
                if (stat.isFile()) {
                    let zipPath = filePath;
                    if (zipDirectory != null) {
                        zipPath = zipDirectory + filePath.substring(directory.length);
                    }
                    const normalizedZipPath = (0, filesystemutil_1.getNormalizedZipPath)(zipPath);
                    quietableConsoleLog('Adding resource file: ' + filePath + ' -> ' + normalizedZipPath);
                    zip.file(normalizedZipPath, await fs.readFile(filePath));
                }
                else if (stat.isDirectory()) {
                    await checkDirForResources(filePath, zipDirectory ? path.join(zipDirectory, fileName) : undefined);
                }
            }
        };
        await checkDirForResources('public');
        if (manifest['public']) {
            for (const url in manifest['public']) {
                const source = manifest['public'][url];
                await checkDirForResources(source, path.join('public', url));
            }
        }
        //Add the manifest itself
        zip.file('manifest.json', JSON.stringify(manifest, undefined, 2));
        //Write out the zip file
        const zipBytes = await zip.generateAsync({
            type: 'uint8array',
            compression: 'DEFLATE',
            compressionOptions: { level: 9 },
        });
        quietableConsoleLog((0, theme_1.success)('Writing file package.zip'));
        const fileName = `package${manifestOverrideEnv ? `-${manifestOverrideEnv}` : ''}.zip`;
        await fs.writeFile(fileName, zipBytes);
    }, manifestOverrideEnv);
}
exports.writePackage = writePackage;
