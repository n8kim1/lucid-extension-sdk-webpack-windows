"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.debugShapeLibraries = exports.buildShapeLibrary = exports.getShapeListJson = exports.createImageShapeLibrary = exports.createEmptyShapeLibrary = void 0;
const express = require("express");
const fsSync = require("fs");
const fs = require("fs/promises");
const JSZip = require("jszip");
const path = require("path");
const cors_1 = require("./cors");
const filesystemutil_1 = require("./filesystemutil");
const package_1 = require("./package");
const packagemanifest_1 = require("./packagemanifest");
const theme_1 = require("./theme");
const hjson = require('hjson');
const ws = require('ws');
const chokidar = require('chokidar');
const sizeOf = require('image-size');
async function createEmptyShapeLibrary(name) {
    const source = path.join(__dirname, '..', 'templates', 'shapelibrary');
    const targetFolder = path.join('shapelibraries', name);
    console.log((0, theme_1.success)('Creating shape library in ' + targetFolder));
    (0, filesystemutil_1.copyFolderRecursiveSync)(source, targetFolder);
    await (0, package_1.modifyManifest)((manifest) => {
        if (!manifest['shapeLibraries']) {
            manifest['shapeLibraries'] = [];
        }
        manifest['shapeLibraries'].push({
            'name': name,
            'product': 'chart',
            'lcszPath': path.join('shapelibraries', `${name}.lcsz`),
        });
    });
}
exports.createEmptyShapeLibrary = createEmptyShapeLibrary;
async function createImageShapeLibrary(name, imagePath, config) {
    console.log((0, theme_1.success)('Creating image shape library in ' + path.join('shapelibraries', name)));
    if (!fsSync.lstatSync(imagePath).isDirectory()) {
        console.error('The provided path `' + imagePath + '` is not a folder');
        return;
    }
    const imageFolder = path.join('shapelibraries', name, 'images');
    const shapeFolder = path.join('shapelibraries', name, 'shapes');
    const shapes = [];
    if (!fsSync.existsSync(imageFolder)) {
        fsSync.mkdirSync(imageFolder, { recursive: true });
    }
    if (!fsSync.existsSync(shapeFolder)) {
        fsSync.mkdirSync(shapeFolder, { recursive: true });
    }
    const files = fsSync.readdirSync(imagePath);
    files.forEach((file) => {
        var curSource = path.join(imagePath, file);
        const fileName = file.replace(/\.[^/.]+$/, '');
        // read image
        var dimen = { width: 160, height: 160 };
        if (!config.width || !config.height) {
            try {
                dimen = sizeOf(curSource);
                console.log('dimen of ' + file + ': ' + dimen + ' - ' + JSON.stringify(dimen));
            }
            catch (e) {
                console.log((0, theme_1.error)('No dimensions found for ' + file));
            }
        }
        const lockedArray = [];
        if (config.lockAspect) {
            lockedArray.push('aspectRatio');
        }
        const manifestShape = {
            shape: fileName,
            name: fileName,
            defaults: {
                width: dimen.width,
                height: dimen.height,
                strokeWidth: 0,
                rounding: 0,
            },
        };
        shapes.push(manifestShape);
        // create shape file
        const shapeFile = {
            locked: lockedArray,
            images: {
                imageReference: {
                    path: file,
                    type: 'file',
                },
            },
            geometry: [
                {
                    type: 'rect',
                },
            ],
            style: {
                fill: {
                    type: 'image',
                    ref: 'imageReference',
                    mode: 'stretch',
                },
            },
        };
        fsSync.writeFileSync(path.join(shapeFolder, fileName) + '.shape', JSON.stringify(shapeFile, undefined, 2));
        // copy image
        console.log(`Copying ${curSource} to ${path.join(imageFolder, file)}`);
        (0, filesystemutil_1.copyFileSync)(curSource, path.join(imageFolder, file));
    });
    const manifest = {
        'name': name,
        'shapes': shapes,
    };
    fsSync.writeFileSync(path.join('shapelibraries', name, 'library.manifest'), JSON.stringify(manifest, undefined, 2));
    // update extension manifest
    await (0, package_1.modifyManifest)((manifest) => {
        if (!manifest['shapeLibraries']) {
            manifest['shapeLibraries'] = [];
        }
        if (!manifest['shapeLibraries'].some((x) => x.name == name)) {
            manifest['shapeLibraries'].push({
                'name': name,
                'product': 'chart',
                'lcszPath': path.join('shapelibraries', `${name}.lcsz`),
            });
        }
    });
}
exports.createImageShapeLibrary = createImageShapeLibrary;
const defaultNameMap = new Map([
    ['rounding', 'Rounding'],
    ['fillColor', 'FillColor'],
    ['strokeColor', 'LineColor'],
    ['strokeWidth', 'LineWidth'],
    ['opacity', 'Opacity'],
    ['rotation', 'Rotation'],
    ['aspectRatio', 'AspectRatio'],
    ['link', 'Link'],
]);
//Produce JSON equivalent to the document service's
// /shapeLibraries/:name/shapes endpoint
async function getShapeListJson(name, packagePath, port = 9901) {
    const packageManifest = await (0, packagemanifest_1.readManifest)('local', packagePath);
    const manifestPath = path.join(packagePath, 'shapelibraries', name, 'library.manifest');
    const rawManifest = await fs.readFile(manifestPath);
    const manifest = hjson.parse(rawManifest.toString());
    const usedNames = new Set(manifest['shapes'].map((shape) => shape['key']).filter((key) => key !== undefined));
    return JSON.stringify(await Promise.all(manifest['shapes'].map(async (shapeManifest, index) => {
        const shapeDataPath = path.join(packagePath, 'shapelibraries', name, 'shapes', `${shapeManifest['shape']}.shape`);
        const rawShapeData = await fs.readFile(shapeDataPath);
        const shapeData = hjson.parse(rawShapeData.toString());
        let shapeName = shapeManifest['key'];
        if (shapeName === undefined) {
            shapeName = shapeManifest['shape'];
            let suffixNumber = 1;
            while (usedNames.has(shapeName)) {
                suffixNumber++;
                shapeName = shapeManifest['shape'] + '_' + suffixNumber;
            }
            usedNames.add(shapeName);
        }
        const properties = {
            'Base': { 'x': shapeManifest['defaults']['width'] / 2, 'y': shapeManifest['defaults']['height'] / 2 },
            'BoundingBox': {
                'x': 0,
                'y': 0,
                'w': shapeManifest['defaults']['width'],
                'h': shapeManifest['defaults']['height'],
            },
            'DefaultSize': {
                'w': shapeManifest['defaults']['width'],
                'h': shapeManifest['defaults']['height'],
            },
            'Stencil': {
                'lcszVersion': '1',
                'name': shapeName,
                'i18n': {},
                'locked': shapeData['locked'],
                'sourcePackage': {
                    'packageId': packageManifest['id'] ?? '__local__',
                    'version': packageManifest['version'],
                    'library': name,
                    'shape': shapeManifest['shape'],
                    'name': shapeName,
                },
            },
        };
        //Property type enum is case-insensitive during upload; replicate that here
        if (shapeData['properties']) {
            for (const property of shapeData['properties']) {
                if (typeof property['type'] == 'string') {
                    property['type'] = property['type'].toLowerCase();
                }
            }
        }
        for (var key in shapeData) {
            properties['Stencil'][key] = shapeData[key];
        }
        const imageMap = properties['Stencil']['images'];
        if (imageMap) {
            const finalImageMap = {};
            for (const key in imageMap) {
                if (imageMap[key]['type'] == 'url') {
                    finalImageMap[key] = imageMap[key]['path'];
                }
                else if (imageMap[key]['type'] == 'file') {
                    finalImageMap[key] =
                        `http://localhost:${port}/shapeLibraries/` +
                            encodeURIComponent(name) +
                            '/images/' +
                            encodeURIComponent(imageMap[key]['path']);
                }
            }
            properties['Stencil']['images'] = finalImageMap;
        }
        for (var key in shapeManifest['defaults']) {
            if (key !== 'width' && key !== 'height') {
                const outName = defaultNameMap.get(key) ?? key;
                properties[outName] = shapeManifest['defaults'][key];
            }
        }
        if (shapeData['locked']?.includes('aspectRatio') && !properties['AspectRatio']) {
            properties['AspectRatio'] =
                shapeManifest['defaults']['width'] / shapeManifest['defaults']['height'] ?? 1;
        }
        return {
            'class': 'CustomBlock',
            'created': new Date().toISOString(),
            'name': shapeManifest['name'],
            'order': index,
            'properties': JSON.stringify(properties),
            'shapeLibrary': `http://localhost:${port}/shapeLibraries/` + encodeURIComponent(name),
            'uri': `http://localhost:${port}/shapeLibraries/${encodeURIComponent(name)}/shapes/${encodeURIComponent(shapeName)}`,
        };
    })));
}
exports.getShapeListJson = getShapeListJson;
async function buildShapeLibrary(name, quiet) {
    const zip = new JSZip();
    const addToZip = async (source) => {
        if (!quiet) {
            console.log(source);
        }
        const stat = await fs.lstat(source);
        if (stat.isDirectory()) {
            const dir = await fs.readdir(source);
            for (const file of dir) {
                await addToZip(path.join(source, file));
            }
        }
        else {
            const normalizedSource = (0, filesystemutil_1.getNormalizedZipPath)(source);
            zip.file(normalizedSource.replace(`shapelibraries/${name}/`, ''), await fs.readFile(source));
        }
    };
    await addToZip(`shapelibraries/${name}`);
    const zipBytes = await zip.generateAsync({ type: 'uint8array' });
    if (!quiet) {
        console.log((0, theme_1.success)(`Writing file ${name}.lcsz`));
    }
    await fs.writeFile(`shapelibraries/${name}.lcsz`, zipBytes);
}
exports.buildShapeLibrary = buildShapeLibrary;
async function debugShapeLibraries(packagePath = '.', pickAnyPort = false) {
    let port = 9901;
    const app = express();
    app.use(cors_1.corsAllowLucid);
    //Having a version number on the shape library URL that changes each time the user updates the code
    //allows us to refresh the toolbox in the editor mid-editor-session. Unless the URL changes for the
    //shape library, the toolbox doesn't update.
    let shapeLibraryVersion = Date.now();
    app.get('/shapeLibraries', async (req, res) => {
        const manifest = await (0, packagemanifest_1.readManifest)('local', packagePath);
        const libraries = manifest['shapeLibraries'] ?? [];
        const output = await Promise.all(libraries.map(async (libraryManifest) => {
            const libraryDefinitionContent = await fs.readFile(path.join(packagePath, 'shapelibraries', libraryManifest['name'], 'library.manifest'));
            const libraryDefinition = JSON.parse(libraryDefinitionContent.toString());
            return {
                'uri': `http://localhost:${port}/shapeLibraries/` +
                    encodeURIComponent(libraryManifest['name']) +
                    '?version=' +
                    shapeLibraryVersion,
                'user': '',
                'created': new Date().toISOString(),
                'name': libraryDefinition['name'],
                'size': 0,
                'accountId': 0,
                'shapes': `http://localhost:${port}/shapeLibraries/` +
                    encodeURIComponent(libraryManifest['name']) +
                    '/shapes',
                'encryption': '',
            };
        }));
        res.send(JSON.stringify(output));
    });
    app.get('/shapeLibraries/:libraryName/shapes', async (req, res) => {
        //Find all the shapes in the given shape library, and produce JSON for the client
        res.send(await getShapeListJson(req.params.libraryName, packagePath, port));
    });
    app.get('/shapeLibraries/:libraryName/images/:image', async (req, res) => {
        const oldcwd = process.cwd();
        process.chdir(packagePath);
        //Find all the shapes in the given shape library, and produce JSON for the client
        res.sendFile(path.join('shapelibraries', req.params.libraryName, 'images', req.params.image), {
            root: process.cwd(),
        });
        process.chdir(oldcwd);
    });
    app.get('/shapeLibraries/');
    app.get('/manifest', async (req, res) => {
        const packageManifest = await (0, packagemanifest_1.readManifest)('local', packagePath);
        res.send(JSON.stringify(packageManifest));
    });
    const listen = () => {
        const server = app.listen(port, 'localhost', () => {
            console.log((0, theme_1.success)('Listening at http://localhost:' + port + '/shapeLibraries'));
            //Watch for any shape library changes, and inform watchers that they need to refresh them.
            const wss = new ws.Server({ server, path: '/shapeLibraries/changes' });
            const sockets = [];
            wss.on('connection', (ws) => {
                sockets.push(ws);
            });
            chokidar.watch(path.join(packagePath, 'shapelibraries')).on('all', () => {
                shapeLibraryVersion = Date.now();
                for (const socket of sockets) {
                    socket.send('refresh');
                }
            });
        });
        server.on('error', (err) => {
            if (err.code === 'EADDRINUSE') {
                if (pickAnyPort && port < 15000) {
                    port++;
                    listen();
                }
                else {
                    console.error('Failed to listen for shapes');
                    console.error(err);
                    process.exit(1);
                }
            }
        });
    };
    listen();
}
exports.debugShapeLibraries = debugShapeLibraries;
