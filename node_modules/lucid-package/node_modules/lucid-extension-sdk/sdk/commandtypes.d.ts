import { SerializedFieldTypeDefinition } from './core/data/fieldtypedefinition/fieldtypedefinition';
import { SerializedReferenceKeyType } from './core/data/referencekeys/serializedreferencekey';
import { SerializedFieldType } from './core/data/serializedfield/serializedfields';
import { JsonObject, JsonSerializable } from './core/jsonserializable';
import { LucidProduct } from './core/lucidproduct';
import { LinearOffsetType } from './core/offsettype';
import { SerializedDataError } from './core/serializeddataerror';
import { ShapeDataInheritance } from './core/shapedatainheritance';
import { DocumentElementType } from './document/documentelement/documentelementtype';
import { SerializedLineTextAreaPositioning } from './document/linetextareapositioning';
import { Box, Point } from './math';
import { MenuLocation, MenuType } from './ui/menu';
import { PanelLocation } from './ui/panel';
/**
 * The lucid-extension-sdk library interacts with core Lucid products through this set of possible commands.
 * Typically, an extension author will not need to access any of these commands directly, as they are all
 * exposed through appropriate classes and methods elsewhere in this SDK.
 *
 * To use these directly, use [EditorClient.sendCommand](#classes_editorclient-EditorClient_sendcommand).
 */
export declare const enum CommandName {
    AddCardIntegration = "aci",
    AddLineTextArea = "alta",
    AddMenuItem = "ami",
    AddShapeData = "asd",
    Alert = "a",
    AnimateViewport = "av",
    AwaitImport = "ai",
    Bootstrap = "b",
    CancelDragBlockToCanvas = "cdc",
    CanEditPackageSettings = "ceps",
    Confirm = "c",
    CreateBlock = "cb",
    CreateCollection = "cc",
    CreateDataSource = "cds",
    CreateLine = "cl",
    CreatePage = "cp",
    CreateUserImage = "cui",
    DataAction = "da",
    DataItemExists = "die",
    DeleteItem = "di",
    DeletePage = "dp",
    DeleteShapeData = "dsd",
    Download = "d",
    DragPointerMove = "dpm",
    DragPointerUp = "dpu",
    ElementExists = "ee",
    ExecuteFormula = "ef",
    GetConnectedLines = "gcl",
    GetCurrentPage = "gcp",
    GetCustomShape = "gcs",
    GetDataItemField = "gdif",
    GetElementType = "get",
    GetItemPageId = "gip",
    GetPackageSettings = "gps",
    GetProduct = "gpr",
    GetProperty = "gp",
    GetReferenceKey = "grk",
    GetRelativeLinePosition = "grlp",
    GetSelection = "gs",
    GetShapeData = "gsd",
    HideModal = "hm",
    HidePanel = "hp",
    HookCreateItems = "hci",
    HookDeleteItems = "hdi",
    HookSelection = "hs",
    HookTextEdit = "hte",
    ImportCards = "ic",
    KillExtension = "k",
    ListBlocks = "lb",
    ListCollectionFields = "lcf",
    ListCollections = "lc",
    ListDataItems = "ldi",
    ListDataSources = "lds",
    ListDocumentElements = "lde",
    ListGroups = "lg",
    ListLines = "ll",
    ListPages = "lp",
    ListProperties = "lpr",
    ListReferenceKeys = "lrk",
    ListShapeData = "lsd",
    ListTextAreas = "lta",
    LoadBlockClasses = "lbc",
    LogForTestCase = "log",
    OffsetItems = "oi",
    PatchDataItems = "pdi",
    RegisterPanel = "rp",
    RegisterUnfurl = "ru",
    ReloadExtension = "r",
    SendOAuthRequest = "oauth",
    SendPermanentTokenRequest = "perm",
    SendUIMessage = "suim",
    SendXHR = "xhr",
    SetCurrentPage = "scp",
    SetProperty = "sp",
    SetReferenceKey = "srk",
    SetShapeData = "ssd",
    SetText = "st",
    ShowModal = "sm",
    ShowPanel = "spn",
    ShowPackageSettingsModal = "spsm",
    SleepForTestCase = "sleep",
    StartDragBlockToCanvas = "sdc",
    StartPDFUploadRequest = "pdf",
    ThrowForTestCase = "throw",
    UnhookCreateItems = "uci",
    UnhookDeleteItems = "udi",
    UnhookSelection = "us",
    UnhookTextEdit = "ute"
}
/** @ignore */
export declare const commandTitles: Map<CommandName, string>;
/**
 * This is a type declaration whose purpose is to allow TypeScript to enforce the correct parameter and
 * return types from [EditorClient.sendCommand](#classes_editorclient-EditorClient_sendcommand) based on
 * which command name you pass in as the first parameter.
 */
export declare type CommandArgs = {
    [CommandName.AddCardIntegration]: {
        query: AddCardIntegrationQuery;
        result: AddCardIntegrationResult;
    };
    [CommandName.AddLineTextArea]: {
        query: AddLineTextAreaQuery;
        result: AddLineTextAreaResult;
    };
    [CommandName.AddMenuItem]: {
        query: AddMenuItemQuery;
        result: AddMenuItemResult;
    };
    [CommandName.AddShapeData]: {
        query: AddShapeDataQuery;
        result: AddShapeDataResult;
    };
    [CommandName.Alert]: {
        query: AlertQuery;
        result: AlertResult;
    };
    [CommandName.AnimateViewport]: {
        query: AnimateViewportQuery;
        result: AnimateViewportResult;
    };
    [CommandName.AwaitImport]: {
        query: AwaitImportQuery;
        result: AwaitImportResult;
    };
    [CommandName.Bootstrap]: {
        query: BootstrapQuery;
        result: BootstrapResult;
    };
    [CommandName.CanEditPackageSettings]: {
        query: CanEditPackageSettingsQuery;
        result: CanEditPackageSettingsResult;
    };
    [CommandName.CancelDragBlockToCanvas]: {
        query: CancelDragBlockToCanvasQuery;
        result: CancelDragBlockToCanvasResult;
    };
    [CommandName.Confirm]: {
        query: ConfirmQuery;
        result: ConfirmResult;
    };
    [CommandName.CreateBlock]: {
        query: CreateBlockQuery;
        result: CreateBlockResult;
    };
    [CommandName.CreateCollection]: {
        query: CreateCollectionQuery;
        result: CreateCollectionResult;
    };
    [CommandName.CreateDataSource]: {
        query: CreateDataSourceQuery;
        result: CreateDataSourceResult;
    };
    [CommandName.CreateLine]: {
        query: CreateLineQuery;
        result: CreateLineResult;
    };
    [CommandName.CreatePage]: {
        query: CreatePageQuery;
        result: CreatePageResult;
    };
    [CommandName.CreateUserImage]: {
        query: CreateUserImageQuery;
        result: CreateUserImageResult;
    };
    [CommandName.DataAction]: {
        query: DataActionQuery;
        result: DataActionResult;
    };
    [CommandName.DataItemExists]: {
        query: DataItemExistsQuery;
        result: DataItemExistsResult;
    };
    [CommandName.DeleteItem]: {
        query: DeleteItemQuery;
        result: DeleteItemResult;
    };
    [CommandName.DeletePage]: {
        query: DeletePageQuery;
        result: DeletePageResult;
    };
    [CommandName.DeleteShapeData]: {
        query: DeleteShapeDataQuery;
        result: DeleteShapeDataResult;
    };
    [CommandName.Download]: {
        query: DownloadQuery;
        result: DownloadResult;
    };
    [CommandName.DragPointerMove]: {
        query: DragPointerMoveQuery;
        result: DragPointerMoveResult;
    };
    [CommandName.DragPointerUp]: {
        query: DragPointerUpQuery;
        result: DragPointerUpResult;
    };
    [CommandName.ElementExists]: {
        query: ElementExistsQuery;
        result: ElementExistsResult;
    };
    [CommandName.ExecuteFormula]: {
        query: ExecuteFormulaQuery;
        result: ExecuteFormulaResult;
    };
    [CommandName.GetConnectedLines]: {
        query: GetConnectedLinesQuery;
        result: GetConnectedLinesResult;
    };
    [CommandName.GetCurrentPage]: {
        query: GetCurrentPageQuery;
        result: GetCurrentPageResult;
    };
    [CommandName.GetCustomShape]: {
        query: GetCustomShapeQuery;
        result: GetCustomShapeResult;
    };
    [CommandName.GetDataItemField]: {
        query: GetDataItemFieldQuery;
        result: GetDataItemFieldResult;
    };
    [CommandName.GetElementType]: {
        query: GetElementTypeQuery;
        result: GetElementTypeResult;
    };
    [CommandName.GetItemPageId]: {
        query: GetItemPageIdQuery;
        result: GetItemPageIdResult;
    };
    [CommandName.GetPackageSettings]: {
        query: GetPackageSettingsQuery;
        result: GetPackageSettingsResult;
    };
    [CommandName.GetProduct]: {
        query: GetProductQuery;
        result: GetProductResult;
    };
    [CommandName.GetProperty]: {
        query: GetPropertyQuery;
        result: GetPropertyResult;
    };
    [CommandName.GetReferenceKey]: {
        query: GetReferenceKeyQuery;
        result: GetReferenceKeyResult;
    };
    [CommandName.GetRelativeLinePosition]: {
        query: GetRelativeLinePositionQuery;
        result: GetRelativeLinePositionResult;
    };
    [CommandName.GetSelection]: {
        query: GetSelectionQuery;
        result: GetSelectionResult;
    };
    [CommandName.GetShapeData]: {
        query: GetShapeDataQuery;
        result: GetShapeDataResult;
    };
    [CommandName.HideModal]: {
        query: HideModalQuery;
        result: HideModalResult;
    };
    [CommandName.HidePanel]: {
        query: HidePanelQuery;
        result: HidePanelResult;
    };
    [CommandName.HookCreateItems]: {
        query: HookCreateItemsQuery;
        result: HookCreateItemsResult;
    };
    [CommandName.HookDeleteItems]: {
        query: HookDeleteItemsQuery;
        result: HookDeleteItemsResult;
    };
    [CommandName.HookSelection]: {
        query: HookSelectionQuery;
        result: HookSelectionResult;
    };
    [CommandName.HookTextEdit]: {
        query: HookTextEditQuery;
        result: HookTextEditResult;
    };
    [CommandName.KillExtension]: {
        query: KillExtensionQuery;
        result: KillExtensionResult;
    };
    [CommandName.ImportCards]: {
        query: ImportCardsQuery;
        result: ImportCardsResult;
    };
    [CommandName.ListBlocks]: {
        query: ListChildrenQuery;
        result: ListChildrenResult;
    };
    [CommandName.ListCollectionFields]: {
        query: ListCollectionFieldsQuery;
        result: ListCollectionFieldsResult;
    };
    [CommandName.ListCollections]: {
        query: ListCollectionsQuery;
        result: ListCollectionsResult;
    };
    [CommandName.ListDataItems]: {
        query: ListDataItemsQuery;
        result: ListDataItemsResult;
    };
    [CommandName.ListDataSources]: {
        query: ListDataSourcesQuery;
        result: ListDataSourcesResult;
    };
    [CommandName.ListDocumentElements]: {
        query: ListDocumentElementsQuery;
        result: ListDocumentElementsResult;
    };
    [CommandName.ListGroups]: {
        query: ListChildrenQuery;
        result: ListChildrenResult;
    };
    [CommandName.ListLines]: {
        query: ListChildrenQuery;
        result: ListChildrenResult;
    };
    [CommandName.ListPages]: {
        query: ListPagesQuery;
        result: ListPagesResult;
    };
    [CommandName.ListProperties]: {
        query: ListPropertiesQuery;
        result: ListPropertiesResult;
    };
    [CommandName.ListReferenceKeys]: {
        query: ListReferenceKeysQuery;
        result: ListReferenceKeysResult;
    };
    [CommandName.ListShapeData]: {
        query: ListShapeDataQuery;
        result: ListShapeDataResult;
    };
    [CommandName.ListTextAreas]: {
        query: ListTextAreasQuery;
        result: ListTextAreasResult;
    };
    [CommandName.LoadBlockClasses]: {
        query: LoadBlockClassesQuery;
        result: LoadBlockClassesResult;
    };
    [CommandName.LogForTestCase]: {
        query: JsonSerializable;
        result: JsonSerializable;
    };
    [CommandName.OffsetItems]: {
        query: OffsetItemsQuery;
        result: OffsetItemsResult;
    };
    [CommandName.PatchDataItems]: {
        query: PatchDataItemsQuery;
        result: PatchDataItemsResult;
    };
    [CommandName.RegisterPanel]: {
        query: RegisterPanelQuery;
        result: RegisterPanelResult;
    };
    [CommandName.RegisterUnfurl]: {
        query: RegisterUnfurlQuery;
        result: RegisterUnfurlResult;
    };
    [CommandName.ReloadExtension]: {
        query: ReloadExtensionQuery;
        result: ReloadExtensionResult;
    };
    [CommandName.SendOAuthRequest]: {
        query: SendOAuthRequestQuery;
        result: SendOAuthRequestResponse;
    };
    [CommandName.SendPermanentTokenRequest]: {
        query: SendPermanentTokenRequestQuery;
        result: SendOAuthRequestResponse;
    };
    [CommandName.SendUIMessage]: {
        query: SendUIMessageQuery;
        result: SendUIMessageResult;
    };
    [CommandName.SendXHR]: {
        query: SendXHRQuery;
        result: SendXHRResponse;
    };
    [CommandName.SetCurrentPage]: {
        query: SetCurrentPageQuery;
        result: SetCurrentPageResult;
    };
    [CommandName.SetProperty]: {
        query: SetPropertyQuery;
        result: SetPropertyResult;
    };
    [CommandName.SetReferenceKey]: {
        query: SetReferenceKeyQuery;
        result: SetReferenceKeyResult;
    };
    [CommandName.SetShapeData]: {
        query: SetShapeDataQuery;
        result: SetShapeDataResult;
    };
    [CommandName.SetText]: {
        query: SetTextQuery;
        result: SetTextResult;
    };
    [CommandName.ShowModal]: {
        query: ShowModalQuery;
        result: ShowModalResult;
    };
    [CommandName.ShowPackageSettingsModal]: {
        query: ShowPackageSettingsModalQuery;
        result: ShowPackageSettingsModalResult;
    };
    [CommandName.ShowPanel]: {
        query: ShowPanelQuery;
        result: ShowPanelResult;
    };
    [CommandName.SleepForTestCase]: {
        query: SleepForTestCaseQuery;
        result: SleepForTestCaseResult;
    };
    [CommandName.StartDragBlockToCanvas]: {
        query: StartDragBlockToCanvasQuery;
        result: StartDragBlockToCanvasResult;
    };
    [CommandName.StartPDFUploadRequest]: {
        query: StartPDFUploadRequestQuery;
        result: StartPDFUploadRequestResponse;
    };
    [CommandName.ThrowForTestCase]: {
        query: ThrowForTestCaseQuery;
        result: ThrowForTestCaseResult;
    };
    [CommandName.UnhookCreateItems]: {
        query: UnhookCreateItemsQuery;
        result: UnhookCreateItemsResult;
    };
    [CommandName.UnhookDeleteItems]: {
        query: UnhookDeleteItemsQuery;
        result: UnhookDeleteItemsResult;
    };
    [CommandName.UnhookSelection]: {
        query: UnhookSelectionQuery;
        result: UnhookSelectionResult;
    };
    [CommandName.UnhookTextEdit]: {
        query: UnhookTextEditQuery;
        result: UnhookTextEditResult;
    };
};
export declare type AddCardIntegrationQuery = {
    /** Title/name */
    'n': string;
    /** Data connector name */
    'dcn': string;
    /** Item label */
    'il': string;
    /** Items label */
    'isl': string;
    /** Icon url */
    'u': string;
    /** Field configuration */
    'fc': {
        /** Callback to get field definitions for all fields supported by the card integration */
        'gf': string;
        /** Callback to handle a change in the fields the user want to be displayed */
        'osfc'?: string | undefined;
    };
    /** Show intro if user has not yet authorized this integration */
    'i'?: string | undefined;
    /** Get default config action */
    'gdc': string;
    /** If specified, import modal settings */
    'im'?: {
        /** Get search fields action */
        'gsf': string;
        /** Search action */
        's': string;
        /** Import action */
        'i': string;
    } | undefined;
    /** If specified, add-card settings */
    'ac'?: {
        /** Get input fields action */
        'gif': string;
        /** Create card action */
        'cc': string;
    } | undefined;
};
export declare type AddCardIntegrationResult = undefined;
export declare type AddLineTextAreaQuery = {
    /** Which line */
    'id': string;
    /** Where to place the text along the line */
    'p': SerializedLineTextAreaPositioning;
    /** Plain text to put at this location (will be styled with document theme) */
    't': string;
};
/** The name of the created text area */
export declare type AddLineTextAreaResult = string;
/** @ignore */
export declare type UnionToIntersection<T> = (T extends any ? (x: T) => unknown : never) extends (x: infer R) => unknown ? R : never;
export declare type AddMenuItemQuery = {
    /** Label to display on the menu item */
    'l': string;
    /** Named action to run when the menu item is clicked */
    'a'?: string | undefined;
    /** Named action that returns whether the menu item should be visible */
    'v'?: string | undefined;
    /** Named action that returns whether the menu item should be disabled */
    'd'?: string | undefined;
    /** Which menu to put the item in */
    't': MenuType;
    /** If specified, where to place the menu item; defaults to MenuLocation.Extension */
    'loc'?: MenuLocation | undefined;
    /** If specified, this menu item should launch a file picker */
    'f'?: {
        /** Action to call when files are selected */
        'a': string;
        /** File types to accept */
        'ac': string;
        /** Single file only */
        's'?: boolean;
        /** Return content in a binary ArrayBuffer instead of as text */
        'b'?: boolean;
    } | undefined;
};
export declare type AddMenuItemResult = undefined;
export declare type AddShapeDataQuery = {
    /** ID of the element to add this shape data to */
    'id'?: string | undefined;
    /** Name for this shape data */
    'n': string;
    /** Inheritance setting for the new shape data */
    'i': ShapeDataInheritance;
    /** Initial value of this shape data; use a string beginning with '=' for a formula */
    'v'?: SerializedFieldType;
};
export declare type AddShapeDataResult = undefined;
export declare type AlertQuery = {
    /** Title; defaults to extension title */
    't'?: string | undefined;
    /** Body text */
    'b': string;
    /** Button text; defaults to i18n'ed "OK" */
    'bt'?: string | undefined;
};
/** True if they click OK, false otherwise */
export declare type AlertResult = Promise<boolean>;
export declare type AwaitImportQuery = {
    /** Data Connector Name */
    'n': string;
    /** Sync data source ID Nonce */
    's'?: string | undefined;
    /** Sync collection ID */
    'c': string;
    /** Keys to await */
    'pk': string[];
    /** Timeout in milliseconds; reject returned promise if no data appears in time */
    't': number;
};
/** Promise resolving to the collection ID where the data arrived */
export declare type AwaitImportResult = Promise<string>;
export declare type BootstrapQuery = {
    /**
     * Named action that accepts the bootstrap data, and which may return a Promise or void. After awaiting\
     * the result of the callback, the bootstrap data is cleared.
     */
    'c': string;
    /**
     * Marks a document as requiring the editor extension.
     */
    'm'?: boolean | undefined;
};
export declare type BootstrapResult = Promise<void>;
export declare type CanEditPackageSettingsQuery = undefined;
export declare type CanEditPackageSettingsResult = Promise<boolean>;
export declare type CancelDragBlockToCanvasQuery = void;
export declare type CancelDragBlockToCanvasResult = undefined;
export declare type ConfirmQuery = {
    /** Title; defaults to extension title */
    't'?: string | undefined;
    /** Body text */
    'b': string;
    /** OK button text; defaults to i18n'ed "OK" */
    'o'?: string | undefined;
    /** Cancel button text; defaults to i18n'ed "Cancel" */
    'c'?: string | undefined;
};
/** True if they click OK, false otherwise */
export declare type ConfirmResult = Promise<boolean>;
export declare type CreateBlockQuery = {
    /**
     * By default, we add the block to the current page & currently active group. If specified, the
     * block will instead be created as a direct child of the given page.
     */
    'p'?: string | undefined;
    /** Class name of the block to create */
    'c': string;
    /** If specified, the stencil for a custom shape. Only valid if the class name is 'CustomBlock' */
    's'?: JsonSerializable | undefined;
};
export declare type CreateBlockResult = string;
export declare type CreateCollectionFieldDefinition = {
    /** Name of the field */
    'n': string;
    /** Type of the values in this field */
    't': SerializedFieldTypeDefinition;
};
export declare type CreateCollectionQuery = {
    /** ID of the data source to add this collection to */
    's': string;
    /** Name of the collection */
    'n': string;
    /** Fields that can be set on data items in this collection */
    'f': CreateCollectionFieldDefinition[];
    /** Field(s) to use as the primary key of this collection */
    'p': string[];
};
export declare type CreateCollectionResult = string;
export declare type CreateDataSourceQuery = {
    /** Name of the data source */
    'n': string;
    /** Source configuration for this data source--information about where it came from, or any metadata that might be useful */
    's': {
        [key: string]: JsonSerializable;
    };
};
export declare type CreateDataSourceResult = string;
export declare type CreateLineQuery = {
    /**
     * By default, we add the line to the current page & currently active group. If specified, the
     * line will instead be created as a direct child of the given page.
     */
    'p'?: string | undefined;
};
export declare type CreateLineResult = string;
export declare type CreatePageQuery = void;
export declare type CreatePageResult = string;
export declare type CreateUserImageQuery = {
    /** media type */
    't': string;
    /** base64-encoded image data */
    'd': string;
};
export declare type RawCreateUserImageResult = {
    /** The resulting image URL */
    'u': string;
};
export declare type CreateUserImageResult = Promise<RawCreateUserImageResult>;
export declare type DataActionQuery = {
    /** Flow Name */
    'fn': string;
    /** Is Async */
    'a': boolean;
    /** Flow Data */
    'fd'?: unknown;
    /** Sync data source ID Nonce */
    's'?: string | undefined;
    /** Data Connector Name */
    'n': string;
};
export declare type RawDataActionResult = {
    /** The external service responded with this code */
    'c': number;
} & ({
    /** And this text */
    't': string;
} | {
    /** Or this JSON */
    'j': unknown;
});
export declare type DataActionResult = Promise<RawDataActionResult>;
export declare type DataItemExistsQuery = {
    /** Collection ID to check */
    'c': string;
    /** Primary key to check */
    'pk': string;
};
export declare type DataItemExistsResult = boolean;
export declare type DeleteItemQuery = string;
export declare type DeleteItemResult = boolean;
export declare type DeletePageQuery = string;
export declare type DeletePageResult = boolean;
export declare type DeleteShapeDataQuery = {
    /** ID of the element to delete this shape data from */
    'id'?: string | undefined;
    /** Name for this shape data */
    'n': string;
};
export declare type DeleteShapeDataResult = undefined;
export declare type DownloadQuery = {
    /** Filename of the download */
    'f': string;
    /** Data to put in the file */
    'd': string;
    /** MIME type for the download */
    'm': string;
    /** If true, data is base64-encoded and should be converted to binary for download */
    'b64': boolean;
};
export declare type DownloadResult = undefined;
export declare type DragPointerMoveQuery = {
    'x': number;
    'y': number;
};
export declare type DragPointerMoveResult = undefined;
export declare type DragPointerUpQuery = {
    'x': number;
    'y': number;
};
export declare type DragPointerUpResult = undefined;
export declare type ElementExistsQuery = {
    'id'?: string | undefined;
};
export declare type ElementExistsResult = boolean;
export declare type ExecuteFormulaQuery = {
    /** ID of the element to execute a formula on */
    'id': string;
    /** Formula to execute, e.g. '@a + @b' or 'CONTAINEDBY' */
    'f': string;
};
export declare type ExecuteFormulaResult = SerializedFieldType | SerializedDataError;
export declare type AnimateViewportQuery = {
    /** ID of the page to view */
    'p': string;
    /** Bounding box on that page that will fill as much of the viewport as possible */
    'bb': Box;
};
export declare type AnimateViewportResult = Promise<void>;
export declare type GetElementTypeQuery = {
    'id'?: string | undefined;
};
export declare type GetElementTypeResult = 'block' | 'line' | 'group' | 'visual-activity' | 'page' | 'document' | 'generator' | 'panel';
export declare type GetConnectedLinesQuery = string;
export declare type GetConnectedLinesResult = string[];
export declare type GetCurrentPageQuery = void;
export declare type GetCurrentPageResult = string | undefined;
export declare type GetCustomShapeQuery = {
    /** Name of the custom shape library in this same extension package */
    'l': string;
    /** Name of the shape in that library to find */
    's': string;
};
export declare type GetCustomShapeResult = Promise<{
    /** Value which can be used as the Stencil property on a dynamic shape */
    's': JsonSerializable;
    /** Default size (x:0, y:0) of this custom shape */
    'bb': Box;
    /** Other default property values */
    'p': JsonObject;
} | undefined>;
export declare type GetDataItemFieldQuery = {
    /** Collection ID to query */
    'c': string;
    /** Primary key of the data item to read */
    'pk': string;
    /** Name of field to read */
    'f': string;
};
export declare type GetDataItemFieldResult = SerializedFieldType;
export declare type GetItemPageIdQuery = string;
export declare type GetItemPageIdResult = string;
export declare type GetReferenceKeyQuery = {
    /** ID of the LucidElement to read a reference key from, or undefined to read from the LucidDocument */
    'id'?: string | undefined;
    /** Reference key to get */
    'k': number | string;
};
export declare type GetReferenceKeyResult = SerializedReferenceKeyType;
export declare type GetProductQuery = undefined;
export declare type GetProductResult = LucidProduct;
export declare type GetPropertyQuery = {
    /** ID of the LucidElement to read a property from, or undefined to read from the LucidDocument */
    'id'?: string | undefined;
    /** Name of the property to read */
    'p': string;
};
export declare type GetPropertyResult = JsonSerializable;
export declare type GetPackageSettingsQuery = undefined;
export declare type GetPackageSettingsResult = Promise<Record<string, JsonSerializable>>;
export declare type GetRelativeLinePositionQuery = {
    /** Block or line ID to check the connections on */
    'id': string;
    /** Relative position in range of [0,1] along the line */
    'p': number;
};
export declare type GetRelativeLinePositionResult = Point;
export declare type GetSelectionQuery = {
    /** If set, additionally return all items inside selected groups */
    'd'?: boolean | undefined;
};
export declare type GetSelectionResult = string[];
export declare type GetShapeDataQuery = {
    /** ID of the element to query shape data from */
    'id'?: string | undefined;
    /** Name of the shape data to read */
    'n': string;
};
export declare type GetShapeDataResult = SerializedFieldType | SerializedDataError;
export declare type HideModalQuery = {
    /** Name of the modal's action for receiving events, i.e. ShowModalQuery['n'] */
    'n': string;
};
export declare type HideModalResult = undefined;
export declare type HidePanelQuery = {
    /** Name of the panel's action for receiving events, i.e. RegisterPanelQuery['n'] */
    'n': string;
};
export declare type HidePanelResult = undefined;
export declare type HookCreateItemsQuery = {
    /** Name of the action for receiving events. Will be called with an array of strings of all recently created item IDs. */
    'n': string;
};
export declare type HookCreateItemsResult = undefined;
export declare type HookDeleteItemsQuery = {
    /** Name of the action for receiving events. Will be called with an array of strings of all recently deleted item IDs. */
    'n': string;
};
export declare type HookDeleteItemsResult = undefined;
export declare type HookSelectionQuery = {
    /** Name of the action for receiving events. Will be called with an array of strings of all selected item IDs. */
    'n': string;
};
export declare type HookSelectionResult = undefined;
export declare type HookTextEditQuery = {
    /** Name of the action for receiving these events */
    'n': string;
};
export declare type HookTextEditResult = undefined;
/** Name of the card integration registered by this extension to show the import dialog for */
export declare type ImportCardsQuery = string;
/** Resolves when the import dialog is closed */
export declare type ImportCardsResult = Promise<void>;
export declare type KillExtensionQuery = void;
export declare type KillExtensionResult = undefined;
export declare type ListChildrenQuery = {
    /** Parent ID to search inside */
    'id': string;
    /** "deep" - If true, get all children at any level of group nesting; otherwise only immediate children */
    'd'?: boolean;
};
export declare type ListChildrenResult = string[];
export declare type ListCollectionsQuery = {
    /** ID of the data source to list collections for */
    'id': string;
};
export declare type ListCollectionsResult = string[];
export declare type ListDataItemsQuery = {
    /** Collection ID to list items from */
    'id': string;
};
export declare type ListDataItemsResult = string[];
export declare type ListCollectionFieldsQuery = {
    /** Collection ID to query */
    'id': string;
};
export declare type ListCollectionFieldsResult = string[];
export declare type ListDataSourcesQuery = undefined;
export declare type ListDataSourcesResult = string[];
export declare type ListDocumentElementsQuery = {
    't': DocumentElementType;
};
export declare type ListDocumentElementsResult = string[];
export declare type ListPagesQuery = void;
export declare type ListPagesResult = string[];
export declare type ListReferenceKeysQuery = {
    /** ID of the element to list reference keys for, or undefined for the document */
    'id'?: string | undefined;
};
/** Reference key IDs */
export declare type ListReferenceKeysResult = (string | number)[];
export declare type ListPropertiesQuery = {
    'id'?: string | undefined;
};
export declare type ListPropertiesResult = string[];
export declare type ListShapeDataQuery = {
    'id'?: string | undefined;
    /** True to include inherited shape data from containing groups and/or page */
    'i'?: boolean | undefined;
};
export declare type ListShapeDataResult = string[];
export declare type ListTextAreasQuery = string;
export declare type ListTextAreasResult = string[];
export declare type LoadBlockClassesQuery = string[];
export declare type LoadBlockClassesResult = Promise<undefined>;
export declare type OffsetItemsQuery = {
    /** IDs of the items (blocks, lines, groups) to move */
    'ids': string[];
    /** What kind of offset to perform */
    't': LinearOffsetType;
    /** How far to offset */
    'o': Point;
};
export declare type OffsetItemsResult = undefined;
export declare type PatchDataItemsQuery = {
    /** ID of the data collection to patch */
    'id': string;
    /** Data items to add to the collection */
    'a': Record<string, SerializedFieldType>[];
    /** Data items to change field values on, keyed by primary key */
    'c': Record<string, Record<string, SerializedFieldType>>;
    /** Primary keys of items to delete */
    'd': string[];
};
/** Primary keys inserted, if any */
export declare type PatchDataItemsResult = string[];
export declare type RegisterPanelQuery = {
    /** Name of the panel's action for receiving events; generated automatically by Panel base class */
    'n': string;
    /** Title to show on the panel */
    't': string;
    /** Where to display the panel */
    'l': PanelLocation;
    /** Named action that returns whether the button to open the panel should be visible */
    'v'?: string | undefined;
    /** Content to display in the panel; full HTML page preferred */
    'c': string;
    /** Icon URL, preferably a base64-encoded URL */
    'i': string;
    /** tooltip */
    'to'?: string;
};
export declare type RegisterPanelResult = undefined;
export declare type RegisterUnfurlQuery = {
    /** Domain to unfurl, e.g. www.google.com */
    'd': string;
    /** Action to call to configure the unfurl */
    'a': string;
};
export declare type RegisterUnfurlResult = boolean;
export declare type ReloadExtensionQuery = void;
export declare type ReloadExtensionResult = undefined;
export declare type SendOAuthRequestQuery = SendXHRQuery & {
    /** OAuth provider name as specified in the package manifest */
    'p': string;
    /** Post Result To */
    'prt'?: string | undefined;
};
export declare type SendPermanentTokenRequestQuery = SendXHRQuery & {
    /** Permanent token provider name as specified in the package manifest */
    'p': string;
};
export declare type SendOAuthRequestResponse = SendXHRResponse;
export declare type SendPermanentTokenRequestResponse = SendXHRResponse;
export declare type SendUIMessageQuery = {
    /** Name of the UI component's action for receiving events, e.g. ShowModalQuery['n'] */
    'n': string;
    /** Content of the message to send to the custom UI component */
    'd'?: JsonSerializable;
};
export declare type SendUIMessageResult = undefined;
export declare type SendXHRResponseFormat = 'utf8' | 'binary';
export declare type SendXHRQuery = {
    'url': string;
    /** HTTP method, e.g. 'GET', 'FETCH', etc. Defaults to GET */
    'm'?: string | undefined;
    /**
     * The data to send with the request.
     *
     * For GET requests, this specifies the query string.
     *
     * For non-GET requests, this is sent as the body of the request. If this is specified, and
     *   no 'Content-Type' header is specified, a 'text/plain; charset=utf-8' content type is sent.
     */
    'd'?: string | undefined;
    /** Headers to send with the request */
    'h'?: {
        [key: string]: string | string[];
    } | undefined;
    /** Timeout in milliseconds, if specified */
    'ms'?: number | undefined;
    /**
     * The desired format for the returned response body. Defaults to 'utf8'.
     *
     * - If 'utf8', the response body will be returned as a string.
     * - If 'binary', the response body will be returned as a Uint8Array.
     */
    'f'?: SendXHRResponseFormat | undefined;
};
export declare type RawSendXHRResponse = {
    /** URL of the response after any redirects */
    'url': string;
    /** Plain-text or base64-encoded response body */
    't': string;
    /** Status code of the response */
    's': number;
    /** Headers sent with the response */
    'h': {
        [key: string]: string;
    };
    /** true if the request timed out */
    'to'?: boolean;
};
export declare type SendXHRResponse = Promise<RawSendXHRResponse>;
export declare function isRawSendXHRResponse(val: any): val is RawSendXHRResponse;
export declare type SetCurrentPageQuery = string;
export declare type SetCurrentPageResult = Promise<void>;
export declare type SetPropertyQuery = {
    /** ID of the element to change */
    'id'?: string | undefined;
    /** Name of the property to change */
    'p': string;
    /** New value of the property */
    'v'?: JsonSerializable;
};
export declare type SetPropertyResult = undefined;
export declare type SetReferenceKeyQuery = {
    /** ID of the element to set the reference key on */
    'id'?: string | undefined;
    /** ID of the reference key to set */
    'k': string | number;
    /** New reference key settings, or undefined to remove the reference key */
    'v'?: SerializedReferenceKeyType | undefined;
};
export declare type SetReferenceKeyResult = undefined;
export declare type SetShapeDataQuery = {
    /** ID of the element to set this shape data on */
    'id'?: string | undefined;
    /** Name for the already-existing shape data to update */
    'n': string;
    /** Value to set; use a string beginning with '=' for a formula */
    'v'?: SerializedFieldType;
};
export declare type SetShapeDataResult = undefined;
export declare type SetTextQuery = {
    /** ID of the element to change text on */
    'id': string;
    /** Name of the text area to update */
    'n': string;
    /** Plain text to put in the text area*/
    't': string;
    /** Optional force boolean for extension to update uneditable items*/
    'f'?: boolean | undefined;
};
export declare type SetTextResult = undefined;
export declare type ShowModalQuery = {
    /** Name of the modal's action for receiving events; generated automatically by Modal base class */
    'n': string;
    /** Title to show on the modal */
    't'?: string | undefined;
    /** Desired modal width */
    'w'?: number | undefined;
    /** Desired modal height */
    'h'?: number | undefined;
    /** Chromeless (without a header and borders) or not */
    'cl'?: boolean | undefined;
    /** FullScreen or not */
    'fs'?: boolean | undefined;
    /** TransparentBackground or not */
    'tb'?: boolean | undefined;
    /** Content to display in the modal; full HTML page preferred */
    'c': string;
};
export declare type ShowModalResult = undefined;
export declare type ShowPackageSettingsModalQuery = undefined;
export declare type ShowPackageSettingsModalResult = Promise<void>;
export declare type ShowPanelQuery = {
    /** Name of the panel's action for receiving events, i.e. RegisterPanelQuery['n'] */
    'n': string;
};
export declare type ShowPanelResult = undefined;
export declare type SleepForTestCaseQuery = number;
export declare type SleepForTestCaseResult = Promise<void>;
export declare type StartDragBlockToCanvasQuery = {
    /** Class name of the block to create */
    'c': string;
    /** Size of the block to create */
    'sz': {
        'w': number;
        'h': number;
    };
    /** Additional properties to set on the block being dragged */
    'p': {
        [key: string]: JsonSerializable;
    };
    /** If specified, the stencil for a custom shape. Only valid if the class name is 'CustomBlock' */
    's'?: JsonSerializable | undefined;
};
export declare type StartDragBlockToCanvasResult = Promise<string | undefined>;
export declare type StartPDFUploadRequestQuery = string;
/**
 * @ignore
 * A signed URL you can upload the pdf to. You can do this manually (via the client, your own service) or via the
 * oauth proxy.
 */
export declare type StartPDFUploadRequestResponse = Promise<string>;
export declare type ThrowForTestCaseQuery = number;
export declare type ThrowForTestCaseResult = undefined | Promise<void>;
export declare type UnhookCreateItemsQuery = {
    /** Name of the action passed to HookCreateItems */
    'n': string;
};
export declare type UnhookCreateItemsResult = undefined;
export declare type UnhookDeleteItemsQuery = {
    /** Name of the action passed to HookDeleteItems */
    'n': string;
};
export declare type UnhookDeleteItemsResult = undefined;
export declare type UnhookSelectionQuery = {
    /** Name of the action for receiving these events */
    'n': string;
};
export declare type UnhookSelectionResult = undefined;
export declare type UnhookTextEditQuery = {
    /** Name of the action for receiving these events */
    'n': string;
};
export declare type UnhookTextEditResult = undefined;
