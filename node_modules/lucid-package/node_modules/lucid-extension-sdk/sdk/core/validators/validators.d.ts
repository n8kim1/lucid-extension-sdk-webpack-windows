import { isNumber, isString } from '../checks';
import { DestructureGuardedTypeObj, GuardToType, Validator } from '../guards';
/*********************************************************************************
 * Validator generators:  These functions construct new composite validators
 *from elemental validators.
 ********************************************************************************/
/**
 * Creates a validator which tests if the target is a string
 * and is one of the values in the specified enum (object).
 */
export declare function stringEnumValidator<T>(enumMap: T): (x: unknown) => x is {} extends T ? never : T[keyof T];
/**
 * Creates a validator which tests if the target is a value in the specified enum.
 * Note that numbers in enums are reverse-mapped by the TS transpiler, so the specified keys are also values.
 */
export declare function enumValidator<T>(enumMap: T): (x: unknown) => x is {} extends T ? never : T[keyof T];
/**
 * Creates a validator which tests if the target is a number
 * and is equal to or between the min and max values.
 *
 */
export declare function rangeValidator(min: number, max: number): (x: unknown) => x is number;
/**
 * Creates a validator which tests if the target is an array
 * and if all elements of the array satisfy the given
 * sub-validator.
 *
 * @return A validator for the array type
 */
export declare function arrayValidator<T>(subValidator: (p1: unknown) => p1 is T): (p1: unknown) => p1 is T[];
/**
 * Creates a validator for a fixed width array where each entry
 * in the array can have a separate validator
 */
export declare function tupleValidator<V extends ((p1: unknown) => p1 is unknown)[]>(...tupleValidators: V): (x: any) => x is { [key in keyof V]: GuardToType<V[key]>; };
/**
 * Creates a validator that the given unknown is one of the supplied values
 */
export declare function someValue<T extends (string | number | symbol)[]>(...values: T): (x: unknown) => x is T[number];
/**
 * Creates a validator that the given unknown matches at least one of the given validators
 */
export declare function someValidator<T, A extends ((p1: unknown) => p1 is T)[]>(...validators: A): (x: any) => x is GuardToType<A[number]>;
/**
 * Creates a validator which tests if the target is an object
 * and if all values in the object satisfy the given sub-validator.
 * This does *not* perform any tests on the object keys, which
 * are allowed to be arbitrary strings.
 *
 * @return A validator for the map
 * Note that unlike objectValidator, this performs no validation on the names or
 * number of the keys and treats all values equally
 */
export declare function mapValidator<T>(subValidator: (p1: unknown) => p1 is T): (x: unknown) => x is {
    [key: string]: T;
};
/**
 * Creates a validator which tests if the target is an object
 * and if the structure of the object matches the structure of the passed-in
 * validator object.  The values in the validator object are in turn
 * validators.  This means that if the validator object has a (key,value)
 * pair of the form ('key', keyValidator), then in order for the target object
 * (x) to match, keyValidator(x['key']) must return true for all keys in the
 * validatorStructure.
 *
 * Note that you can use `lucid.validators.option` to create optional parameters
 * in validation structure.
 */
export declare function objectValidator<T extends {
    [key: string]: (p1: unknown) => p1 is unknown;
}>(validatorStructure: T): (subject: unknown) => subject is DestructureGuardedTypeObj<T>;
/**
 * Similar to {@link objectValidator}, but if the object has any non-undefined keys, they must also be present in the validator structure.
 * This is useful for things where extra data is unwanted, like Property serialization.
 * the loose version is often prefered because this one makes backwards compatible changes to the data harder,
 * because it requires an additional PR when the data transfers between services:
 * 1. A PR that adds the option() to this validator; 2. A PR that sends the new data; 3. A PR to remove the option();
 * compared to the (non-strict)objectValidator steps:
 * 1. A PR that adds the option() to this validator and sends the new data; 2. A PR to remove the option();
 */
export declare function strictObjectValidator<T extends {
    [key: string]: (p1: unknown) => p1 is unknown;
}>(validatorStructure: T): (subject: unknown) => subject is DestructureGuardedTypeObj<T>;
export declare function recordValidator<K extends string, V>(keyList: K[], valueValidator: Validator<V>): (x: unknown) => x is Record<K, V>;
export declare function objectOfValidator<T>(subValidator: Validator<T>): (x: unknown) => x is Record<any, T>;
/**
 * Create a validator which allows the target to be either null or satisfy the
 * sub-validator.
 *
 * @return A validator for the array type
 */
export declare function nullable<T>(subValidator: (p1: unknown) => p1 is T): (x: unknown) => x is T | null;
/**
 * Create a validator which allows the target to be undefined or satisfy the
 * sub-validator.
 *
 * @return A validator for the array type
 */
export declare function option<T>(subValidator: (p1: unknown) => p1 is T): (x: unknown) => x is T | undefined;
/**
 * Create a validator which allows the target to be undefined, null, or satisfy
 * the sub-validator.
 *
 * @return A validator for the array type
 */
export declare function nullableOption<T>(subValidator: (p1: unknown) => p1 is T): (x: unknown) => x is T | null | undefined;
export declare const isNullOption: (value: unknown) => value is null | undefined;
/**
 * Create a validator that merges two validators.
 * This is useful for validating properties that have 2 disjoint sets of possible values.
 * e.g. {someObject: string}|false
 */
export declare function either<A, B>(validatorA: Validator<A>, validatorB: Validator<B>): (x: unknown) => x is A | B;
/**
 * Create a validator that combines two validators.
 * This is useful for validating properties that have been composed of a generic and more specific values.
 */
export declare function both<A, B>(validatorA: Validator<A>, validatorB: Validator<B>): (x: unknown) => x is A & B;
/**
 * Create a validator that allows types excluding those that satisfy an excludeValidator.
 */
export declare function exclude<T extends U, U>(validator: (x: unknown) => x is U, excludeValidator: (x: U) => x is T): (x: unknown) => x is Exclude<U, T>;
/**
 * Get a validator which returns whether the property calculation structure is
 * correct.
 */
export declare function propertyValidator<T>(subValidator: (p1: unknown) => p1 is T, preSaveActions: ((p1: unknown) => unknown)[]): (subject: unknown) => subject is DestructureGuardedTypeObj<{
    Equation: typeof isString;
    StaticValue: (x: unknown) => x is unknown;
}>;
/*********************************************************************************
 * Validators:  Some useful predefined validator functions.
 ********************************************************************************/
/**
 * This validator only allows objects whose values are all booleans set to true.
 *
 * @return A validator for the map
 */
export declare function isSet(x: unknown): x is {
    [key: string]: true;
};
/**
 * This validator validates that value is either number or empty string
 */
export declare const isNumberOrEmptyString: (x: unknown) => x is number | "";
/**
 * This validator validates that value is either boolean or empty string
 */
export declare const isBooleanOrEmptyString: (x: unknown) => x is boolean | "";
/**
 * This validator validates that value is either string or -1
 */
export declare const isStringOrNegativeOne: (x: unknown) => x is string | -1;
/**
 * This validator validates model of lucid.model.restrictions
 */
export declare const isRestrictions: (subject: unknown) => subject is DestructureGuardedTypeObj<{
    b: (x: unknown) => x is boolean | null | undefined;
    p: (x: unknown) => x is boolean | null | undefined;
    c: (x: unknown) => x is boolean | null | undefined;
    f: (x: unknown) => x is boolean | null | undefined;
    o: (x: unknown) => x is boolean | null | undefined;
    e: (x: unknown) => x is boolean | null | undefined;
    fc: (x: unknown) => x is boolean | null | undefined;
    fs: (x: unknown) => x is boolean | null | undefined;
    l: (x: unknown) => x is boolean | null | undefined;
    i: (x: unknown) => x is boolean | null | undefined;
    u: (x: unknown) => x is boolean | null | undefined;
    acap: (x: unknown) => x is boolean | null | undefined;
    scap: (x: unknown) => x is boolean | null | undefined;
    imageCategory: (x: unknown) => x is boolean | null | undefined;
    pcad: (x: unknown) => x is boolean | null | undefined;
}>;
/**
 * Returns true if the target is equal to either zero or one or is a boolean.
 *
 */
export declare function isFlag(x: unknown): x is 0 | 1 | boolean;
export declare function isTrue(x: unknown): x is true;
/**
 * Returns if an object is a number between 0 and 100.
 *
 */
export declare const isOpacity: (x: unknown) => x is number;
/**
 * Tests if the given target satisfies the PointLike interface.
 *
 */
export declare const isPointLike: (subject: unknown) => subject is DestructureGuardedTypeObj<{
    x: typeof isNumber;
    y: typeof isNumber;
}>;
/**
 * Tests if the given target is a bounding box.
 *
 */
export declare const isBoundingBox: (subject: unknown) => subject is DestructureGuardedTypeObj<{
    x: typeof isNumber;
    y: typeof isNumber;
    w: typeof isNumber;
    h: typeof isNumber;
}>;
/**
 * Tests if the given target is a panel size.
 *
 */
export declare const isPanelSize: (subject: unknown) => subject is DestructureGuardedTypeObj<{
    x: typeof isNumber;
    y: typeof isNumber;
    w: typeof isNumber;
    h: typeof isNumber;
    identifier: (x: unknown) => x is string | null | undefined;
}>;
export declare const isSize: (subject: unknown) => subject is DestructureGuardedTypeObj<{
    w: typeof isNumber;
    h: typeof isNumber;
}>;
export declare function isPositiveNumber(x: unknown): x is number;
export declare function isDate(x: unknown): x is Date;
export declare function maxLengthValidator(max: number): (x: unknown) => x is string;
export declare function minLengthValidator(min: number): (x: unknown) => x is string;
export declare type ValidatorWithMessage = (x: unknown) => true | string;
export declare function validatorWithMessage<T>(validator: (x: unknown) => x is T, message: string, sub?: ValidatorWithMessage): ValidatorWithMessage;
export declare function asAssertion<TO extends FROM, FROM>(validator: Validator<TO, FROM>): (val: FROM) => asserts val is TO;
