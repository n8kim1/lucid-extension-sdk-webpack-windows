import { FieldConstraintDefinition } from '../../data/schemadefinition';
import { CollectionEnumFieldType } from './fieldtypedefinition/collectionenumfieldtype';
import { FieldTypeArray } from './fieldtypedefinition/fieldtypearray';
import { FieldTypeDefinition } from './fieldtypedefinition/fieldtypedefinition';
import { ScalarFieldTypeEnum } from './fieldtypedefinition/scalarfieldtype';
import { SemanticKind } from './fieldtypedefinition/semantickind';
import { SerializedColorObject, SerializedLucidCurrency, SerializedLucidDateObject, SerializedLucidDictionary } from './serializedfield/serializedfields';
declare type TsTypeOf<X> = X extends ScalarFieldTypeEnum.ANY ? unknown : X extends ScalarFieldTypeEnum.NUMBER ? number : X extends ScalarFieldTypeEnum.BOOLEAN ? boolean : X extends ScalarFieldTypeEnum.STRING ? string : X extends ScalarFieldTypeEnum.COLOR ? SerializedColorObject : X extends ScalarFieldTypeEnum.DATE ? SerializedLucidDateObject : X extends ScalarFieldTypeEnum.NULL ? null : X extends ScalarFieldTypeEnum.DICTIONARY ? SerializedLucidDictionary : X extends FieldTypeArray<infer Inner> ? TsTypeOf<Inner>[] : X extends ScalarFieldTypeEnum.CURRENCY ? SerializedLucidCurrency : X extends ScalarFieldTypeEnum.DATEONLY ? SerializedLucidDateObject & {
    isDateOnly: true;
} : X extends CollectionEnumFieldType ? string : X extends readonly [infer Inner, ...infer Others] ? TsTypeOf<Inner> | TsTypeOf<Others> : never;
/**
 * Specifies all the fields that this itegration will be sending to the data-sync service.
 * Give you well typed methods to convert from `YourType[]` to `{[PrimaryKey:string]: YourType}`
 * which is what most of the data sync service calls expect.
 *
 * There is fromItems which does the above will full type information, and fromItems sparse
 * which allows all the fields not part of the primaryKey to be undefined. The former should
 * be used with initial imports, and the latter can be used for updates.
 */
export declare function declareSchema<Names extends string, Types extends Readonly<FieldTypeDefinition>, Constraint extends FieldConstraintDefinition, SemanticFieldTypes extends SemanticKind, Fields extends {
    [Name in Names]: {
        type: Types;
        constraints?: readonly Constraint[];
        mapping?: readonly SemanticFieldTypes[] | undefined;
    };
}, PrimaryKey extends keyof Fields>({ primaryKey, fields }: {
    primaryKey: PrimaryKey[];
    fields: Fields;
}): {
    example: Fields;
    array: {
        name: Exclude<keyof typeof fields, number>;
        type: FieldTypeDefinition;
        constraints: FieldConstraintDefinition[];
        mapping: SemanticFieldTypes[];
    }[];
    primaryKey: FormattedPrimaryKey<Fields, PrimaryKey>;
    fromItemsSparse: (items: PartialItemType<typeof fields, PrimaryKey>[]) => Map<string, PartialItemType<Fields, PrimaryKey>>;
    fromItems: (items: ItemType<typeof fields>[]) => Map<string, ItemType<Fields>>;
};
/**
 * Generates a mapper that, given a primary key definition is able to produce the primary key for that item.
 **/
export declare class FormattedPrimaryKey<Fields extends FieldsStructure, PrimaryKey extends keyof Fields> {
    readonly elements: PrimaryKey[];
    constructor(...elements: PrimaryKey[]);
    /**
     * Generate the serialized form of the item's primary key.
     *
     * For single value primary keys, the encoded values are just the json representation of the primary
     * key. For example, if the primary key is ['id'] the following table shows encodings:
     *
     * | type    | value     | encoded                            |
     * |---------|-----------|------------------------------------|
     * | number  | `15`      | `new Map([["15", ...], ...])`      |
     * | boolean | `false`   | `new Map([["false", ...], ...])`   |
     * | string  | `"hello"` | `new Map([['"hello"', ...], ...])` |
     *
     * Take note of the extra quotes in the string case.
     *
     * For primary keys with multiple values, first sort the array of primary keys then join the json encoded values
     * from of the keys with commas. For example:
     *
     * ```
     * primary key = ["lastName", "firstName"]
     * sorted key = ["firstName", "lastName"]
     * row = {"lastName": "Smith", "firstName": "John", "age": 42}
     * row key = '"John","Smith"'
     * items = new Map([['"John","Smith"', {"lastName": "Smith", "firstName": "John", "age": 42}]])
     * ```
     */
    forItem(item: PartialItemType<Fields, PrimaryKey>): string;
}
/**
 * Root type for something that looks like the field list we use to sync with the data-sync service.
 * Used just to make writing other internal types easier.
 */
declare type FieldsStructure = {
    [Name in string]: {
        type: Readonly<FieldTypeDefinition>;
        mapping?: undefined | readonly SemanticKind[];
    };
};
/**
 * The type of a item in the FieldsStructure, that is if the FieldsStructure represents
 *
 * ```
 * [{Name: "id", Type: ScalarFieldTypeEnum.STRING}]
 * ```
 *
 * then ItemType for that would be:
 *
 * ```
 * {'id': string}
 * ```
 */
export declare type ItemType<Fields extends FieldsStructure> = {
    [Field in keyof Fields]: TsTypeOf<Fields[Field]['type']>;
};
/**
 * Just like ItemType<Foo>, but the fields not part of the primary key can be undefined.
 */
export declare type PartialItemType<Fields extends FieldsStructure, PrimaryKey extends keyof Fields> = Pick<ItemType<Fields>, PrimaryKey> & Partial<Omit<ItemType<Fields>, PrimaryKey>>;
export {};
