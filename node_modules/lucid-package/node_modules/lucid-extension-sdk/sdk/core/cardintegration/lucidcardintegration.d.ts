import { CollectionDefinition } from '../../data/collectiondefinition';
import { CollectionProxy } from '../../data/collectionproxy';
import { DataSourceProxy } from '../../data/datasourceproxy';
import { EditorClient } from '../../editorclient';
import { SerializedFieldType } from '../data/serializedfield/serializedfields';
import { CardIntegrationConfig } from './cardintegrationconfig';
import { ExtensionCardFieldDefinition } from './cardintegrationdefinitions';
export declare abstract class LucidCardIntegration {
    private readonly client;
    constructor(client: EditorClient);
    /**
     * Label used to identify the integration, e.g. "Jira", which will be used in menu items, etc.
     * Should be unique within any given extension.
     */
    abstract label: string;
    /**
     * Label used to identify one card worth of data, e.g. "Jira task"
     */
    abstract itemLabel: string;
    /**
     * Label used to identify multiple cards worth of data, e.g. "Jira tasks"
     */
    abstract itemsLabel: string;
    /**
     * URL for an icon to display in toolbars, etc. Should be at least 24x24.
     */
    abstract iconUrl: string;
    /**
     * The name of the data connector associated with the card integration.
     */
    abstract dataConnectorName: string;
    abstract fieldConfiguration: {
        /**
         * Callback to provide a list of all supported field names for the card integration.
         */
        getAllFields: (dataSource: DataSourceProxy) => Promise<string[]>;
        /**
         * Callback that handled changes in the fields the user wants to be displayed in the card integration.
         * If this callback is not provided then the user will not be shown the modal to configure fields.
         */
        onSelectedFieldsChange?: (dataSource: DataSourceProxy, selectedFields: string[]) => Promise<void>;
    };
    /**
     * If specified, and the user hasn't yet authorized the data connector for this extension,
     * this should show the user an intro dialog or take some other action.
     */
    showIntro?: () => void;
    /**
     * Provide the default configuration for a new import
     */
    abstract getDefaultConfig: (dataSource: DataSourceProxy) => Promise<CardIntegrationConfig>;
    /**
     * If specified, allow the user to import cards using the standard card-import modal.
     *
     * getSearchFields:
     * Given the values entered by the user so far into search fields, return the list of all search fields
     * to display in the search form.
     *
     * search:
     * Given values entered by the user into the search fields so far, return a collection of data to
     * display in the results table. If partialImportMetadata is also returned, it will be used to create the tasks cards before
     * the import is completedâ€”which allows users to interact with the cards while the
     * data is fetched asynchronously. The collectionId needs to match the id that will be
     * returned from the completed import. The syncDataSourceId needs to match the
     * syncDataSourceId that is passed into performDataAction.
     * The last requirement for the partial import to work is that the primary keys in the data also
     * returned in this search need to match the primary keys that will be returned
     * on import.
     *
     * import:
     * The user checked the boxes beside the given list of items in the collection returned from search().
     * Import them, and return the collection and primary keys in that final collection that were imported.
     *
     * The config provided here is only used on the first import from a given source; on subsequent imports,
     * the existing config will remain unchanged to preserve any customizations by the user.
     */
    importModal?: {
        getSearchFields: (searchSoFar: Map<string, SerializedFieldType>) => Promise<ExtensionCardFieldDefinition[]>;
        search: (fields: Map<string, SerializedFieldType>) => Promise<{
            partialImportMetadata?: {
                collectionId: string;
                syncDataSourceId?: string;
            };
            data: CollectionDefinition;
            fields: ExtensionCardFieldDefinition[];
        }>;
        import: (primaryKeys: string[], searchFields: Map<string, SerializedFieldType>) => Promise<{
            collection: CollectionProxy;
            primaryKeys: string[];
        }>;
    };
    /**
     * If specified, allow the user to create new cards and convert other shapes to cards
     */
    addCard?: {
        /**
         * Given the values entered by the user so far into input fields, return the list of all input fields
         * to display in the create-card form.
         */
        getInputFields: (inputSoFar: Map<string, SerializedFieldType>) => Promise<ExtensionCardFieldDefinition[]>;
        /**
         * Given the values entered by the user into input fields, create a new data record to represent the
         * created card, and return information about that record.
         */
        createCardData: (input: Map<string, SerializedFieldType>) => Promise<{
            collection: CollectionProxy;
            primaryKey: string;
        }>;
    };
    showCardImport(name: string): import("../../commandtypes").ImportCardsResult;
}
