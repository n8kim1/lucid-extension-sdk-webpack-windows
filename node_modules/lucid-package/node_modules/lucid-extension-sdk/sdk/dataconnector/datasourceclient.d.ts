import { SerializedFieldTypeDefinition } from '../core/data/fieldtypedefinition/fieldtypedefinition';
import { SemanticKind } from '../core/data/fieldtypedefinition/semantickind';
import type { FieldConstraintType } from '../core/data/serializedfield/serializedfielddefinition';
import { SerializedFields } from '../core/data/serializedfield/serializedfields';
import { JsonSerializable } from '../core/jsonserializable';
import type { DataUpdateFilterType } from '../data/dataupdatefiltertype';
import { FieldDefinition, SchemaDefinition } from '../data/schemadefinition';
/**
 * Container for an update to a data source
 */
export declare type DataSourceRequest = {
    /** The current update filter type associated with this request */
    updateFilterType?: DataUpdateFilterType;
    /** The name of the data source to be added or modified */
    dataSourceName: string;
    /** Collections to add or update to the data source */
    collections: Record<string, CollectionPatch>;
};
declare type SerializedFieldConstraintForApi = {
    'type': FieldConstraintType;
    'details'?: JsonSerializable;
};
declare type SerializedFieldDefinitionForApi = {
    'name': string;
    'type': SerializedFieldTypeDefinition;
    'constraints': SerializedFieldConstraintForApi[];
    'syncSchema'?: string;
    'mapping'?: readonly SemanticKind[];
};
/**
 * A patch to a collection or the definition of a new collection to be added. If adding a new collection, a schema must
 * be provided. If modifying an existing collection, a schema may be omitted.
 **/
export interface CollectionPatch {
    /**
     * If changing an existing schema only the following changes are allowed:
     *
     * 1. Adding a nullable field
     * 2. Promoting a type of a field to a union of types (`string` -> `string | number`)
     * 3. Adding a new variant to a union type (`string | number` -> `string | number | boolean`)
     *
     * * Removing a field is not allowed (just add `| null` and don't provide the field in patches anymore).
     * * Changing a type in a way that any existing legal value is no longer valid for that field is not allowed.
     */
    schema?: SchemaDefinition;
    /** The patch to apply to the collection */
    patch: {
        /**
         * Items to be added or changed in the collection. Mapping from item serialized primary key to
         * the sparse patch of the item. See FormattedPrimaryKey.forItem.
         **/
        items: Map<string, SerializedFields>;
        /** Items to remove from the collection, based on the same primary key algorithm. */
        itemsDeleted?: string[];
    };
}
/** @ignore */
export declare function serializeFieldDefinitionForApi(field: FieldDefinition): SerializedFieldDefinitionForApi;
/**
 * Authenticated client for DataSource related requests to Lucid.
 */
export declare class DataSourceClient {
    private url;
    private updateToken;
    private fetchMethod;
    constructor(url: string, updateToken: string, fetchMethod?: import("./defaultfetchfunction").GlobalFetchType);
    private formatBody;
    /** Create or update a datasource. If you create a new collection it must be fully specified in terms of schema and
     * and items. If it's just an update then the schema can be omitted (if unchanged) and items that already exist can
     * be partial.*/
    update(request: DataSourceRequest): Promise<void>;
}
/**
 * A version of the DataSourceClient that you can use for any automated tests of your data connector.
 * Modify the `gotUpdate` field to change the behaviour of the update method.
 **/
export declare class MockDataSourceClient extends DataSourceClient {
    /** Assign this to your mocked update function */
    gotUpdate: (request: DataSourceRequest) => void;
    constructor();
    /** @ignore */
    update(request: DataSourceRequest): Promise<void>;
}
export {};
