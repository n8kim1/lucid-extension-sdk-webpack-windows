"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockDataSourceClient = exports.DataSourceClient = exports.serializeFieldDefinitionForApi = void 0;
const fieldtypedefinition_1 = require("../core/data/fieldtypedefinition/fieldtypedefinition");
const object_1 = require("../core/object");
const dataconnector_1 = require("./dataconnector");
const defaultfetchfunction_1 = require("./defaultfetchfunction");
function serializeFieldConstraintForApi(constraint) {
    return {
        'type': constraint.type,
        'details': constraint.value,
    };
}
/** @ignore */
function serializeFieldDefinitionForApi(field) {
    var _a;
    return {
        'name': field.name,
        'type': (0, fieldtypedefinition_1.serializeFieldTypeDefinition)(field.type),
        'constraints': ((_a = field.constraints) !== null && _a !== void 0 ? _a : []).map((x) => serializeFieldConstraintForApi(x)),
        'mapping': field.mapping,
    };
}
exports.serializeFieldDefinitionForApi = serializeFieldDefinitionForApi;
function serializeSchemaForApi(schema) {
    return {
        'fields': schema.fields.map((x) => serializeFieldDefinitionForApi(x)),
        'primaryKey': schema.primaryKey,
        'fieldLabelOverrides': schema.fieldLabels,
    };
}
function serializeCollectionPatch(patch) {
    var _a;
    return {
        'schema': patch.schema && serializeSchemaForApi(patch.schema),
        'itemsPatch': {
            'items': (0, object_1.fromEntries)(patch.patch.items.entries()),
            'itemsDeleted': (_a = patch.patch.itemsDeleted) !== null && _a !== void 0 ? _a : [],
        },
    };
}
const assertIsJustRenamed = () => undefined;
assertIsJustRenamed();
assertIsJustRenamed();
assertIsJustRenamed();
/**
 * Authenticated client for DataSource related requests to Lucid.
 */
class DataSourceClient {
    constructor(url, updateToken, fetchMethod = defaultfetchfunction_1.globalFetch) {
        this.url = url;
        this.updateToken = updateToken;
        this.fetchMethod = fetchMethod;
    }
    formatBody({ updateFilterType, dataSourceName, collections }) {
        const upstreamConfig = updateFilterType
            ? {
                'upstreamConfig': {
                    'UpdateType': updateFilterType,
                },
            }
            : {};
        const updateData = {};
        for (const collectionId in collections) {
            updateData[collectionId] = serializeCollectionPatch(collections[collectionId]);
        }
        return {
            'updateData': updateData,
            'name': dataSourceName,
            // ...upstreamConfig,
        };
    }
    /** Create or update a datasource. If you create a new collection it must be fully specified in terms of schema and
     * and items. If it's just an update then the schema can be omitted (if unchanged) and items that already exist can
     * be partial.*/
    async update(request) {
        const response = await this.fetchMethod(this.url, {
            'method': 'POST',
            'headers': {
                'Content-Type': 'application/json',
                'data-update-token': this.updateToken,
                'Lucid-Api-Version': '1',
            },
            'body': JSON.stringify(this.formatBody(request)),
        });
        if (Math.floor(response.status / 100) !== 2) {
            throw new dataconnector_1.DataConnectorRunError(500, { message: 'Error updating data source', json: await response.text() });
        }
        // webhooks return 200 with an empty body
        // document updates return valid json
        // we can't use .json because that will fail for webhooks
        // if we update the response type for webhook updates
        // we can handle that here too. We should probably unify the responses
        // to be meaningful
        // we could just:
        // return await response.text();
        // but lets avoid users trying to interpret the response
    }
}
exports.DataSourceClient = DataSourceClient;
/**
 * A version of the DataSourceClient that you can use for any automated tests of your data connector.
 * Modify the `gotUpdate` field to change the behaviour of the update method.
 **/
class MockDataSourceClient extends DataSourceClient {
    constructor() {
        super('', '');
        /** Assign this to your mocked update function */
        this.gotUpdate = (request) => {
            throw new Error(`Didn't mock request: ${JSON.stringify(request)}`);
        };
    }
    /** @ignore */
    update(request) {
        return Promise.resolve(this.gotUpdate(request));
    }
}
exports.MockDataSourceClient = MockDataSourceClient;
