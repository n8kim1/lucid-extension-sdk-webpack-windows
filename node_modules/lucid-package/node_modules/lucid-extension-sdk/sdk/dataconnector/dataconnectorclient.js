"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockDataConnectorClient = exports.DataConnectorClient = void 0;
const checks_1 = require("../core/checks");
const serializedactions_1 = require("./actions/serializedactions");
const dataconnector_1 = require("./dataconnector");
const datasourceclient_1 = require("./datasourceclient");
const defaultfetchfunction_1 = require("./defaultfetchfunction");
const signaturevalidator_1 = require("./signaturevalidator");
const LUCID_URLS = { main: 'https://lucid.app/', api: 'https://api.lucid.co/' };
/**
 * Client for requests to and from Lucid
 */
class DataConnectorClient {
    constructor(urls = LUCID_URLS, fetchMethod = defaultfetchfunction_1.globalFetch) {
        this.urls = urls;
        this.fetchMethod = fetchMethod;
        this.cachedPublicKey = undefined;
    }
    /** Get a client for DataSource related requests to Lucid */
    getDataSourceClient(updateToken) {
        return new datasourceclient_1.DataSourceClient(`${this.urls.api}data/dataSource/update`, updateToken, this.fetchMethod);
    }
    /** Get a validator to prove a given request came from Lucid */
    async getSignatureValidator() {
        return new signaturevalidator_1.SignatureValidator(await this.getPublicKey());
    }
    /** Get Lucid's public key to verify requests came from Lucid if you don't want to use the SignatureValidator. Maybe
     * you're not running in a NodeJS environment */
    async getPublicKey() {
        if (!this.cachedPublicKey) {
            const url = `${this.urls.main}.well-known/pem/TPCP`;
            const result = await this.fetchMethod(url);
            if (Math.floor(result.status / 100) !== 2) {
                throw new dataconnector_1.DataConnectorRunError(500, { text: await result.text(), message: 'Error getting public key' });
            }
            this.cachedPublicKey = await result.text();
        }
        return this.cachedPublicKey;
    }
    /** Validate and parse an action request from Lucid */
    async parseActions(url, headers, actions) {
        if (!(0, serializedactions_1.actionsHeaderValidator)(headers)) {
            return;
        }
        if (!(await this.getSignatureValidator()).validate(actions, headers, url)) {
            return;
        }
        return (0, serializedactions_1.deserializeActions)(this, actions);
    }
    /** @ignore */
    async getSecretFromWebhook(webhookUpdateToken, WebhookValidationSecret) {
        // todo: this should be using the public API
        const result = await this.fetchMethod(`${this.urls.dataSync}webhookAuthorization`, {
            headers: {
                'data-update-token': webhookUpdateToken,
                'webhook-validation-secret': JSON.stringify(WebhookValidationSecret),
            },
        });
        const responseBody = await result.json();
        if ((0, checks_1.isString)(responseBody)) {
            return responseBody;
        }
        else {
            return undefined;
        }
    }
    /** @ignore */
    async getCustomWebhookData(webhookUpdateToken) {
        return (await // todo: this should be using the public API
         (await this.fetchMethod(`${this.urls.dataSync}customWebhookData`, {
            headers: { 'data-update-token': webhookUpdateToken },
        })).json());
    }
    /** @ignore */
    async patchCustomWebhookData(webhookUpdateToken, patch) {
        // todo: this should be using the public API
        const response = await this.fetchMethod(`${this.urls.dataSync}customWebhookData`, {
            method: 'PATCH',
            'headers': {
                'Content-Type': 'application/json',
                'data-update-token': webhookUpdateToken,
                'Lucid-Api-Version': '1',
            },
            body: JSON.stringify(patch),
        });
        if (Math.floor(response.status / 100) !== 2) {
            throw new dataconnector_1.DataConnectorRunError(500, {
                message: 'Error patching custom webhook data',
                json: await response.text(),
            });
        }
        return (await response.json());
    }
}
exports.DataConnectorClient = DataConnectorClient;
/** Use this for writing automated tests for your data connector */
class MockDataConnectorClient extends DataConnectorClient {
    constructor() {
        super(...arguments);
        /** set properties on this to modify how data source updates are mocked */
        this.dataSourceClient = new datasourceclient_1.MockDataSourceClient();
    }
    /** @ignore */
    getDataSourceClient(updateToken) {
        return this.dataSourceClient;
    }
    /** Mocked version just always returns successful */
    getSignatureValidator() {
        return Promise.resolve(new signaturevalidator_1.MockSignatureValidator());
    }
    /** Mocked version returns an empty string */
    getPublicKey() {
        return Promise.resolve('');
    }
}
exports.MockDataConnectorClient = MockDataConnectorClient;
