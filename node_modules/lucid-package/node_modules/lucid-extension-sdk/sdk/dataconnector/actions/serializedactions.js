"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeActions = exports.actionsHeaderValidator = void 0;
const dataupdatefiltertype_1 = require("../../data/dataupdatefiltertype");
const checks_1 = require("../../core/checks");
const validators_1 = require("../../core/validators/validators");
const action_1 = require("./action");
const dataconnectoractionkeys_1 = require("./dataconnectoractionkeys");
exports.actionsHeaderValidator = (0, validators_1.objectValidator)({ 'x-lucid-rsa-nonce': checks_1.isString, 'x-lucid-signature': checks_1.isString });
const serializedActionsBaseValidator = (0, validators_1.objectValidator)({
    'action': (0, validators_1.objectValidator)({ 'name': checks_1.isString, 'data': checks_1.isUnknown }),
    'packageId': checks_1.isString,
    'packageVersion': (0, validators_1.nullableOption)(checks_1.isString),
    'dataConnectorName': checks_1.isString,
    'installationId': (0, validators_1.nullableOption)(checks_1.isString),
    'userCredential': (0, validators_1.nullableOption)(checks_1.isString),
    'documentUpdateToken': (0, validators_1.nullableOption)(checks_1.isString),
    'documentCollections': (0, validators_1.objectOfValidator)((0, validators_1.arrayValidator)(checks_1.isString)),
    'updateFilterType': (0, validators_1.enumValidator)(dataupdatefiltertype_1.DataUpdateFilterType),
});
const serializedPatchDataValidator = (0, validators_1.objectValidator)({
    'packageVersion': checks_1.isString,
    'userCredential': checks_1.isString,
    'patches': (0, validators_1.arrayValidator)((0, validators_1.objectValidator)({
        'patch': (0, validators_1.objectValidator)({
            'itemsAdded': (0, validators_1.objectOfValidator)(checks_1.isObject),
            'itemsChanged': (0, validators_1.objectOfValidator)(checks_1.isObject),
            'itemsDeleted': (0, validators_1.arrayValidator)(checks_1.isString),
            'syncSourceId': checks_1.isString,
            'syncCollectionId': checks_1.isString,
            'adapterType': (0, checks_1.isLiteral)('EXTENSION_API'),
            'syncSchema': checks_1.isUnknown,
        }),
        'id': checks_1.isString,
    })),
});
const parseSerializedPatches = (patches) => {
    return patches.map((patch) => {
        const p = patch['patch'];
        return new action_1.Patch(patch['id'], p['itemsAdded'], p['itemsChanged'], p['itemsDeleted'], p['syncSourceId'], p['syncCollectionId']);
    });
};
const serializedManageWebhookDataValidator = (0, validators_1.objectValidator)({
    'webhooks': (0, validators_1.arrayValidator)((0, validators_1.objectValidator)({
        'documentCollections': (0, validators_1.objectOfValidator)((0, validators_1.arrayValidator)(checks_1.isString)),
        'webhookData': (0, validators_1.option)(checks_1.isUnknown),
    })),
    'webhookToken': checks_1.isString,
});
/** Function to convert the lucid action wire format into a clean list of actions */
function deserializeActions(client, actions) {
    if (!serializedActionsBaseValidator(actions)) {
        return;
    }
    const name = actions['action']['name'];
    const data = actions['action']['data'];
    if (name === dataconnectoractionkeys_1.DataConnectorActionKeys.Patch) {
        if (!(0, validators_1.arrayValidator)(serializedPatchDataValidator)(data)) {
            return;
        }
        return data.map((item) => {
            const context = new action_1.DataConnectorActionContext(actions['packageId'], item['packageVersion'], item['userCredential'], actions['dataConnectorName'], actions['dataConnectorName'], actions['documentCollections'], actions['updateFilterType']);
            const patches = parseSerializedPatches(item['patches']);
            return new action_1.DataConnectorPatchAction(context, patches);
        });
    }
    if (!actions['packageVersion'] || !actions['userCredential']) {
        return;
    }
    if (name === dataconnectoractionkeys_1.DataConnectorActionKeys.UnbatchedPatch) {
        if (!serializedPatchDataValidator(data)) {
            return;
        }
        const context = new action_1.DataConnectorActionContext(actions['packageId'], actions['packageVersion'], actions['userCredential'], actions['dataConnectorName'], actions['dataConnectorName'], actions['documentCollections'], actions['updateFilterType']);
        return [
            new action_1.DataConnectorPatchAction(context, parseSerializedPatches(data['patches']), dataconnectoractionkeys_1.DataConnectorActionKeys.UnbatchedPatch),
        ];
    }
    const context = new action_1.DataConnectorActionContext(actions['packageId'], actions['packageVersion'], actions['userCredential'], actions['dataConnectorName'], actions['dataConnectorName'], actions['documentCollections'], actions['updateFilterType']);
    if (name == 'ManageWebhook') {
        if (!serializedManageWebhookDataValidator(data)) {
            return;
        }
        const webhooks = data['webhooks'].map((webhook) => new action_1.Webhook(webhook['documentCollections'], webhook['webhookData']));
        return [new action_1.DataConnectorManageWebhookAction(context, data['webhookToken'], webhooks)];
    }
    if (actions['documentUpdateToken']) {
        return [
            new action_1.DataConnectorAsynchronousAction(name, context, client.getDataSourceClient(actions['documentUpdateToken']), data),
        ];
    }
    return [new action_1.DataConnectorSynchronousAction(name, context, data)];
}
exports.deserializeActions = deserializeActions;
